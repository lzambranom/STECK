#INCLUDE "PROTHEUS.CH"
#INCLUDE "CTBXFUN.CH"
    
#DEFINE D_PRELAN		"9"

STATIC __Ct105CT2		// Ponto de entrada complementar CT2
STATIC aCtbIni := {}
STATIC __aTamVlr := TamSX3("CT7_DEBITO")

**************************************************************
*                                                                    *
*                   VALIDACOES PARA LANCAMENTO CONTABIL              *
*                                                                    *
**************************************************************
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ValidaBloq³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 07.03.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida se Entidade Contabil esta bloqueada pela data       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ValidaBloq(cEntidade,dDAta,cAlias)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. / .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Entidade                                           ³±±
±±³          ³ ExpD1 = Data                                               ³±±
±±³          ³ ExpC2 = Alias                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValidaBloq(cEntidade,dData,cAlias,lHelp)

Local aSaveArea:= GetArea()
Local lRet		:= .T.
DEFAULT lHelp := .T.

If !Empty(cEntidade)
	dbSelectArea(cAlias)
	dbSetOrder(1)
	If MsSeek(xFilial()+cEntidade)
		If &(cAlias+"_BLOQ") == "1"
			If (!Empty(&(cAlias+"_DTBLINI")) .And. !Empty(&(cAlias+"_DTBLINI")))
				If DTOS(dData) >= DTOS(&(cAlias+"_DTBLINI")) .And.;
					DTOS(dData) <= DTOS(&(cAlias+"_DTBLFIM"))
					// Data do lancamento entre os limites da data de bloqueio
					If lHelp
						Help(" ",1,"CTA_DTBLOQ")
					EndIf
					lRet := .F.
				EndIf	
			Else
				If lHelp
					Help(" ",1,"CTA_BLOQ")
				EndIf
				lRet := .F.				
			EndIf
		EndIf
		If lRet 
			If DTOS(dData) < DTOS(&(cAlias+"_DTEXIS"))
				// Data do lancamento menor do que a data de existencia da conta
				If lHelp
					Help("  ", 1, "CTA_DTEXIS")
				EndIf
				lRet := .F.
			EndIf							
					
			//Verificar se existe o campo CT1_DTEXSF
			If CtbExDtFim(cAlias)
				If !CtbVlDtFim(cAlias,dData)
				If lHelp
					MsgAlert(STR0070)	// Data do lancamento maior do que a data final de existencia da entidade
				EndIf
					lRet	:= .F.
				EndIf
			EndIf    			
		EndIf	
	EndIf
EndIf

RestArea(aSaveArea)

Return lRet            

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ValidaValo³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida Valor digitado                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ValidaValor(nValor)                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T./.F.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Valor do Lancamento                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValidaValor(nValor)

Local nValorAnt	:= 0
Local lRet		:= .T. 
Local aSaveArea:= GetArea()
Local nValLcto	:= 0
Local nCont		:= 0
Local cCriter	:= ""

If "CT2_VALOR" $ ReadVar()
	nValLcto    := M->CT2_VALOR
	nValorAnt	:= TMP->CT2_VALOR
ElseIf "CT2_VALR" $ ReadVar()
	nValLcto    := &("M->CT2_VALR" + Right(ReadVar(), 2))
	nValorAnt	:= &("TMP->CT2_VALR" + Right(ReadVar(), 2))
Endif    

If TMP->CT2_DC $ "123"
	If nValLcto <> nValorAnt 
		If nValorAnt = 0 .And. nValLcto > 0	//Se o valor anterior era zero e alterei para outro valor
			TMP->CT2_CONVER	:= "1" + SUBS(TMP->CT2_CONVER,2,LEN(TMP->CT2_CONVER))
		ElseIf nValorAnt > 0 .And. nValLcto = 0		
			For nCont := 2 to __nQuantas 
				If Subs(TMP->CT2_CONVER,nCont,1) = "4"
					cCriter += "4"
				Else
					cCriter	+= "5" 
				EndIf
			Next	                           
			TMP->CT2_CONVER	:= "5" + cCriter
	    EndIf
	Endif
EndIf

If lRet
	If nValor < 0 
		Help(" ",1,"POSIT")	
		lRet := .F.
		nSaida++
	EndIf		
EndIf
If lRet 
	IF nValor != 0 .and. TMP->CT2_DC == "4"
		Help(" ",1,"CONTHIST")
		lRet := .F.
		nSaida++
	End
EndIf

// Atualiza rodape -> MSGETDB => SOMENTE SE A LINHA NAO ESTIVER DELETADA!!!
If lRet .And. ! TMP->CT2_FLAG
	CTB102Exibe(nValor,nValorAnt,TMP->CT2_DC,TMP->CT2_DC,GetMv("MV_SOMA"))
EndIf

RestArea(aSaveArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ValidaHist³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida Historico Digitado                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ValidaHist(cHP)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Historico Padrao                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValidaHist(cHP)

Local aSaveArea := GetArea()

IF !Empty(cHP)
	dbSelectArea("CT8")
	dbSetOrder(1)
	If MsSeek(xFilial()+cHP)
    	If  CT8->CT8_IDENT == 'I' //Se for historico inteligente, monta a tela do historico
    		If TMP->(Recno()) <> TMP->(RecCount())
				MsgInfo(STR0069,STR0003)
				RestArea(aSaveArea)			
    			Return .F.
    		Endif
    		If Empty(TMP->CT2_DC)
				Help("",1,"CT2_DC")
				RestArea(aSaveArea)			
    			Return .F.
    		Endif
			MontHistInt(cHp)	              
		Else
			TMP->CT2_HIST := CT8->CT8_DESC
	   	Endif			
	EndIf
EndIF

RestArea(aSaveArea)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ValidaCrit³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida Criterio de Conversao                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ValidaCriter(cCriterio)                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T./.F.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Criterio de Conversao                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValidaCriter(cCriterio,cProg)

Local nCont
Local lRet 		:= .T.
Local cCriterAnt:= ""
Local cCriterAtu:= ""	
Local dData	:= CTOD("  /  /  ")

cProg	:= Iif(cProg == Nil,"",cProg)

IF Empty(cCriterio)
	lRet := .F.
EndIF

If lRet	//Se for Lancam. Contab. por Folder considerar o acols
	If cProg == 'CTBA101' 
		If aCols[n][1] ==  '01'			//Na moeda 01 nao podera digitar nada, so sera alterado qdo alterar
			Help(" ",1,"ERRO_CRITE")	//o valor na moeda 01. 
			Return .F.
		Else
			If !(cCriterio $ "12345678")
				Help(" ",1,"ERRO_CRITE")
				Return .F.
			Else
				//Verificar se existe amarracao moeda x calendario na moeda que esta alterando a conversao 
				//So sera verificado se o criterio de conversao for diferente de "5" => Nao tem conversao.
				If cCriterio <> "5"
					If !Empty(dDataLanc)
						lRet := CtbDtComp(4,dDataLanc,aCols[n][1],.T.)				
						If !lRet
							Return .F.
						EndIf	
					Endif
				EndIf									
			EndIf					
	    Endif	
	Else
		For nCont := 1 To Len(Trim(cCriterio))
			If nCont = 1//Na moeda 01 podera ser digitado somente 1 ou 5=>pois nao utiliza criterio de conversao                             	
				cCriterAnt	:= Subs(TMP->CT2_CONVER,1,1)
				cCriterAtu	:= Subs(M->CT2_CONVER,1,1)
				//Na moeda 01, nao sera possivel alterar o criterio de conversao. O criterio so 
				//sera alterado quando alterar o valor. ( na moeda 01)				
//				If !SubStr(cCriterio,nCont,1) $ "15"	
				If cCriterAnt	<> cCriterAtu
					Help(" ",1,"ERRO_CRITE")
					Return .F.
				EndIf		
			Else
				IF !SubStr(cCriterio,nCont,1) $ "12345678"
					Help(" ",1,"ERRO_CRITE")
					Return .F.
				Else
					//Verificar se existe amarracao moeda x calendario na moeda que esta alterando a conversao 
					//So sera verificado se o criterio de conversao for diferente de "5" => Nao tem conversao.
					If !SubStr(cCriterio,nCont,1) $ "5"
						If !Empty(TMP->CT2_DATA)
							dData	:= TMP->CT2_DATA
						ElseIf !Empty(dDataLanc)
							dData	:= dDataLanc
						EndIf
						If !Empty(dData)
							lRet := CtbDtComp(4,dData,StrZero(nCont,2),.T.)				
							If !lRet
								Return .F.
							EndIf	
						Endif
					EndIf						
				EndIf		
			EndIf		
		Next
	EndIf
Endif
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ValidaMoed³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida quais moedas estao sendo lancadas                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ValidaMoedas(cMoedas)                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T./.F.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Moedas Lancadas                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValidaMoedas(cMoedas)

Local aSaveArea:= GetArea()
Local lRet 		:= .T.
Local nCont

IF Empty(cMoedas) .and. TMP->CT2_DC $ "123"
	lRet := .F.
EndIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Consiste apenas quando n„o for continua‡„o do historico      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet 
	For nCont:= 1 TO Len(Trim(cMoedas))
		If !SubStr(cMoedas,nCont,1) $ "12" .and. TMP->CT2_DC $ "123"
			Help(" ",1,"ca050Moeda")
			nSaida++
			lRet := .f.
			Exit
		EndIF
	Next i
EndIf

RestArea(aSaveArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³CtbValLig ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida a amarracao de cadastros                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbValLig(cClasse)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T./.F.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Classe                                             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbValLig(cClasse)

Local aSaveArea := GetArea()
Local lRET		:= .T.

If cClasse == "1"
	Help(" ",1,"CTBNOLIG")	
	lRet := .F.
EndIf

RestArea(aSaveArea)

Return lRet	

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³CtbMInUse ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 19.01.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se a moeda esta bloqueada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CTBMInUse(cMoeda)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T./.F.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Moeda                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CTBMInUse(cMoeda)

Local aSaveArea:= GetArea()
Local lRet		:= .T.	

dbSelectArea("CTO")
dbSetOrder(1)
If !MsSeek(xFilial()+cMoeda)
	lRet := .F.
Else
	If CTO->CTO_BLOQ == "1"		// Moeda Bloqueada
		lRet := .F.
	EndIf
EndIf		

RestArea(aSaveArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³CtbDtInUse³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 19.01.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se a data esta bloqueada                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbDtInUse(cMoeda,dData)                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T./.F.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 =Moeda												  ³±±
±±³			 ³ExpD1 =Data                                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CTBDtInUse(cMoeda,dData)

Local aSaveArea:= GetArea()
Local lRet		:= .T.	

dbSelectArea("CTP")
dbSetOrder(1)
If !MsSeek(xFilial()+DTOS(dData)+cMoeda)
	lRet := .F.
Else	
	If CTP->CTP_BLOQ == "1"		// Data Bloqueada para a moeda
		lRet := .F.
	EndIf
EndIf		

RestArea(aSaveArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³CtbUso    ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 19.01.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se o campo esta em uso.                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbUso(ccampo)                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T./.F.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 =Campo												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbUso(cCampo)
Local aSaveArea:= GetArea()
Local lRet		:= .F.
Local aAreaSx3 := SX3->(GetArea())
dbSelectArea( "SX3" )
dbSetOrder( 2 )
MsSeek( cCampo )
If X3USO( X3_USADO )
	lRet := .t.
EndIf
RestArea(aAreaSX3)
RestArea(aSaveArea)
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³GravaCtC  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Totais do Documento Contabil                        	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³GRAVACTC(cLote,cSubLote,cDoc,cTipo,dData,cMoeda,nValor,cTpSald)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Lote do Lancamento Contabil                      	 ³±±
±±³          ³ ExpC2 = Sub-Lote do Lancamento Contabil              	     ³±±
±±³          ³ ExpC3 = Documento do Lancamento Contabil          	         ³±±
±±³          ³ ExpC4 = Tipo do Lancamento Contabil                  	     ³±±
±±³          ³ ExpD1 = Data do Lancamento Contabil              	         ³±±
±±³          ³ ExpN6 = Valor do Lancamento Contabil        		          	 ³±±
±±³          ³ ExpC7 = Tipo do saldo                                     	 ³±±
±±³          ³ 1 - Real = 2 - Orcado = 3 - Gerencial = 4 - Pre-Lancamento	 ³±±
±±³          ³ lPartDob = Indica se eh partida dobrada ou nao                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GRAVACTC(cLote,cSubLote,cDoc,cTipo,dData,cMoeda,nValor,cTpSald,lPartDob)

Local aSaveArea := GetArea()
Local lInclui	:= .F.
Local nMvSoma	:= Getmv("MV_SOMA") //Determina se o lancam. tipo 3 ira ser somado 1 ou 2 vezes

If nValor <= 0
	Return
EndIf	

BEGIN TRANSACTION 
	DbSelectArea( "CTC" )
	DbSetOrder( 3 )
	If !MsSeek(xFilial()+cMoeda+cTpSald+cLote+cSubLote+cDoc+Dtos(dData),.T.)
		lInclui := .T.
	Else
		lInclui := .F.
	EndIf

	// Nao ha registro para o dia -> cria!!
	If lInclui
		RecLock( "CTC", .t. )
		CTC->CTC_FILIAL 	:= xFilial()
		CTC->CTC_DATA		:= dData
		CTC->CTC_LOTE		:= cLote
		CTC->CTC_SBLOTE		:= cSubLote
		CTC->CTC_DOC		:= cDoc
		CTC->CTC_MOEDA		:= cMoeda
		CTC->CTC_STATUS		:= "1"						// Periodo Aberto
		CTC->CTC_TPSALD		:= cTpSald					// Real / Orcado / Gerencial / Pre
	Else
		RecLock( "CTC", .f. )
	Endif

	// Grava valores atuais
	If cTipo == "1"
		CTC->CTC_DEBITO	:= (CTC->CTC_DEBITO + nValor)
	ElseIf cTipo == "2"
		CTC->CTC_CREDIT	:= (CTC->CTC_CREDIT + nValor)
	EndIf	      

	//Se o tipo do lancamento e 3, verifica o parametro MV_SOMA:caso seja 1, soma 1 vez
	//Se for igual a 2, soma 2 vezes no valor digitado.

	If lPartDob
		If nMvSoma == 1 .And. cTipo == '1'        
		    CTC->CTC_DIG := CTC->CTC_DIG + nValor
		Elseif nMvSoma == 2
			CTC->CTC_DIG := CTC->CTC_DIG + nValor
		EndIf 
	Else
  	  	CTC->CTC_DIG := CTC->CTC_DIG + nValor
	Endif    

	MsUnlock()
	FKCOMMIT()	
END TRANSACTION 

RestArea(aSaveArea)

Return
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³DsGravaCtC³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Desgrava Totais do Documento Contabil                        	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³DSGRAVACTC(cLote,cSubLote,cDoc,cTipo,dData,cMoeda,nValor,		 ³±±
±±³		 	 ³cTpSald)														 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Lote do Lancamento Contabil                      	 ³±±
±±³          ³ ExpC2 = Sub-Lote do Lancamento Contabil              	     ³±±
±±³          ³ ExpC3 = Documento do Lancamento Contabil          	         ³±±
±±³          ³ ExpC4 = Tipo do Lancamento Contabil                  	     ³±±
±±³          ³ ExpD1 = Data do Saldo                                	     ³±±
±±³          ³ ExpC5 = Moeda                                    	         ³±±
±±³          ³ ExpN6 = Valor do Lancamento Contabil        		          	 ³±±
±±³          ³ ExpC7 = Tipo do saldo                                     	 ³±±
±±³          ³ 1 - Real = 2 - Orcado = 3 - Gerencial = 4 - Pre-Lancamento	 ³±±
±±³          ³ lPartDob = Indica se eh partida dobrada ou nao                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function DSGRAVACTC(cLote,cSubLote,cDoc,cTipo,dData,cMoeda,nValor,cTpSald,lPartDob)

Local aSaveArea := GetArea()
Local nMvSoma	:= Getmv("MV_SOMA") //Determina se o lancam. tipo 3 ira ser somado 1 ou 2 vezes

	DbSelectArea( "CTC" )
	DbSetOrder( 3 )
	If !MsSeek(xFilial()+cMoeda+cTpSald+cLote+cSubLote+cDoc+Dtos(dData),.T.)
		// Neste caso, não há alteração de valores, pois não o documento
		Return                                                            
	EndIf         
	
BEGIN TRANSACTION 
	RecLock( "CTC", .f. )
	// Descalcula - Subtrai valores aos ja existentes
	If cTipo == "1"
		If CTC->CTC_DEBITO < nValor
			CTC_DEBITO := 0
		Else	
			CTC->CTC_DEBITO	:= (CTC->CTC_DEBITO - nValor)
		EndIf	
	ElseIf cTipo == "2"
		If CTC->CTC_CREDIT < nValor
			CTC_CREDIT := 0
		Else
			CTC->CTC_CREDIT	:= (CTC->CTC_CREDIT - nValor)
		EndIf	
	EndIf

	//Se o tipo do lancamento e 3, verifica o parametro MV_SOMA:caso seja 1, soma 1 vez
	//Se for igual a 2, soma 2 vezes no valor digitado.

	If lPartDob
		If nMvSoma == 1 .And. cTipo == '1'
		    CTC->CTC_DIG := CTC->CTC_DIG - nValor
		Elseif nMvSoma == 2
			CTC->CTC_DIG := CTC->CTC_DIG - nValor
		EndIf 
	Else
	  	CTC->CTC_DIG := Iif(CTC->CTC_DIG >0,CTC->CTC_DIG - nValor,0)			
	Endif
     
	MsUnlock()
	FKCOMMIT()	
END TRANSACTION 

RestArea(aSaveArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³GravaCt6  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Totais do Lote Contabil                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GRAVACT6(cLote,cSubLote,cTipo,dData,cMoeda,nValor,cTpSald, ³±±
±±³			 | lPartDob)       						                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Lote do Lancamento Contabil                        ³±±
±±³          ³ ExpC2 = Sub-Lote do Lancamento Contabil                    ³±±
±±³          ³ ExpC3 = Tipo do Lancamento Contabil                        ³±±
±±³          ³ ExpD4 = Data do Lancamento Contabil                        ³±±	
±±³          ³ ExpC5 = Moeda do Lancamento Contabil                  	  ³±±
±±³          ³ ExpN1 = Valor do Lancamento Contabil                  	  ³±±
±±³          ³ ExpC6 = Tipo do saldo                                      ³±±
±±³          ³ 1 - Real = 2 - Orcado = 3 - Gerencial = 4 - Pre-Lancamento ³±±
±±³          ³ ExpL1 = Indica se eh partida dobrada ou nao                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GRAVACT6(cLote,cSubLote,cTipo,dData,cMoeda,nValor,cTpSald,lPartDob)

Local aSaveArea	:= GetArea()
Local lInclui		:= .F.
Local nMvSoma	  :=Getmv("MV_SOMA") //Determina se o lancam. tipo 3 ira ser somado 1 ou 2 vezes
If nValor <= 0
	Return
EndIf	

BEGIN TRANSACTION 
	DbSelectArea( "CT6" )
	DbSetOrder(3)
	If !MsSeek(xFilial()+cMoeda+cTpSald+cLote+cSubLote+Dtos(dData),.T.)
		lInclui := .T.
	Else
		lInclui := .F.
	EndIf

	// Nao ha registro para o dia -> cria!!
	If lInclui
		RecLock( "CT6", .t. )
		CT6->CT6_FILIAL	:= xFilial()
		CT6->CT6_DATA		:= dData
		CT6->CT6_LOTE		:= cLote
		CT6->CT6_SBLOTE		:= cSubLote
		CT6->CT6_MOEDA		:= cMoeda
		CT6->CT6_STATUS		:= "1"				// Periodo Aberto
		CT6->CT6_TPSALD		:= cTpSald			// Real / Orcado / Gerencial
	Else
		RecLock("CT6", .f.)
	Endif

	// Grava valores atuais
	If cTipo == "1"
		CT6->CT6_DEBITO	:= (CT6->CT6_DEBITO + nValor)
	ElseIf cTipo == "2"
		CT6->CT6_CREDIT	:= (CT6->CT6_CREDIT + nValor)
	EndIf	                
             
	//Se o tipo do lancamento e 3, verifica o parametro MV_SOMA:caso seja 1, soma 1 vez
	//Se for igual a 2, soma 2 vezes no valor digitado.

	If lPartDob
		If nMvSoma == 1 .And. cTipo == '1'        
		    CT6->CT6_DIG := CT6->CT6_DIG + nValor
		Elseif nMvSoma == 2
			CT6->CT6_DIG := CT6->CT6_DIG + nValor
		EndIf 
	Else
  	  	CT6->CT6_DIG := CT6->CT6_DIG + nValor
	Endif    

	MsUnlock()        
	FKCOMMIT()	
END TRANSACTION 	

	
RestArea(aSaveArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³DsGravaCt6³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Desgrava Totais do Lote Contabil                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³DSGRAVACT6(cLote,cSubLote,cTipo,dData,cMoeda,nValor,cTpSald,³±±
±±³			 | lPartDob)       						                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Lote do Lancamento Contabil                        ³±±
±±³          ³ ExpC2 = Sub-Lote do Lancamento Contabil                    ³±±
±±³          ³ ExpC3 = Tipo do Lancamento Contabil                        ³±±
±±³          ³ ExpD4 = Data do Lancamento Contabil                        ³±±	
±±³          ³ ExpC5 = Moeda do Lancamento Contabil                  	  ³±±
±±³          ³ ExpN1 = Valor do Lancamento Contabil                  	  ³±±
±±³          ³ ExpC6 = Tipo do saldo                                      ³±±
±±³          ³ 1 - Real = 2 - Orcado = 3 - Gerencial = 4 - Pre-Lancamento ³±±
±±³          ³ ExpL1 = Indica se eh partida dobrada ou nao                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function DSGRAVACT6(cLote,cSubLote,cTipo,dData,cMoeda,nValor,cTpSald,lPartDob)

Local aSaveArea  := GetArea()
Local nMvSoma	  :=Getmv("MV_SOMA") //Determina se o lancam. tipo 3 ira ser somado 1 ou 2 vezes


DbSelectArea( "CT6" )
DbSetOrder(3)
If !MsSeek(xFilial()+cMoeda+cTpSald+cLote+cSubLote+Dtos(dData),.T.)
	Return
EndIf         
	
BEGIN TRANSACTION 
	RecLock("CT6", .f.)
	// Descalcula - Subtrai valores aos ja existentes
	If cTipo == "1"
		If CT6->CT6_DEBITO < nValor
			CT6_DEBITO := 0
		Else
			CT6->CT6_DEBITO	:= (CT6->CT6_DEBITO - nValor)
		EndIf	
	ElseIf cTipo == "2"
		If CT6->CT6_CREDIT < nValor
			CT6_CREDIT := 0
		Else
			CT6->CT6_CREDIT	:= (CT6->CT6_CREDIT - nValor)
		EndIf	
	EndIf

	//Se o tipo do lancamento e 3, verifica o parametro MV_SOMA:caso seja 1, soma 1 vez
	//Se for igual a 2, soma 2 vezes no valor digitado.

	If lPartDob
		If nMvSoma == 1 .And. cTipo == '1'
		    CT6->CT6_DIG := CT6->CT6_DIG - nValor
		Elseif nMvSoma == 2
			CT6->CT6_DIG := CT6->CT6_DIG - nValor
		EndIf 
	Else
	  	CT6->CT6_DIG := Iif(CT6->CT6_DIG >0,CT6->CT6_DIG - nValor,0)			
	Endif
     
	MsUnlock()         
	FKCOMMIT()	
END TRANSACTION 	

RestArea(aSaveArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³GravaCt7  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Saldos das Contas Contabeis e atualiza saldo dia dia ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GRAVACT7(cConta,cTipo,dData,cMoeda,nValor,cTpSald)         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                     ³±±
±±³          ³ ExpC2 = Tipo do Lancamento Contabil                        ³±±
±±³          ³ ExpD1 = Data do Lancamento Contabil                        ³±±
±±³          ³ ExpC3 = Moeda do Lancamento Contabil                       ³±±
±±³          ³ ExpN1 = Valor do Lancamento Contabil                  	  ³±±
±±³          ³ ExpC4 = Tipo do Saldo                                  	  ³±±
±±³          ³ ExpL1 = Define se foi chamado pelo Reprocessamento     	  ³±±
±±³          ³ ExpL2 = Define se o saldo basico eh atualizado na dig.lanc.³±±
±±³          ³ ExpL3 = Define se deve zerar os movimentos.            	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GRAVACT7(cConta,cTipo,dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,lZera,dDataLP)

Local aSaveArea	:= GetArea()
Local lInclui	:= .F.
Local nAntDeb	:= 0
Local nAntCrd	:= 0
Local aSldAntCT7:= {}
Local cChave	:= ""

lReproc 		:= Iif(lReproc==Nil,.F.,lReproc)
lAtSldBase 		:= Iif(lAtSldBase==Nil,.T.,lAtSldBase)                                                                               
lZera			:= Iif(lZera == Nil,.F.,lZera)
dDataLP		    := Iif(dDataLP == Nil, CTOD("  /  /  "), dDataLP)

If Empty(cConta) .Or. nValor <= 0
	Return
EndIf	         

BEGIN TRANSACTION
	DbSelectArea( "CT7" )
	If Empty(dDataLP)
		cChave	:= xFilial()+cMoeda+cTpSald+cConta+Dtos(dData)
	Else
		cChave	:= xFilial()+cMoeda+cTpSald+cConta+Dtos(dData)+"Z"	
	EndIf
		
	DbSetOrder( 1 )  
	If ! MsSeek(cChave)
		lInclui	:= .T.
	Else
		lInclui := .F.
		//Se nao for lancamento de zeramento e posicionar no saldo de zeramento.
		//Devera ser incluido um novo registro. 		
		If Empty(dDataLP) .And. CT7->CT7_LP == 'Z'
			lInclui := .T.			
		EndIf
	EndIf

	// Nao ha registro para o dia -> cria!!
	If lInclui
		RecLock( "CT7", .t. )
		CT7->CT7_FILIAL 	:= xFilial()
		CT7->CT7_CONTA		:= cConta
		CT7->CT7_MOEDA		:= cMoeda
		CT7->CT7_DATA		:= dData
		CT7->CT7_TPSALD		:= cTpSald					// Real / Orcado / Gerencial
		CT7->CT7_STATUS		:= "1"						// Periodo Aberto
		If !Empty(dDataLP)
			CT7->CT7_LP 	:= 'Z'						//Se for lancamento de zeramento
		Else
			CT7->CT7_LP			:= "N"					// Flag indicando que ainda nao foi zerado
		EndIf
	Else			
		RecLock( "CT7", .f. )
		//Se o programa for CTBA360, devo zerar os movimentos
		If lZera
			If cTipo == "1"
				CT7->CT7_DEBITO	:= 0
			ElseIf cTipo == "2"
				CT7->CT7_CREDIT	:= 0			
			EndIf
		EndIf
	Endif
	
	//Rotina para recuperar saldo anterior                  
    If !lInclui .And. lZera 	//Se for CTBA360.
		aSldAntCT7 := SldAntCT7(cConta,dData,cMoeda,cTpSald,,.T.)
	Else
		aSldAntCT7 := SldAntCT7(cConta,dData,cMoeda,cTpSald,,lInclui)
	EndIf                                                                 
	nAntDeb	:= aSldAntCT7[1]
	nAntCrd	:= aSldAntCT7[2]

	// Grava valores atuais
	// Soma valores aos ja existentes
	If cTipo == "1"
		CT7->CT7_DEBITO	:= (CT7->CT7_DEBITO + nValor)
		#IFDEF TOP
			CT7->CT7_ANTDEB	:= nAntDeb
			CT7->CT7_ATUDEB	:= CT7->CT7_ANTDEB+CT7->CT7_DEBITO
			CT7->CT7_ANTCRD	:= nAntCrd
			CT7->CT7_ATUCRD	:= CT7->CT7_ANTCRD+CT7->CT7_CREDIT
		#ENDIF		
	ElseIf cTipo == "2"
		CT7->CT7_CREDIT	:= (CT7->CT7_CREDIT + nValor)
		#IFDEF TOP
			CT7->CT7_ANTCRD	:= nAntCrd
			CT7->CT7_ATUCRD	:= CT7->CT7_ANTCRD+CT7->CT7_CREDIT
			CT7->CT7_ANTDEB	:= nAntDeb
			CT7->CT7_ATUDEB	:= CT7->CT7_ANTDEB+CT7->CT7_DEBITO
		#ENDIF		
	EndIf	            	
	
	//Atualiza flag de saldo basico.	
	#IFDEF TOP
		CT7->CT7_SLBASE	:= "S"
	#ENDIF
	MsUnlock()        

                                                                 
                        
	//Chama funcao que grava o saldo anterior e o saldo atual
	GRVSLDCT7(cTipo,cConta,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,lAtSldBase,,lZera,"+")

END TRANSACTION

RestArea(aSaveArea)

Return 

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³SldAntCT7 ³ Autor ³ Simone Mie Sato       ³ Data ³ 16.10.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Recupera saldo anterior a data inicial                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³SLDANTCT7(cConta,dData,cMoeda,cTpSald) 					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                     ³±±
±±³          ³ ExpD1 = Data do Lancamento Contabil                        ³±±
±±³          ³ ExpC2 = Moeda do Lancamento Contabil                       ³±±
±±³          ³ ExpC3 = Tipo do Saldo                                  	  ³±±
±±³          ³ ExpC4 = Codigo da Filial                               	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SLDANTCT7(cConta,dData,cMoeda,cTpSald,cFilX,lDbSkip1)
                                                                           
Local aSaveArea	:= GetArea()
Local nAntDeb		:= 0	//Saldo anterior Debito Conta
Local nAntCrd		:= 0	//Saldo anterior Credito Conta


#IFDEF TOP                             
	Local aTamVlr		:= TAMSX3("CT7_ATUDEB")
	Local cQuery		:= ""
	Local cOrderCT7 	:= ""
	Local cAliasCT7 	:= ""   		
#ENDIF

DEFAULT lDbSkip1 := .T.

If cFilX == Nil
	cFilX := xFilial("CT7")
EndIf

#IFDEF TOP                             
	If TcSrvType() != "AS/400"                     		
		cOrderCT7 := SqlOrder(indexKey())
		cAliasCT7 := "cAliasCT7"   		

		cQuery := "SELECT CT7_DATA, CT7_ATUDEB, CT7_ATUCRD "
		cQuery += "FROM "+RetSqlName("CT7")+" CT7 "
		cQuery += "WHERE CT7.CT7_FILIAL ='"+cFilX+"' AND "
		cQuery += "CT7.CT7_MOEDA ='"+cMoeda+"' AND "
		cQuery += "CT7.CT7_TPSALD ='"+cTpSald+"' AND "
		cQuery += "CT7.CT7_CONTA = '"+cConta+"' AND "		 		
		cQuery += "CT7.D_E_L_E_T_ <> '*' AND "				
		cQuery += "CT7.CT7_DATA = (SELECT MAX(CT7_DATA) "
		cQuery += "FROM "+RetSqlName("CT7")+" CT72 "
		cQuery += "WHERE CT72.CT7_FILIAL ='"+cFilX+"' AND "			
		cQuery += "CT72.CT7_MOEDA = '"+cMoeda+"' AND "	 
		cQuery += "CT72.CT7_TPSALD = '"+cTpSald+"' AND "					
		cQuery += "CT72.CT7_CONTA = '"+cConta+"' AND "		 
		cQuery += "CT72.CT7_DATA < '"+DTOS(dData)+"' AND "		 
		cQuery += "CT72.D_E_L_E_T_ <> '*') AND "
		cQuery += "CT7.CT7_LP = (SELECT MAX(CT7_LP) "
		cQuery += "FROM "+RetSqlName("CT7")+" CT73 "
		cQuery += "WHERE CT73.CT7_FILIAL ='"+cFilX+"' AND "			
		cQuery += "CT73.CT7_MOEDA = '"+cMoeda+"' AND "	 
		cQuery += "CT73.CT7_TPSALD = '"+cTpSald+"' AND "					
		cQuery += "CT73.CT7_CONTA = '"+cConta+"' AND "		 
		cQuery += "CT73.CT7_DATA =  (SELECT MAX(CT7_DATA) "
		cQuery += "FROM "+RetSqlName("CT7")+" CT74 "
		cQuery += "WHERE CT74.CT7_FILIAL ='"+cFilX+"' AND "			
		cQuery += "CT74.CT7_MOEDA = '"+cMoeda+"' AND "	 
		cQuery += "CT74.CT7_TPSALD = '"+cTpSald+"' AND "					
		cQuery += "CT74.CT7_CONTA = '"+cConta+"' AND "		 
		cQuery += "CT74.CT7_DATA < '"+DTOS(dData)+"' AND "		 
		cQuery += "CT74.D_E_L_E_T_ <> '*') AND "
		cQuery += "CT73.D_E_L_E_T_ <> '*')"		
		cQuery := ChangeQuery(cQuery)		   
		If ( Select ( cAliasCT7 ) <> 0 )
			dbSelectArea ( cAliasCT7 )
			dbCloseArea ()
		Endif

  		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasCT7,.T.,.F.)
  		
		TCSetField(cAliasCT7,"CT7_DATA", "D",8,0)				  		
		TCSetField(cAliasCT7,"CT7_ATUDEB", "N",aTamVlr[1],aTamVlr[2])	
		TCSetField(cAliasCT7,"CT7_ATUCRD", "N",aTamVlr[1],aTamVlr[2])			
		
		nAntDeb := (cAliasCT7)->CT7_ATUDEB
		nAntCrd := (cAliasCT7)->CT7_ATUCRD			
	
		dbCloseArea()
		dbSelectArea("CT7")	                     

		If ( Select ( cAliasCT7 ) <> 0 )
			dbSelectArea ( cAliasCT7 )
			dbCloseArea ()
		Endif			
	Else
#ENDIF  
	//Se for codebase ou As/400
	// Procura saldo anterior -> Para recalculo
	If lDbSkip1
		dbSkip(-1)
	Endif
	
	If (xFilial()+cMoeda+cTpSald+cConta) == ;
		(CT7->CT7_FILIAL+CT7->CT7_MOEDA+CT7->CT7_TPSALD+CT7->CT7_CONTA) .And.;
		(!Bof() .And. !Eof())
		If CT7->CT7_DATA == dData
			If lDbSkip1 .And. CT7->CT7_LP <> "Z"
				nAntDeb		:= CT7->CT7_ATUDEB
				nAntCrd		:= CT7->CT7_ATUCRD		
			Else
				nAntDeb 	:= CT7->CT7_ANTDEB
				nAntCrd 	:= CT7->CT7_ANTCRD	
			EndIf
		Else                               
			nAntDeb 	:= CT7->CT7_ATUDEB
			nAntCrd 	:= CT7->CT7_ATUCRD				
		EndIf
	Else
		nAntDeb	:= 0
		nAntCrd	:= 0
	EndIf
	If (!Bof())
		dbSkip()
	EndIf

#IFDEF TOP
	Endif
#ENDIF

RestArea(aSaveArea)

Return{nAntDeb,nAntCrd}                                    

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³DsGravaCT7³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Desgrava Saldos das Contas Contabeis  					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³DSGRAVACT7(cConta,cTipo,dData,cMoeda,nValor,cTpSald)        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                     ³±±
±±³          ³ ExpC2 = Tipo do Lancamento Contabil                        ³±±
±±³          ³ ExpD1 = Data do Lancamento Contabil                        ³±±
±±³          ³ ExpC3 = Moeda do Lancamento Contabil                       ³±±
±±³          ³ ExpN1 = Valor do Lancamento Contabil                  	  ³±±
±±³          ³ ExpC4 = Tipo do Saldo                                  	  ³±±
±±³          ³ ExpL1 = Define se foi chamado pelo Reprocessamento     	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function DSGRAVACT7(cConta,cTipo,dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,dDataLP,nOpc)

Local aSaveArea := GetArea()
Local nAntDeb	:= 0
Local nAntCrd	:= 0
Local aSldAntCT7:= {}
Local cChave	:= ""
lReproc 		:= Iif(lReproc==Nil,.F.,lReproc)
lAtSldBase		:= Iif(lAtSldBase==Nil,.T.,lAtSldBase) 

dDataLP			:= Iif(dDataLP == Nil,CTOD("  /  /  "),dDataLP )     
nOpc			:= Iif(nOpc == Nil,4,nOpc)

DbSelectArea( "CT7" )
DbSetOrder( 1 )  
If Empty(dDataLP)
	cChave	:= xFilial()+cMoeda+cTpSald+cConta+Dtos(dData)
Else
	cChave	:= xFilial()+cMoeda+cTpSald+cConta+Dtos(dData)+"Z"
EndIf                                                         

If !MsSeek(cChave) .Or. Empty(cConta)
	// Neste caso, não há alteração de valores, pois não achou a conta
	Return                                                            
Else
	//Se nao for lancamento de zeramento e posicionar no saldo de zeramento.
	//Devera ser incluido um novo registro. 		
	If Empty(dDataLP) .And. CT7->CT7_LP == 'Z'
		Return
	EndIf
EndIf	

BEGIN TRANSACTION
	//Rotina para recuperar saldo anterior
	aSldAntCT7 := SldAntCT7(cConta,dData,cMoeda,cTpSald)

	nAntDeb	:= aSldAntCT7[1]
	nAntCrd	:= aSldAntCT7[2]

	// Descalcula - Subtrai valores aos ja existentes
	RecLock("CT7")
	If cTipo == "1"
		If CT7->CT7_DEBITO < nValor
			CT7->CT7_DEBITO := 0
		Else	
			CT7->CT7_DEBITO	:= (CT7->CT7_DEBITO - nValor)
			#IFDEF TOP
				CT7->CT7_ANTDEB	:= nAntDeb
				CT7->CT7_ATUDEB	:= CT7->CT7_ANTDEB+CT7->CT7_DEBITO
				CT7->CT7_ANTCRD	:= nAntCrd
				CT7->CT7_ATUCRD	:= CT7->CT7_ANTCRD+CT7->CT7_CREDIT
			#ENDIF							
		EndIf	
	ElseIf cTipo == "2"
		If CT7->CT7_CREDIT < nValor
			CT7->CT7_CREDIT := 0
		Else	
			CT7->CT7_CREDIT	:= (CT7->CT7_CREDIT - nValor)
			#IFDEF TOP
				CT7->CT7_ANTCRD	:= nAntCrd
				CT7->CT7_ATUCRD	:= CT7->CT7_ANTCRD+CT7->CT7_CREDIT
				CT7->CT7_ANTDEB	:= nAntDeb
				CT7->CT7_ATUDEB	:= CT7->CT7_ANTDEB+CT7->CT7_DEBITO
			#ENDIF										
		EndIf	
	EndIf
	MsUnLock()

	//Se na exclusao, zerar os valores de mov. debito e credito, deleta o registro no 
	//arquivo de saldos, pois no reprocessamento nao refaz os saldos que nao tenham 
	//lancamentos no CT2, e da diferenca no balancete.

	If CT7->CT7_CREDIT == 0  .And. CT7->CT7_DEBITO == 0
		RecLock("CT7",.F.,.T.)
		CT7->(dbDelete())
		CT7->(MsUnlock())
		dbSelectArea("CT7")
		dbSkip()
		//Chama funcao que grava o saldo anterior e o saldo atual	  
		//A variavel latSldBase esta sendo passado como .T. para atualizar o flag		                               		
		If nOpc == 5	//No parametro lReproc esta sendo passado como .F. para atualizar os saldos da data para frente.
			GRVSLDCT7(cTipo,cConta,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,.F.,.T.,,,"-")                       
		Else
			GRVSLDCT7(cTipo,cConta,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,.T.,,,"-")                       		
		EndIf
	Else
		//Chama funcao que grava o saldo anterior e o saldo atual                                                           
		If nOpc == 5	//Se for exclusao de lancamento contabil, atualiza os saldos, pois o lancamento contabil eh deletado
			GRVSLDCT7(cTipo,cConta,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,.F.,.T.,,,"-")                   				
		Else
			GRVSLDCT7(cTipo,cConta,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,lAtSldBase,,,"-")                   		
		EndIf
	Endif
	
END TRANSACTION
RestArea(aSaveArea)

Return 

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³GRVSLDCT7 ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Saldo Anterior e Saldo Atual do CT7				   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³GRVSLDCT7(cConta,cMoeda,cTpSald,nAntDeb,nAntCrd,lReproc,	   ³±±                                                     
±±³          ³lAtSldBase,cFilX)                                       	   ³±±                                                     
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                      ³±±
±±³          ³ ExpC2 = Moeda do Lancamento Contabil                        ³±±
±±³          ³ ExpC3 = Tipo do Saldo                                       ³±±
±±³          ³ ExpN2 = Valor anterior debito                         	   ³±±
±±³          ³ ExpN3 = Valor anterioro credito                       	   ³±±
±±³          ³ ExpL1 = Define se ira atualizar os dias posteriores   	   ³±±
±±³          ³ ExpL2 = Define se devera preencher o flag de atualiz.saldos ³±±
±±³          ³ ExpC1 = Filial											   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GRVSLDCT7(cTipo,cConta,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,lAtSldBase,cFilX,lZera,cOperacao)

Local aSaveArea		:= GetArea()
Local nRegCT7		:= Recno()

#IFDEF TOP
	Local cChave		:= ""
	Local cQuery		:= ""
	Local cGrvSldCT7	:= ""	
	Local nCountReg		:= 0               	
	Local nMax			:= 0
	Local nMin			:= 0
	Local nRecCT7		:= 0	
#ENDIF

lReproc 	 		:= Iif(lReproc==Nil,.F.,lReproc)
lAtSldBase			:= Iif(lAtSldBase==Nil,.T.,lAtSldBase)                      
cFilX				:= Iif(cFilX==Nil,xFilial("CT7"),cFilX)
lZera				:= Iif(lZera == Nil,.F.,lZera)

DEFAULT cOperacao	:= "+"

// Recalcula valores
nRegCT7 := Recno()

If lReproc //Se for Reprocessamento, so deve atualizar o registro atual
	If !Eof() .And. CT7->CT7_FILIAL == cFilX .And. ;
			CT7->CT7_TPSALD == cTpSald .And. CT7->CT7_CONTA == cConta .And. ;
			CT7->CT7_MOEDA == cMoeda				
			RecLock("CT7")
			CT7->CT7_ANTDEB	:= nAntDeb 
			CT7->CT7_ANTCRD	:= nAntCrd
			CT7->CT7_ATUDEB	:= nAntDeb + CT7->CT7_DEBITO
			CT7->CT7_ATUCRD	:= nAntCrd + CT7->CT7_CREDIT                      
			//Se for Reprocessamento ou se for CTBA360, devera estar com flag de atualizado			
			//para nao precisar atualizar novamente. 
			If lAtSldBase .Or. lZera
				CT7->CT7_SLBASE	:= "S"
			Else 		   //Flag de Atualizacao de saldo,para identificar que o
				CT7->CT7_SLBASE	:= "N"//saldo devera ser atualizado a partir desse reg.    
			EndIf
			MsUnlock()	
	Endif
Else	
	#IFDEF TOP                             
		If TcSrvType() != "AS/400"                     			
			CT7->(dbCommit())
			cGrvSldCT7 := "cGrvSldCT7"   		
			cQuery   	:= "SELECT R_E_C_N_O_ RECNO "
			cQuery   	+=" FROM "+RetSqlName("CT7")+" CT7 "
			cQuery		+= "WHERE CT7.CT7_FILIAL = '"+cFilX+"' AND "
			cQuery   	+= "CT7.CT7_TPSALD = '"+cTpSald+"' AND "                  
			cQuery   	+= "CT7.CT7_CONTA ='"+cConta+"' AND "			
			cQuery   	+= "CT7.CT7_MOEDA ='"+cMoeda+"' AND "			
			cQuery 		+= "CT7_DATA > '"+Dtos(dData)+"' AND "		
			cQuery   	+= "D_E_L_E_T_<>'*'" 		
			cQuery   	+= "ORDER BY RECNO" 		
			cQuery		:= ChangeQuery(cQuery)   
		
			If ( Select ( cGrvSldCT7 ) <> 0 )
				dbSelectArea ( cGrvSldCT7 )
				dbCloseArea ()
			Endif
			
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cGrvSldCT7,.T.,.F.)
			
			cQuery := "UPDATE "
			cQuery += RetSqlName("CT7")+" "				
			cQuery += "SET " 
			If cTipo = "1"
				cQuery += "CT7_ANTDEB = CT7_ANTDEB " + cOperacao + (Str(nValor,TAMSX3("CT7_ANTDEB")[1],TAMSX3("CT7_ANTDEB")[2])) +", "
				cQuery += "CT7_ATUDEB = CT7_ATUDEB " + cOperacao + (Str(nValor,TAMSX3("CT7_ATUDEB")[1],TAMSX3("CT7_ATUDEB")[2])) + " "   			
			ElseIf cTipo = "2"	
				cQuery += "CT7_ANTCRD =  CT7_ANTCRD " + cOperacao + (Str(nValor,TAMSX3("CT7_ANTCRD")[1],TAMSX3("CT7_ANTCRD")[2])) + ", "   			
				cQuery += "CT7_ATUCRD =  CT7_ATUCRD " + cOperacao + (Str(nValor,TAMSX3("CT7_ATUCRD")[1],TAMSX3("CT7_ATUCRD")[2])) + " "   			    
			EndIf
			cQuery += "WHERE CT7_FILIAL = '"+cFilX+"' AND "
			cQuery += "CT7_TPSALD = '"+cTpSald+"' AND "                           
			cQuery += "CT7_CONTA ='"+cConta+"' AND "			
			cQuery += "CT7_MOEDA ='"+cMoeda+"' AND "			
			cQuery += "CT7_DATA > '"+Dtos(dData)+"' AND "
			cQuery 	+= "D_E_L_E_T_<>'*' AND " 		
		
			While cGrvSldCT7->(!EOF())
		
				nMin := (cGrvSldCT7)->RECNO
				
				nCountReg := 0
				
				While cGrvSldCT7->(!EOF()) .and. nCountReg <= 4096
				
					nMax := (cGrvSldCT7)->RECNO
					nCountReg++
					cGrvSldCT7->(DbSkip())

				End
				
				cChave := "R_E_C_N_O_>="+Str(nMin,10,0)+" AND R_E_C_N_O_<="+Str(nMax,10,0)+""
				TcSqlExec(cQuery+cChave)
		
			End

			If ( Select ( cGrvSldCT7 ) <> 0 )
				dbSelectArea ( cGrvSldCT7 )
				dbCloseArea ()
			Endif						

			dbSelectArea("CT7")
			nRecCT7	:= CT7->(Recno())
			dbGoto(0)
			dbGoto(nRecCT7)		
		
		Else			
	#ENDIF
		While !Eof() .And. CT7->CT7_FILIAL == cFilX .And. ;
				CT7->CT7_TPSALD == cTpSald .And. CT7->CT7_CONTA == cConta .And. ;
				CT7->CT7_MOEDA == cMoeda
				RecLock("CT7")
				CT7->CT7_ANTDEB	:= nAntDeb 
				CT7->CT7_ANTCRD	:= nAntCrd
				CT7->CT7_ATUDEB	:= nAntDeb + CT7->CT7_DEBITO
				CT7->CT7_ATUCRD	:= nAntCrd + CT7->CT7_CREDIT
				CT7->CT7_SLBASE	:= "S"
				MsUnlock()
				nAntDeb 	:= CT7->CT7_ATUDEB
				nAntCrd		:= CT7->CT7_ATUCRD
				dbSkip()
		EndDo
	#IFDEF TOP
		Endif
	#ENDIF								
Endif

RestArea(aSaveArea)

Return 


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³GravaCt3  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Saldos dos Centros de Custo e atualiza saldo dia dia ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³GRAVACT3(cConta,cCusto,cTipo,dData,cMoeda,nValor,cTpSald)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                     ³±±
±±³          ³ ExpC2 = Centro de Custo                                    ³±±
±±³          ³ ExpC3 = Tipo do Lancamento Contabil                        ³±±
±±³          ³ ExpD1 = Data do Lancamento Contabil                        ³±±
±±³          ³ ExpC4 = Moeda do Lancamento Contabil                       ³±±
±±³          ³ ExpN1 = Valor do Lancamento Contabil                  	  ³±±
±±³          ³ ExpC5 = Tipo do Saldo                                  	  ³±±
±±³          ³ ExpL1 = Define se foi chamado pelo Reprocessamento     	  ³±±
±±³          ³ ExpL2 = Define se Atualiza Saldo basico na dig. lancamento ³±±
±±³          ³ ExpL3 = Define se zera os movimentos.                  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GRAVACT3(cConta,cCusto,cTipo,dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,lZera,dDataLP)

Local aSaveArea	:= GetArea()
Local lInclui		:= .F.
Local nAntDeb		:= 0
Local nAntCrd		:= 0                                                    
Local aSldAntCT3	:= {}
Local cChave		:= ""

lReproc				:= Iif(lReproc == Nil,.F.,lReproc)
lAtSldBase 			:= Iif(lAtSldBase == Nil,.T.,lAtSldBase)
lZera				:= Iif(lZera == Nil,.F.,lZera)
dDataLP				:= Iif(dDataLp == Nil, CTOD("  /  /  "),dDAtaLP)

If Empty(cCusto) .Or. nValor <= 0
	Return
EndIf	

BEGIN TRANSACTION
	DbSelectArea("CT3")
	If Empty(dDataLP)
		cChave	:= xFilial()+cMoeda+cTpSald+cConta+cCusto+Dtos(dData)
	Else
		cChave	:= xFilial()+cMoeda+cTpSald+cConta+cCusto+Dtos(dData)+"Z"	
	EndIf

	DbSetOrder(1)
	If !MsSeek(cChave,.T.)
		lInclui 	:= .T.
	Else
		lInclui		:= .F.
		//Se nao for lancamento de zeramento e posicionar no saldo de zeramento.
		//Devera ser incluido um novo registro. 		
		If Empty(dDataLP) .And. CT3->CT3_LP == 'Z'
			lInclui := .T.			
		EndIf		
	EndIf	

	// Nao ha registro para o dia -> cria!!
	If lInclui
		RecLock("CT3",.t.)
		CT3->CT3_FILIAL	:= xFilial()
		CT3->CT3_CONTA		:= cConta
		CT3->CT3_CUSTO		:= cCusto
		CT3->CT3_MOEDA		:= cMoeda
		CT3->CT3_DATA		:= dData
		CT3->CT3_TPSALD		:= cTpSald                               
		CT3->CT3_STATUS		:= "1"					// Periodo Aberto
		If !Empty(dDataLP)
			CT3->CT3_LP			:= 'Z'				//Indica que eh saldo de zeramento
		Else
			CT3->CT3_LP			:= 'N'				//Flag indicando que o saldo ainda nao foi zerado
		EndIf
	Else
		RecLock( "CT3", .f. )
		//Se for rotina de atualizacao de saldos compostos, ira zerar os saldos 
		If lZera
			If cTipo == "1"
				CT3->CT3_DEBITO	:= 0
			ElseIf cTipo == "2"
				CT3->CT3_CREDIT	:= 0			
			EndIf
		EndIf		
	EndIf

	//Rotina para recuperar saldo anterior
    If !lInclui .And. lZera 	//Se for CTBA360.
		aSldAntCT3 := SldAntCT3(cConta,cCusto,dData,cMoeda,cTpSald,,.T.)
	Else
		aSldAntCT3 := SldAntCT3(cConta,cCusto,dData,cMoeda,cTpSald,,lInclui)
	EndIf
                                                                 
	nAntDeb	:= aSldAntCT3[1]
	nAntCrd	:= aSldAntCT3[2]
	
	// Grava valores atuais
	If cTipo == "1"
		CT3->CT3_DEBITO	:= (CT3->CT3_DEBITO + nValor)
		#IFDEF TOP
			CT3->CT3_ANTDEB	:= nAntDeb
			CT3->CT3_ATUDEB	:= CT3->CT3_ANTDEB+CT3->CT3_DEBITO
			CT3->CT3_ANTCRD	:= nAntCrd
			CT3->CT3_ATUCRD	:= CT3->CT3_ANTCRD+CT3->CT3_CREDIT
		#ENDIF				
	ElseIf cTipo == "2"
		CT3->CT3_CREDIT	:= (CT3->CT3_CREDIT + nValor)
		#IFDEF TOP
			CT3->CT3_ANTDEB	:= nAntDeb
			CT3->CT3_ATUDEB	:= CT3->CT3_ANTDEB+CT3->CT3_DEBITO
			CT3->CT3_ANTCRD	:= nAntCrd
			CT3->CT3_ATUCRD	:= CT3->CT3_ANTCRD+CT3->CT3_CREDIT
		#ENDIF				
	EndIf	
	//Atualiza flag de saldo basico.	
	#IFDEF TOP
		CT3->CT3_SLBASE	:= "S"
	#ENDIF	
	MsUnlock()        
	//Chama funcao que grava o saldo anterior e o saldo atual          
	GRVSLDCT3(cTipo,cConta,cCusto,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,lAtSldBase,,lZera,"+")	

END TRANSACTION
	
RestArea(aSaveArea)

Return 

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³SldAntCT3 ³ Autor ³ Simone Mie Sato       ³ Data ³ 16.10.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Recupera saldo anterior a data inicial                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³SLDANTCT3(cConta,cCusto,dData,cMoeda,cTpSald) 				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                     ³±±
±±³          ³ ExpC2 = Centro de Custo                                    ³±±
±±³          ³ ExpC3 = Tipo do Lancamento Contabil                        ³±±
±±³          ³ ExpD1 = Data do Lancamento Contabil                        ³±±
±±³          ³ ExpC4 = Moeda do Lancamento Contabil                       ³±±
±±³          ³ ExpC5 = Tipo do Saldo                                  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SLDANTCT3(cConta,cCusto,dData,cMoeda,cTpSald,cFilX,lDbSkip1)
                                                                           
Local aSaveArea	:= GetArea()
Local nAntDeb		:= 0	//Saldo anterior Debito Conta/C.Custo
Local nAntCrd		:= 0	//Saldo anterior Credito Conta/C.Custo

#IFDEF TOP
	Local aTamVlr		:= TAMSX3("CT3_ATUDEB")
	Local cOrderCT3 	:= ""
	Local cAliasCT3 	:= ""   		
	Local cQuery		:= ""
#ENDIF

DEFAULT lDbSkip1 := .T.

If cFilX == Nil
	cFilX := xFilial("CT3")
EndIf

#IFDEF TOP                             
	If TcSrvType() != "AS/400"                     		
		cOrderCT3 := SqlOrder(indexKey())
		cAliasCT3 := "cAliasCT3"   		
			
		cQuery := "SELECT CT3_DATA, CT3_ATUDEB, CT3_ATUCRD "
		cQuery += "FROM "+RetSqlName("CT3")+" CT3 "
		cQuery += "WHERE CT3.CT3_FILIAL ='"+cFilX+"' AND "
		cQuery += "CT3.CT3_MOEDA ='"+cMoeda+"' AND "
		cQuery += "CT3.CT3_TPSALD ='"+cTpSald+"' AND "
		cQuery += "CT3.CT3_CONTA = '"+cConta+"' AND "		 		
		cQuery += "CT3.CT3_CUSTO='"+cCusto+"' AND "			
		cQuery += "CT3.D_E_L_E_T_ <> '*' AND "				
		cQuery += "CT3.CT3_DATA = (SELECT MAX(CT3_DATA) "
		cQuery += "FROM "+RetSqlName("CT3")+" CT32 "
		cQuery += "WHERE CT32.CT3_FILIAL ='"+cFilX+"' AND "			
		cQuery += "CT32.CT3_MOEDA = '"+cMoeda+"' AND "	 
		cQuery += "CT32.CT3_TPSALD = '"+cTpSald+"' AND "					
		cQuery += "CT32.CT3_CONTA = '"+cConta+"' AND "		
		cQuery += "CT32.CT3_CUSTO='"+cCusto+"' AND "			 
		cQuery += "CT32.CT3_DATA < '"+DTOS(dData)+"' AND "		 
		cQuery += "CT32.D_E_L_E_T_ <> '*') AND "
		cQuery += "CT3.CT3_LP = (SELECT MAX(CT3_LP) "
		cQuery += "FROM "+RetSqlName("CT3")+" CT33 "
		cQuery += "WHERE CT33.CT3_FILIAL ='"+cFilX+"' AND "			
		cQuery += "CT33.CT3_MOEDA = '"+cMoeda+"' AND "	 
		cQuery += "CT33.CT3_TPSALD = '"+cTpSald+"' AND "					
		cQuery += "CT33.CT3_CONTA = '"+cConta+"' AND "		
		cQuery += "CT33.CT3_CUSTO='"+cCusto+"' AND "			 
		cQuery += "CT33.CT3_DATA =  (SELECT MAX(CT3_DATA) "
		cQuery += "FROM "+RetSqlName("CT3")+" CT34 "
		cQuery += "WHERE CT34.CT3_FILIAL ='"+cFilX+"' AND "			
		cQuery += "CT34.CT3_MOEDA = '"+cMoeda+"' AND "	 
		cQuery += "CT34.CT3_TPSALD = '"+cTpSald+"' AND "					
		cQuery += "CT34.CT3_CONTA = '"+cConta+"' AND "		 
		cQuery += "CT34.CT3_CUSTO='"+cCusto+"' AND "			 
		cQuery += "CT34.CT3_DATA < '"+DTOS(dData)+"' AND "		 
		cQuery += "CT34.D_E_L_E_T_ <> '*')	AND "
		cQuery += "CT33.D_E_L_E_T_ <> '*')"
		
		cQuery := ChangeQuery(cQuery)		   
	
		If ( Select ( cAliasCT3 ) <> 0 )
			dbSelectArea ( cAliasCT3 )
			dbCloseArea ()
		Endif

  		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasCT3,.T.,.F.)
  		
		TCSetField(cAliasCT3,"CT3_DATA", "D",8,0)				  		
		TCSetField(cAliasCT3,"CT3_ATUDEB", "N",aTamVlr[1],aTamVlr[2])	
		TCSetField(cAliasCT3,"CT3_ATUCRD", "N",aTamVlr[1],aTamVlr[2])			
  		
		nAntDeb 	:= (cAliasCT3)->CT3_ATUDEB
		nAntCrd 	:= (cAliasCT3)->CT3_ATUCRD					

		If ( Select ( cAliasCT3 ) <> 0 )
			dbSelectArea ( cAliasCT3 )
			dbCloseArea ()
		Endif			
	Else
#ENDIF

	If lDbSkip1
		dbSkip(-1)
	Endif

	If (xFilial()+cMoeda+cTpSald+cConta+cCusto) == ;
		(CT3->CT3_FILIAL+CT3->CT3_MOEDA+CT3->CT3_TPSALD+CT3->CT3_CONTA+;
		CT3->CT3_CUSTO) .And.;
		(!Bof() .And. !Eof())
		If CT3->CT3_DATA == dData               
			If lDbSkip1 .And. CT3->CT3_LP <> "Z"		
				nAntDeb		:= CT3->CT3_ATUDEB
				nAntCrd		:= CT3->CT3_ATUCRD			
			Else                              
				nAntDeb 	:= CT3->CT3_ANTDEB
				nAntCrd 	:= CT3->CT3_ANTCRD					
			EndIf			
		Else                               		
			nAntDeb		:= CT3->CT3_ATUDEB
			nAntCrd		:= CT3->CT3_ATUCRD
		EndIf
	Else
		nAntDeb	:= 0
		nAntCrd	:= 0
	EndIf

	If (!Bof())
		dbSkip()
	EndIf

#IFDEF TOP
Endif
#ENDIF

RestArea(aSaveArea)

Return{nAntDeb,nAntCrd}                                    

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³DsGravaCt3³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Desgrava Saldos dos Centros de Custo 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³DSGRAVACT3(cConta,cCusto,cTipo,dData,cMoeda,nValor,cTpSald) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                     ³±±
±±³          ³ ExpC2 = Centro de Custo                                    ³±±
±±³          ³ ExpC3 = Tipo do Lancamento Contabil                        ³±±
±±³          ³ ExpD1 = Data do Lancamento Contabil                        ³±±
±±³          ³ ExpC4 = Moeda do Lancamento Contabil                       ³±±
±±³          ³ ExpN1 = Valor do Lancamento Contabil                  	  ³±±
±±³          ³ ExpC5 = Tipo do Saldo                                  	  ³±±
±±³          ³ ExpL1 = Define se foi chamado pelo Reprocessamento     	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function DSGRAVACT3(cConta,cCusto,cTipo,dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,dDataLP,nOpc)

Local aSaveArea		:= GetArea()
Local nAntDeb		:= 0
Local nAntCrd		:= 0
Local aSldAntCT3	:= {}                                                        
Local cChave		:= ""
lReproc 			:= Iif(lReproc==Nil,.F.,lReproc)
lAtSldBase			:= Iif(lAtSldBase==Nil,.T.,lAtSldBase) 
dDataLP				:= Iif(dDataLP==Nil,CTOD("  /  /  "),dDataLP)
nOpc			:= Iif(nOpc == Nil,4,nOpc)

DbSelectArea("CT3")
If Empty(dDataLP)
  cChave	:= xFilial()+cMoeda+ctpsald+cConta+cCusto+Dtos(dData)
Else
  cChave	:= xFilial()+cMoeda+ctpsald+cConta+cCusto+Dtos(dData)+"Z"
EndIf

DbSelectArea("CT3")
DbSetOrder(1)
If !MsSeek(cChave) .Or. Empty(cCusto)
	Return                            
Else
	//Se nao for lancamento de zeramento e posicionar no saldo de zeramento.
	//Devera ser incluido um novo registro. 		
	If Empty(dDataLP) .And. CT3->CT3_LP == 'Z'
		Return
	EndIf		
EndIf	
    
BEGIN TRANSACTION

	//Rotina para recuperar saldo anterior
	aSldAntCT3 := SldAntCT3(cConta,cCusto,dData,cMoeda,cTpSald)
                                                                 
	nAntDeb	:= aSldAntCT3[1]
	nAntCrd	:= aSldAntCT3[2]

	// Descalcula
	RecLock("CT3")
	If cTipo == "1"
		If CT3->CT3_DEBITO < nValor
			CT3->CT3_DEBITO := 0
		Else
			CT3->CT3_DEBITO	:= (CT3->CT3_DEBITO - nValor)
			#IFDEF TOP
				CT3->CT3_ANTDEB	:= nAntDeb
				CT3->CT3_ATUDEB	:= CT3->CT3_ANTDEB+CT3->CT3_DEBITO			
				CT3->CT3_ANTCRD	:= nAntCrd
				CT3->CT3_ATUCRD	:= CT3->CT3_ANTCRD+CT3->CT3_CREDIT
			#ENDIF			
		EndIf	
	ElseIf cTipo == "2"
		If CT3->CT3_CREDIT < nValor
			CT3->CT3_CREDIT := 0
		Else
			CT3->CT3_CREDIT	:= (CT3->CT3_CREDIT - nValor)
			#IFDEF TOP
				CT3->CT3_ANTCRD	:= nAntCrd
				CT3->CT3_ATUCRD	:= CT3->CT3_ANTCRD+CT3->CT3_CREDIT			
				CT3->CT3_ANTDEB	:= nAntDeb
				CT3->CT3_ATUDEB	:= CT3->CT3_ANTDEB+CT3->CT3_DEBITO
			#ENDIF			
		EndIf	
	EndIf
	MsUnlock()        

	//Se na exclusao, zerar os valores de mov. debito e credito, deleta o registro no 
	//arquivo de saldos, pois no reprocessamento nao refaz os saldos que nao tenham 
	//lancamentos no CT2, e da diferenca no balancete.
	If CT3->CT3_CREDIT == 0  .And. CT3->CT3_DEBITO == 0
		RecLock("CT3",.F.,.T.)
		CT3->(dbDelete())
		CT3->(MsUnlock())
		dbSelectArea("CT3")
		dbSkip()
		//Chama funcao que grava o saldo anterior e o saldo atual		
		//A variavel lAtSldBase esta sendo passada como .T. para atualizar o flag
		If nOpc == 5 //Se for exclusao de lancamento contabil, atualiza os saldos da data para frente.
			GRVSLDCT3(cTipo,cConta,cCusto,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,.F.,.T.,,,"-")		
		Else
			GRVSLDCT3(cTipo,cConta,cCusto,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,.T.,,,"-")				
		EndIf
	Else                                   
		//Chama funcao que grava o saldo anterior e o saldo atual
		If nOpc == 5//Se for exclusao de lancamento contabil, atualiza os saldos, pois o lancamento contabil eh deletado
			GRVSLDCT3(cTipo,cConta,cCusto,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,.F.,.T.,,,"-")				
		Else
			GRVSLDCT3(cTipo,cConta,cCusto,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,lAtSldBase,,,"-")		
		EndIf
	Endif
END TRANSACTION

RestArea(aSaveArea)

Return 

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³GRVSLDCT3 ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Saldo Anterior e Saldo Atual do CT3				    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³GRVSLDCT3(cConta,cCusto,cMoeda,cTpSald,nAntDeb,nAntCrd,lReproc³±±
±±³          ³lAtSldBase,cFilX)												³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                       ³±±
±±³          ³ ExpC2 = Centro de Custo                                      ³±±
±±³          ³ ExpC3 = Moeda do Lancamento Contabil                         ³±±
±±³          ³ ExpC4 = Tipo do Saldo                                  	    ³±±
±±³          ³ ExpN1 = Valor Anterior debito                         	    ³±±
±±³          ³ ExpN2 = Valor Anterior Credito                        	    ³±±
±±³          ³ ExpL1 = Indica se deve atual.os saldos dos dias posteriores  ³±±
±±³          ³ ExpL2 = Define se devera preencher o flag de atualiz.saldos  ³±±
±±³          ³ ExpC5 = Filial                                         	    ³±±
±±³          ³ ExpL3 = Define se zera os movimentos debito/credito          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GRVSLDCT3(cTipo,cConta,cCusto,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,lAtSldBase,cFilX,lZera,cOperacao)

Local aSaveArea		:= GetArea()
Local nRegCT3		:= Recno()                                                         

#IFDEF TOP
	Local cChave		:= ""
	Local cGrvSldCT3	:= ""
	Local cQuery		:= ""	
	Local nCountReg		:= 0	
	Local nMax			:= 0
	Local nMin			:= 0
	Local nRecCT3		:= 0	
#ENDIF
lReproc 			:= Iif(lReproc==Nil,.F.,lReproc)
lAtSldBase			:= Iif(lAtSldBase==Nil,.T.,lAtSldBase) 
cFilX				:= Iif(cFilX==Nil,xFilial("CT3"),cFilX)
lZera				:= Iif(lZera == Nil,.F.,lZera)

DEFAULT cOperacao	:= "+"                                               	

nRegCT3 := Recno()
// Recalcula valores
If lReproc //Se for chamado pelo Reprocessamento so deve atualizar o registro atual.
	If !Eof() .And. CT3->CT3_FILIAL == cFilX .And. ;
			CT3->CT3_TPSALD == cTpSald .And. CT3->CT3_CONTA == cConta .And. ;
			CT3->CT3_MOEDA == cMoeda .And. CT3->CT3_CUSTO == cCusto
			RecLock("CT3")
			CT3->CT3_ANTDEB	:= nAntDeb 
			CT3->CT3_ANTCRD	:= nAntCrd
			CT3->CT3_ATUDEB	:= nAntDeb + CT3->CT3_DEBITO
			CT3->CT3_ATUCRD	:= nAntCrd + CT3->CT3_CREDIT                                  
			CT3->CT3_SLCOMP:= "N"
			//Se for Reprocessamento ou Atualizacao de Saldos compostos (CTBA360), 
			//devera estar com flag de atualizado para nao precisar atualizar novamente. 
			If lAtSldBase .Or.	lZera
				CT3->CT3_SLBASE	:= "S"
			Else 	   	   //Flag de Atualizacao de saldo,para identificar que o
				CT3->CT3_SLBASE	:= "N"//saldo devera ser atualizado a partir desse reg.    
			EndIf	 
			MsUnlock()
	EndIf                                                                   	
Else	                                                                    
	#IFDEF TOP   
		If TcSrvType() != "AS/400"                     			                          
			CT3->(dbCommit())
			cGrvSldCT3 := "cGrvSldCT3"   		
			cQuery   	:= "SELECT R_E_C_N_O_ RECNO "
			cQuery   	+=" FROM "+RetSqlName("CT3")+" CT3 "
			cQuery		+= "WHERE CT3.CT3_FILIAL = '"+cFilX+"' AND "
			cQuery   	+= "CT3.CT3_TPSALD = '"+cTpSald+"' AND "        
			cQuery   	+= "CT3.CT3_CUSTO ='"+cCusto+"' AND "			          
			cQuery   	+= "CT3.CT3_CONTA ='"+cConta+"' AND "			
			cQuery   	+= "CT3.CT3_MOEDA ='"+cMoeda+"' AND "			
			cQuery 		+= "CT3_DATA > '"+Dtos(dData)+"' AND "		
			cQuery   	+= "D_E_L_E_T_<>'*' " 		
			cQuery   	+= "ORDER BY RECNO" 		
			cQuery		:= ChangeQuery(cQuery)   
		
			If ( Select ( cGrvSldCT3 ) <> 0 )
				dbSelectArea ( cGrvSldCT3 )
				dbCloseArea ()
			Endif
			
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cGrvSldCT3,.T.,.F.)
			
			cQuery := "UPDATE "
			cQuery += RetSqlName("CT3")+" "				
			cQuery += "SET " 
			If cTipo = "1"
					cQuery += "CT3_ANTDEB = CT3_ANTDEB " + cOperacao + (Str(nValor,TAMSX3("CT3_ANTDEB")[1],TAMSX3("CT3_ANTDEB")[2])) +", "
				cQuery += "CT3_ATUDEB = CT3_ATUDEB " + cOperacao + (Str(nValor,TAMSX3("CT3_ATUDEB")[1],TAMSX3("CT3_ATUDEB")[2])) + " "   			
			ElseIf cTipo = "2"	
				cQuery += "CT3_ANTCRD =  CT3_ANTCRD " + cOperacao + (Str(nValor,TAMSX3("CT3_ANTCRD")[1],TAMSX3("CT3_ANTCRD")[2])) + ", "   			
				cQuery += "CT3_ATUCRD =  CT3_ATUCRD " + cOperacao + (Str(nValor,TAMSX3("CT3_ATUCRD")[1],TAMSX3("CT3_ATUCRD")[2])) + " "   			    
			EndIf
			cQuery += "WHERE CT3_FILIAL = '"+cFilX+"' AND "
			cQuery += "CT3_TPSALD = '"+cTpSald+"' AND "                           
			cQuery += "CT3_CONTA ='"+cConta+"' AND "			
			cQuery += "CT3_CUSTO ='"+cCusto+"' AND "			
			cQuery += "CT3_MOEDA ='"+cMoeda+"' AND "			
			cQuery += "CT3_DATA > '"+Dtos(dData)+"' AND "
			cQuery 	+= "D_E_L_E_T_<>'*' AND " 		
		
			While cGrvSldCT3->(!EOF())
		
				nMin := (cGrvSldCT3)->RECNO
				
				nCountReg := 0
				
				While cGrvSldCT3->(!EOF()) .and. nCountReg <= 4096
				
					nMax := (cGrvSldCT3)->RECNO
					nCountReg++
					cGrvSldCT3->(DbSkip())

				End
				
				cChave := "R_E_C_N_O_>="+Str(nMin,10,0)+" AND R_E_C_N_O_<="+Str(nMax,10,0)+""
				TcSqlExec(cQuery+cChave)
				
			End

			If ( Select ( cGrvSldCT3 ) <> 0 )
				dbSelectArea ( cGrvSldCT3 )
				dbCloseArea ()
			Endif      			            

			dbSelectArea("CT3")
			nRecCT3	:= CT3->(Recno())
			dbGoto(0)
			dbGoto(nRecCT3)		
		
		Else			
	#ENDIF
		While !Eof() .And. CT3->CT3_FILIAL == cFilX .And. ;
				CT3->CT3_TPSALD == cTpSald .And. CT3->CT3_CONTA == cConta .And. ;
				CT3->CT3_MOEDA == cMoeda .And. CT3->CT3_CUSTO == cCusto
			RecLock("CT3")
			CT3->CT3_ANTDEB	:= nAntDeb 
			CT3->CT3_ANTCRD	:= nAntCrd
			CT3->CT3_ATUDEB	:= nAntDeb + CT3->CT3_DEBITO
			CT3->CT3_ATUCRD	:= nAntCrd + CT3->CT3_CREDIT
			CT3->CT3_SLBASE	:= "S"
			CT3->CT3_SLCOMP := "N"
			MsUnlock()
			nAntDeb 	:= CT3->CT3_ATUDEB
			nAntCrd		:= CT3->CT3_ATUCRD
			dbSkip()
		EndDo
	#IFDEF TOP		
		EndIf
	#ENDIF
Endif
RestArea(aSaveArea)

Return 

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³GravaCt4  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Saldos dos Itens Contabeis e atualiza saldo dia dia  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³GRAVACT4(cConta,cCusto,cItem,cTipo,dData,cMoeda,nValor,	  ³±±
±±³			 ³cTpSald)                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                     ³±±
±±³          ³ ExpC2 = Centro de Custo                                    ³±±
±±³          ³ ExpC3 = Item Contabil                                      ³±±
±±³          ³ ExpC4 = Tipo do Lancamento Contabil                        ³±±
±±³          ³ ExpD1 = Data do Lancamento Contabil                        ³±±
±±³          ³ ExpC5 = Moeda do Lancamento Contabil                       ³±±
±±³          ³ ExpN1 = Valor do Lancamento Contabil                  	  ³±±
±±³          ³ ExpC6 = Tipo do Saldo                                  	  ³±±
±±³          ³ ExpL1 = Define se foi chamado pelo Reprocessamento     	  ³±±
±±³          ³ ExpL2 = Define se atualiza saldo basico na dig. lancamento ³±±
±±³          ³ ExpL3 = Define se zera os movimentos				     	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GRAVACT4(cConta,cCusto,cItem,cTipo,dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,lZera,dDataLP)

Local aSaveArea		:= GetArea()
Local lInclui		:= .F.
Local nAntDeb		 := 0
Local nAntCrd	 	:= 0
Local aSldAntCT4	:= {}		
Local cChave		:= ""

lReproc 			:= Iif(lReproc==Nil,.F.,lReproc)
lAtSldBase			:= Iif(lAtSldBase==Nil,.T.,lAtSldBase) 
lZera				:= Iif(lZera == Nil,.F.,lZera)
dDataLP				:= Iif(dDataLP == Nil,CTOD("  /  /  "),dDataLP)

If Empty(cItem) .Or. nValor <= 0
	Return
EndIf	
     
BEGIN TRANSACTION

	DbSelectArea("CT4")
	If Empty(dDataLP)
		cChave	:= xFilial()+cMoeda+cTpSald+cConta+cCusto+cItem+Dtos(dData)
	Else
		cChave	:= xFilial()+cMoeda+cTpSald+cConta+cCusto+cItem+Dtos(dData)+"Z"	
	EndIf

	DbSetOrder(1)
	If !MsSeek(cChave,.T.)
		lInclui	:= .T.
	Else
		lInclui	:= .F.
		//Se nao for lancamento de zeramento e posicionar no saldo de zeramento.
		//Devera ser incluido um novo registro. 		
		If Empty(dDataLP) .And. CT4->CT4_LP == 'Z'
			lInclui := .T.			
		EndIf				
	EndIf

	// Nao ha registro para o dia -> cria!!
	If lInclui
		RecLock( "CT4", .t. )
		CT4->CT4_FILIAL 	:= xFilial()
		CT4->CT4_CONTA		:= cConta
		CT4->CT4_CUSTO		:= cCusto
		CT4->CT4_ITEM		:= cItem
		CT4->CT4_MOEDA		:= cMoeda
		CT4->CT4_DATA		:= dData
		CT4->CT4_TPSALD		:= cTpSald
		CT4->CT4_STATUS		:= "1"					// Periodo Aberto
		If !Empty(dDataLP)
			CT4->CT4_LP 	:= 'Z'						//Se for lancamento de zeramento
		Else
			CT4->CT4_LP		:= "N"					// Flag indicando que ainda nao foi zerado
		EndIf
	Else
		RecLock( "CT4", .f. )
		//Se for rotina de atualizacao de saldos compostos (CTBA360),
		// deve zerar os movimentos
		If lZera 
			If cTipo == "1"
				CT4->CT4_DEBITO	:= 0
			ElseIf cTipo == "2"
				CT4->CT4_CREDIT	:= 0			
			EndIf
		EndIf		
	Endif

	//Rotina para recuperar saldo anterior
    If !lInclui .And. lZera 	//Se for CTBA360.
		aSldAntCT4 := SldAntCT4(cConta,cCusto,cItem,dData,cMoeda,cTpSald,,.T.)
	Else	
		aSldAntCT4 := SldAntCT4(cConta,cCusto,cItem,dData,cMoeda,cTpSald,,lInclui)
	EndIf
                                                                 
	nAntDeb	:= aSldAntCT4[1]
	nAntCrd	:= aSldAntCT4[2]	

	// Grava valores atuais
	If cTipo == "1"        
		CT4->CT4_DEBITO	:= (CT4->CT4_DEBITO + nValor)	
		#IFDEF TOP
			CT4->CT4_ANTDEB	:= nAntDeb
			CT4->CT4_ATUDEB	:= CT4->CT4_ANTDEB+CT4->CT4_DEBITO
			CT4->CT4_ANTCRD	:= nAntCrd
			CT4->CT4_ATUCRD	:= CT4->CT4_ANTCRD+CT4->CT4_CREDIT
		#ENDIF		
	ElseIf cTipo == "2"
		CT4->CT4_CREDIT	:= (CT4->CT4_CREDIT + nValor)
		#IFDEF TOP
			CT4->CT4_ANTDEB	:= nAntDeb
			CT4->CT4_ATUDEB	:= CT4->CT4_ANTDEB+CT4->CT4_DEBITO
			CT4->CT4_ANTCRD	:= nAntCrd
			CT4->CT4_ATUCRD	:= CT4->CT4_ANTCRD+CT4->CT4_CREDIT
		#ENDIF				
	EndIf	 
	//Atualiza flag de saldo basico.	
	#IFDEF TOP
		CT4->CT4_SLBASE	:= "S"
	#ENDIF	
	MsUnlock()
	
	//Chama funcao que grava o saldo anterior e o saldo atual
	GRVSLDCT4(cTipo,cConta,cCusto,cItem,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,lAtSldBase,,lZera,"+")
	
END TRANSACTION

RestArea(aSaveArea)

Return                                    

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³SldAntCT4 ³ Autor ³ Simone Mie Sato       ³ Data ³ 15.10.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Recupera saldo anterior a data inicial                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³SLDANTCT4(cConta,cCusto,cItem,dData,cMoeda,cTpSald)		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                     ³±±
±±³          ³ ExpC2 = Centro de Custo                                    ³±±
±±³          ³ ExpC3 = Item Contabil                                      ³±±
±±³          ³ ExpD1 = Data do Lancamento Contabil                        ³±±
±±³          ³ ExpC4 = Moeda do Lancamento Contabil                       ³±±
±±³          ³ ExpC5 = Tipo do Saldo                                  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SLDANTCT4(cConta,cCusto,cItem,dData,cMoeda,cTpSald,cFilx,lDbSkip1)
                                                                           
Local aSaveArea	:= GetArea()
Local nAntDeb		:= 0	//Saldo anterior Debito Conta/C.Custo/Item
Local nAntCrd		:= 0	//Saldo anterior Credito Conta/C.Custo/Item


#IFDEF TOP
	Local aTamVlr		:= TAMSX3("CT4_ATUDEB")
	Local cQuery		:= ""
	Local cOrderCT4 	:= ""
	Local cAliasCT4 	:= ""   		
#ENDIF
DEFAULT lDbSkip1 := .T.

If cFilX == Nil
	cFilX := xFilial("CT4")
EndIf

#IFDEF TOP                             
	If TcSrvType() != "AS/400"                     		
		cOrderCT4 := SqlOrder(indexKey())
		cAliasCT4 := "cAliasCT4"   		

		cQuery := "SELECT CT4_DATA, CT4_ATUDEB, CT4_ATUCRD "
		cQuery += "FROM "+RetSqlName("CT4")+" CT4 "
		cQuery += "WHERE CT4.CT4_FILIAL ='"+cFilX+"' AND "
		cQuery += "CT4.CT4_MOEDA ='"+cMoeda+"' AND "
		cQuery += "CT4.CT4_TPSALD ='"+cTpSald+"' AND "
		cQuery += "CT4.CT4_CONTA = '"+cConta+"' AND "		 		
		cQuery += "CT4.CT4_CUSTO='"+cCusto+"' AND "			
		cQuery += "CT4.CT4_ITEM='"+cItem+"' AND "
		cQuery += "CT4.D_E_L_E_T_ <> '*' AND "				
		cQuery += "CT4.CT4_DATA = (SELECT MAX(CT4_DATA) "
		cQuery += "FROM "+RetSqlName("CT4")+" CT42 "
		cQuery += "WHERE CT42.CT4_FILIAL ='"+cFilX+"' AND "			
		cQuery += "CT42.CT4_MOEDA = '"+cMoeda+"' AND "	 
		cQuery += "CT42.CT4_TPSALD = '"+cTpSald+"' AND "					
		cQuery += "CT42.CT4_CONTA = '"+cConta+"' AND "		
		cQuery += "CT42.CT4_CUSTO='"+cCusto+"' AND "			 
		cQuery += "CT42.CT4_ITEM='"+cItem+"' AND "
		cQuery += "CT42.CT4_DATA < '"+DTOS(dData)+"' AND "		 
		cQuery += "CT42.D_E_L_E_T_ <> '*') AND "
		cQuery += "CT4.CT4_LP = (SELECT MAX(CT4_LP) "
		cQuery += "FROM "+RetSqlName("CT4")+" CT43 "
		cQuery += "WHERE CT43.CT4_FILIAL ='"+cFilX+"' AND "			
		cQuery += "CT43.CT4_MOEDA = '"+cMoeda+"' AND "	 
		cQuery += "CT43.CT4_TPSALD = '"+cTpSald+"' AND "					
		cQuery += "CT43.CT4_CONTA = '"+cConta+"' AND "		
		cQuery += "CT43.CT4_CUSTO='"+cCusto+"' AND "			 
		cQuery += "CT43.CT4_ITEM='"+cItem+"' AND "
		cQuery += "CT43.CT4_DATA =  (SELECT MAX(CT4_DATA) "
		cQuery += "FROM "+RetSqlName("CT4")+" CT44 "
		cQuery += "WHERE CT44.CT4_FILIAL ='"+cFilX+"' AND "			
		cQuery += "CT44.CT4_MOEDA = '"+cMoeda+"' AND "	 
		cQuery += "CT44.CT4_TPSALD = '"+cTpSald+"' AND "					
		cQuery += "CT44.CT4_CONTA = '"+cConta+"' AND "		
		cQuery += "CT44.CT4_CUSTO='"+cCusto+"' AND "			 
		cQuery += "CT44.CT4_ITEM='"+cItem+"' AND "
		cQuery += "CT44.CT4_DATA < '"+DTOS(dData)+"' AND "		 
		cQuery += "CT44.D_E_L_E_T_ <> '*') AND "
		cQuery += "CT43.D_E_L_E_T_ <> '*')"			
		cQuery := ChangeQuery(cQuery)		   
	
		If ( Select ( cAliasCT4 ) <> 0 )
			dbSelectArea ( cAliasCT4 )
			dbCloseArea ()
		Endif

  		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasCT4,.T.,.F.)
  		
		TCSetField(cAliasCT4,"CT4_DATA", "D",8,0)				  		
		TCSetField(cAliasCT4,"CT4_ATUDEB", "N",aTamVlr[1],aTamVlr[2])	
		TCSetField(cAliasCT4,"CT4_ATUCRD", "N",aTamVlr[1],aTamVlr[2])			
  		
		nAntDeb 	:= (cAliasCT4)->CT4_ATUDEB
		nAntCrd 	:= (cAliasCT4)->CT4_ATUCRD			
		
		dbCloseArea()
		dbSelectArea("CT4")	                     
		
		If ( Select ( cAliasCT4 ) <> 0 )
			dbSelectArea ( cAliasCT4 )
			dbCloseArea ()
		Endif			
	Else
#ENDIF
   	
	// Procura saldo anterior -> Para recalculo
	If lDbSkip1
		dbSkip(-1)
	Endif
	If (xFilial()+cMoeda+cTpSald+cConta+cCusto+cItem) == ;
		(CT4->CT4_FILIAL+CT4->CT4_MOEDA+CT4->CT4_TPSALD+CT4->CT4_CONTA+;
		CT4->CT4_CUSTO+CT4->CT4_ITEM) .And.;
		(!Bof() .And. !Eof())    
		If CT4->CT4_DATA == dData
			If lDbSkip1 .And. CT4->CT4_LP <> "Z"		
				nAntDeb		:= CT4->CT4_ATUDEB
				nAntCrd		:= CT4->CT4_ATUCRD			
			Else                              
				nAntDeb 	:= CT4->CT4_ANTDEB
				nAntCrd 	:= CT4->CT4_ANTCRD	
			EndIf
		Else                               		
			nAntDeb 	:= CT4->CT4_ATUDEB
			nAntCrd 	:= CT4->CT4_ATUCRD
		EndIf
	Else
		nAntDeb	:= 0
		nAntCrd	:= 0
	EndIf
	If (!Bof())
		dbSkip()
	EndIf

#IFDEF TOP
	Endif
#ENDIF

RestArea(aSaveArea)

Return{nAntDeb,nAntCrd}                                    

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³DsGravaCt4| Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Desgrava Saldos dos Itens Contabeis.						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³DSGRAVACT4(cConta,cCusto,cItem,cTipo,dData,cMoeda,nValor,	  ³±±
±±³			 ³cTpSald)                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                     ³±±
±±³          ³ ExpC2 = Centro de Custo                                    ³±±
±±³          ³ ExpC3 = Item Contabil                                      ³±±
±±³          ³ ExpC4 = Tipo do Lancamento Contabil                        ³±±
±±³          ³ ExpD1 = Data do Lancamento Contabil                        ³±±
±±³          ³ ExpC5 = Moeda do Lancamento Contabil                       ³±±
±±³          ³ ExpN1 = Valor do Lancamento Contabil                  	  ³±±
±±³          ³ ExpC6 = Tipo do Saldo                                  	  ³±±
±±³          ³ ExpL1 = Define se foi chamado pelo Reprocessamento     	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function DSGRAVACT4(cConta,cCusto,cItem,cTipo,dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,dDataLP,nOpc)

Local aSaveArea	:= GetArea()
Local nAntDeb	 := 0
Local nAntCrd	 := 0
Local aSldAntCT4	:= {}                                                        
Local cChave		:= ""
lReproc 			:= Iif(lReproc==Nil,.F.,lReproc)
lAtSldBase			:= Iif(lAtSldBase==Nil,.T.,lAtSldBase) 
dDataLP				:= Iif(dDataLP==Nil,CTOD("  /  /  "),dDataLP)
nOpc				:= Iif(nOpc==Nil,4,nOpc)
                   
DbSelectArea("CT4")
If Empty(dDataLP)
	cChave	:= xFilial()+cMoeda+cTpSald+cConta+cCusto+cItem+Dtos(dData)
Else
	cChave	:= xFilial()+cMoeda+cTpSald+cConta+cCusto+cItem+Dtos(dData)+"Z"	
EndIf

DbSelectArea("CT4")
DbSetOrder(1)
If !MsSeek(cChave) .Or. Empty(cItem)
	Return
Else
	//Se nao for lancamento de zeramento e posicionar no saldo de zeramento.
	//Devera ser incluido um novo registro. 		
	If Empty(dDataLP) .And. CT4->CT4_LP == 'Z'
		Return
	EndIf					
EndIf

BEGIN TRANSACTION
	//Rotina para recuperar saldo anterior
	aSldAntCT4 := SldAntCT4(cConta,cCusto,cItem,dData,cMoeda,cTpSald)
                                                                 
	nAntDeb	:= aSldAntCT4[1]
	nAntCrd	:= aSldAntCT4[2]

	// Descalcula
	RecLock("CT4")
	If cTipo == "1"
		If CT4->CT4_DEBITO < nValor
			CT4->CT4_DEBITO := 0
		Else
			CT4->CT4_DEBITO	:= (CT4->CT4_DEBITO - nValor)
			#IFDEF TOP
				CT4->CT4_ANTDEB	:= nAntdeb
				CT4->CT4_ATUDEB	:= CT4->CT4_ANTDEB+CT4->CT4_DEBITO			
				CT4->CT4_ANTCRD	:= nAntCrd
				CT4->CT4_ATUCRD	:= CT4->CT4_ANTCRD+CT4->CT4_CREDIT
			#ENDIF			
		EndIf	
	ElseIf cTipo == "2"
		If CT4->CT4_CREDIT < nValor
			CT4->CT4_DEBITO := 0
		Else
			CT4->CT4_CREDIT	:= (CT4->CT4_CREDIT - nValor)
			#IFDEF TOP
				CT4->CT4_ANTCRD	:= nAntCrd
				CT4->CT4_ATUCRD	:= CT4->CT4_ANTCRD+CT4->CT4_CREDIT			
				CT4->CT4_ANTDEB	:= nAntdeb
				CT4->CT4_ATUDEB	:= CT4->CT4_ANTDEB+CT4->CT4_DEBITO
			#ENDIF						
		EndIf	
	EndIf
	MsUnlock()

	//Se na exclusao, zerar os valores de mov. debito e credito, deleta o registro no 
	//arquivo de saldos, pois no reprocessamento nao refaz os saldos que nao tenham 
	//lancamentos no CT2, e da diferenca no balancete.
	If CT4->CT4_CREDIT == 0  .And. CT4->CT4_DEBITO == 0
		RecLock("CT4",.F.,.T.)
		CT4->(dbDelete())
		CT4->(MsUnlock())
		dbSelectArea("CT4")
		dbSkip()
		//Chama funcao que grava o saldo anterior e o saldo atual		
		//A variavel lAtSldBase esta sendo passada como .T. para atualizar o flag
		If nOpc == 5
			GRVSLDCT4(cTipo,cConta,cCusto,cItem,cMoeda,cTpSald,dData,nvAlor,nAntDeb,nAntCrd,.F.,.T.,,,"-")
		Else
			GRVSLDCT4(cTipo,cConta,cCusto,cItem,cMoeda,cTpSald,dData,nvAlor,nAntDeb,nAntCrd,lReproc,.T.,,,"-")		
		EndIf
	Else
		//Chama funcao que grava o saldo anterior e o saldo atual
		If nOpc == 5//Se for exclusao de lancamento contabil, atualiza os saldos, pois o lancamento contabil eh deletado
			GRVSLDCT4(cTipo,cConta,cCusto,cItem,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,.F.,.T.,,,"-")
		Else
			GRVSLDCT4(cTipo,cConta,cCusto,cItem,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,lAtSldBase,,,"-")		
		Endif
	Endif      
	
END TRANSACTION

RestArea(aSaveArea)

Return                                    

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³GRVSLDCT4 ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Saldo Anterior e Saldo Atual do CT4				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³GRVSLDCT4(cConta,cCusto,cItem,cMoeda,cTpSald,nAntDeb,nAntCrd³±±
±±³			 ³	lAtSldBase,cFilX)        								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                     ³±±
±±³          ³ ExpC2 = Centro de Custo                                    ³±±
±±³          ³ ExpC3 = Item Contabil                                      ³±±
±±³          ³ ExpC4 = Moeda do Lancamento Contabil                       ³±±
±±³          ³ ExpC5 = Tipo do Saldo                                  	  ³±±
±±³          ³ ExpN1 = Valor Anterior debito                         	  ³±±
±±³          ³ ExpN2 = Valor Anterior Credito                        	  ³±±
±±³          ³ ExpL1 = Indica se deve atual.os saldos dos dias posteriores³±±
±±³          ³ ExpL2 = Define se devera preencher o flag de atualiz.saldos³±±
±±³          ³ ExpC6 = Filial                                         	  ³±±
±±³          ³ ExpL3 = Define se zera os movimentos debito/credito    	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GRVSLDCT4(cTipo,cConta,cCusto,cItem,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,lAtSldBase,cFilX,lZera,cOperacao)

Local aSaveArea	:= GetArea()
Local nRegCT4	:= Recno()

#IFDEF TOP
	Local cChave		:= ""
	Local cGrvSldCT4    := ""
	Local cQuery		:= ""
	Local nCountReg		:= ""	
	Local nMax			:= 0
	Local nMin			:= 0	
#ENDIF                     

lReproc 			:= Iif(lReproc==Nil,.F.,lReproc)
lAtSldBase			:= Iif(lAtSldBase==Nil,.T.,lAtSldBase) 
cFilX			:= Iif(cFilX==Nil,xFilial("CT4"),cFilX)
DEFAULT cOperacao	:= "+"

nRegCT4 := Recno()
If lReproc
	If !Eof() .And. CT4->CT4_FILIAL == cFilX .And. ;
			CT4->CT4_TPSALD == cTpSald .And. CT4->CT4_CONTA == cConta .And. ;
			CT4->CT4_CUSTO == cCusto .And. CT4->CT4_ITEM == cItem .And. ;
			CT4->CT4_MOEDA == cMoeda
			RecLock("CT4")
			CT4->CT4_ANTDEB	:= nAntDeb 
			CT4->CT4_ANTCRD	:= nAntCrd
			CT4->CT4_ATUDEB	:= nAntDeb + CT4->CT4_DEBITO
			CT4->CT4_ATUCRD	:= nAntCrd + CT4->CT4_CREDIT
			CT4->CT4_SLCOMP := "N"
			//Se for Reprocessamento ou Atualizacao de saldos Composts,
			// devera estar com flag de atualizadopara nao precisar atualizar novamente. 
			If lAtSldBase .Or. lZera
				CT4->CT4_SLBASE	:= "S"
			Else 		   //Flag de Atualizacao de saldo,para identificar que o
				CT4->CT4_SLBASE	:= "N"//saldo devera ser atualizado a partir desse reg.    
			EndIf
			MsUnlock()
	Endif                 	
Else	                  
	#IFDEF TOP   
		If TcSrvType() != "AS/400"                     			                          
			CT4->(dbCommit())
			cGrvSldCT4 := "cGrvSldCT4"   		
			cQuery   	:= "SELECT R_E_C_N_O_ RECNO"
			cQuery   	+=" FROM "+RetSqlName("CT4")+" CT4 "
			cQuery		+= "WHERE CT4.CT4_FILIAL = '"+cFilX+"' AND "
			cQuery   	+= "CT4.CT4_TPSALD = '"+cTpSald+"' AND "                  
			cQuery   	+= "CT4.CT4_ITEM ='"+cItem+"' AND "									
			cQuery   	+= "CT4.CT4_CUSTO ='"+cCusto+"' AND "						
			cQuery   	+= "CT4.CT4_CONTA ='"+cConta+"' AND "			
			cQuery   	+= "CT4.CT4_MOEDA ='"+cMoeda+"' AND "			
			cQuery 		+= "CT4_DATA > '"+Dtos(dData)+"' AND "		
			cQuery   	+= "D_E_L_E_T_<>'*' " 		
			cQuery   	+= "ORDER BY RECNO" 		
			cQuery		:= ChangeQuery(cQuery)   
		
			If ( Select ( cGrvSldCT4 ) <> 0 )
				dbSelectArea ( cGrvSldCT4 )
					dbCloseArea ()
			Endif
			
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cGrvSldCT4,.T.,.F.)
			
			cQuery := "UPDATE "
			cQuery += RetSqlName("CT4")+" "				
			cQuery += "SET " 
			If cTipo = "1"
				cQuery += "CT4_ANTDEB = CT4_ANTDEB " + cOperacao + (Str(nValor,TAMSX3("CT4_ANTDEB")[1],TAMSX3("CT4_ANTDEB")[2])) +", "
				cQuery += "CT4_ATUDEB = CT4_ATUDEB " + cOperacao + (Str(nValor,TAMSX3("CT4_ATUDEB")[1],TAMSX3("CT4_ATUDEB")[2])) + " "   			
			ElseIf cTipo = "2"	
				cQuery += "CT4_ANTCRD =  CT4_ANTCRD " + cOperacao + (Str(nValor,TAMSX3("CT4_ANTCRD")[1],TAMSX3("CT4_ANTCRD")[2])) + ", "   			
				cQuery += "CT4_ATUCRD =  CT4_ATUCRD " + cOperacao + (Str(nValor,TAMSX3("CT4_ATUCRD")[1],TAMSX3("CT4_ATUCRD")[2])) + " "   			    
			EndIf
			cQuery += "WHERE CT4_FILIAL = '"+cFilX+"' AND "
			cQuery += "CT4_TPSALD = '"+cTpSald+"' AND "                           
			cQuery += "CT4_ITEM ='"+cItem+"' AND "									
			cQuery += "CT4_CUSTO ='"+cCusto+"' AND "						
			cQuery += "CT4_CONTA ='"+cConta+"' AND "			
			cQuery += "CT4_MOEDA ='"+cMoeda+"' AND "			
			cQuery += "CT4_DATA > '"+Dtos(dData)+"' AND "
			cQuery 	+= "D_E_L_E_T_<>'*' AND " 		
		
			While cGrvSldCT4->(!EOF())
		
				nMin := (cGrvSldCT4)->RECNO
				
				nCountReg := 0
				
				While cGrvSldCT4->(!EOF()) .and. nCountReg <= 4096
				
					nMax := (cGrvSldCT4)->RECNO
					nCountReg++
					cGrvSldCT4->(DbSkip())

				End
				
				cChave := "R_E_C_N_O_>="+Str(nMin,10,0)+" AND R_E_C_N_O_<="+Str(nMax,10,0)+""
				TcSqlExec(cQuery+cChave)
				
			End

			If ( Select ( cGrvSldCT4 ) <> 0 )
				dbSelectArea ( cGrvSldCT4 )
				dbCloseArea ()
			Endif      			            

			dbSelectArea("CT4")
			nRecCT4	:= CT4->(Recno())
			dbGoto(0)
			dbGoto(nRecCT4)		
		
		Else			
	#ENDIF
		While !Eof() .And. CT4->CT4_FILIAL == cFilX .And. ;
			CT4->CT4_TPSALD == cTpSald .And. CT4->CT4_CONTA == cConta .And. ;
			CT4->CT4_CUSTO == cCusto .And. CT4->CT4_ITEM == cItem .And. ;
			CT4->CT4_MOEDA == cMoeda
			RecLock("CT4")
			CT4->CT4_ANTDEB	:= nAntDeb 
			CT4->CT4_ANTCRD	:= nAntCrd
			CT4->CT4_ATUDEB	:= nAntDeb + CT4->CT4_DEBITO
			CT4->CT4_ATUCRD	:= nAntCrd + CT4->CT4_CREDIT                                  
			CT4->CT4_SLBASE	:= "S"
			CT4->CT4_SLCOMP:= "N"
			MsUnlock()                                                                     		
			nAntDeb 	:= CT4->CT4_ATUDEB
			nAntCrd		:= CT4->CT4_ATUCRD
			dbSkip()
		EndDo
	#IFDEF TOP		
		EndIf
	#ENDIF
Endif

RestArea(aSaveArea)

Return 

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³GravaCtI  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Saldos da Classe de Valores  atualiza saldo dia dia  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³GRAVACTI(cConta,cCusto,cItem,cClasseVlr,cTipo,dData,cMoeda, ³±±
±±³			 ³	nValor,cTpSald)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                     ³±±
±±³          ³ ExpC2 = Centro de Custo                                    ³±±
±±³          ³ ExpC3 = Item Contabil                                      ³±±
±±³          ³ ExpC3 = Classe de Valores                                  ³±±
±±³          ³ ExpC4 = Tipo do Lancamento Contabil                        ³±±
±±³          ³ ExpD1 = Data do Lancamento Contabil                        ³±±
±±³          ³ ExpC5 = Moeda do Lancamento Contabil                       ³±±
±±³          ³ ExpN1 = Valor do Lancamento Contabil                  	  ³±±
±±³          ³ ExpC6 = Tipo do Saldo                                  	  ³±±
±±³          ³ ExpL1 = Define se foi chamado pelo Reprocessamento     	  ³±±
±±³          ³ ExpL2 = Define se atualiza saldo basico na dig.lancamento  ³±±
±±³          ³ ExpL3 = Define se zera os movimentos debito/credito    	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GRAVACTI(cConta,cCusto,cItem,cClasseVlr,cTipo,dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,lZera,dDataLP)

Local aSaveArea		:= GetArea()
Local lInclui		:= .F.
Local nAntDeb		:= 0
Local nAntCrd		:= 0                     
Local aSldAntCTI 	:= {}
Local cChave		:= ""

lReproc 			:= Iif(lReproc==Nil,.F.,lReproc)
lAtSldBase			:= Iif(lAtSldBase==Nil,.T.,lAtSldBase) 
lZera				:= Iif(lZera == Nil,.F.,lZera)
dDataLP				:= Iif(dDataLP == Nil,CTOD("  /  /  "),dDataLP)

If Empty(cClasseVlr) .Or. nValor <= 0
	Return
EndIf	

BEGIN TRANSACTION
	DbSelectArea("CTI")

	If Empty(dDataLP)
		cChave	:= xFilial()+cMoeda+cTpSald+cConta+cCusto+cItem+cClasseVlr+Dtos(dData)
	Else
		cChave	:= xFilial()+cMoeda+cTpSald+cConta+cCusto+cItem+cClasseVlr+Dtos(dData)+"Z"	
	EndIf

	DbSetOrder(1)
	If !MsSeek(cChave,.t.)
		lInclui := .T.
	Else
		lInclui	:= .F.
		//Se nao for lancamento de zeramento e posicionar no saldo de zeramento.
		//Devera ser incluido um novo registro. 		
		If Empty(dDataLP) .And. CTI->CTI_LP == 'Z'
			lInclui := .T.			
		EndIf
	EndIf

	// Nao ha registro para o dia -> cria!!
	If lInclui
		RecLock( "CTI", .t. )
		CTI->CTI_FILIAL 	:= xFilial()
		CTI->CTI_CLVL		:= cClasseVlr
		CTI->CTI_CONTA		:= cConta
		CTI->CTI_CUSTO		:= cCusto
		CTI->CTI_ITEM		:= cItem
		CTI->CTI_MOEDA		:= cMoeda
		CTI->CTI_DATA		:= dData
		CTI->CTI_TPSALD	:= cTpSald
		CTI->CTI_STATUS	:= "1"					// Periodo Aberto
		If !Empty(dDataLP)
			CTI->CTI_LP 	:= 'Z'						//Se for lancamento de zeramento
		Else
			CTI->CTI_LP		:= "N"					// Flag indicando que ainda nao foi zerado
		EndIf

	Else
		RecLock( "CTI", .f. )
		//Se for chamado pela rotina de Atualizacao de Saldos Compostos, 
		// os movimentos devem ser zerados.
		If lZera      
			If cTipo == "1"
				CTI->CTI_DEBITO	:= 0
			ElseIf cTipo == "2"				
				CTI->CTI_CREDIT	:= 0			
			EndIf
		EndIf		
	Endif
	
	//Rotina para recuperar saldo anterior
    If !lInclui .And. lZera 	//Se for CTBA360.
		aSldAntCTI := SldAntCTI(cConta,cCusto,cItem,cClasseVlr,dData,cMoeda,cTpSald,,.T.)
	Else	
		aSldAntCTI := SldAntCTI(cConta,cCusto,cItem,cClasseVlr,dData,cMoeda,cTpSald,,lInclui)
	EndIf                                                            
	nAntDeb	:= aSldAntCTI[1]
	nAntCrd	:= aSldAntCTI[2]
	

	// Grava valores atuais
	If cTipo == "1"
		CTI->CTI_ANTDEB	:= nAntDeb	
		CTI->CTI_DEBITO	:= (CTI->CTI_DEBITO + nValor)
		CTI->CTI_ATUDEB	:= CTI->CTI_ANTDEB+CTI->CTI_DEBITO		
		CTI->CTI_ANTCRD	:= nAntCrd		
		CTI->CTI_ATUCRD	:= CTI->CTI_ANTCRD+CTI->CTI_CREDIT
	ElseIf cTipo == "2"                                   
		CTI->CTI_ANTCRD	:= nAntCrd	
		CTI->CTI_CREDIT	:= (CTI->CTI_CREDIT + nValor)
		CTI->CTI_ATUCRD	:= CTI->CTI_ANTCRD+CTI->CTI_CREDIT		
		CTI->CTI_ANTDEB	:= nAntDeb		
		CTI->CTI_ATUDEB	:= CTI->CTI_ANTDEB+CTI->CTI_DEBITO		
	EndIf	
	//Atualiza flag de saldo basico.	
	#IFDEF TOP
		CTI->CTI_SLBASE	:= "S"
	#ENDIF	
	MsUnlock()


	//Chama funcao que grava o saldo anterior e o saldo atual
	GRVSLDCTI(cTipo,cConta,cCusto,cItem,cClasseVlr,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,lAtSldBase,,lZera,"+")
    
END TRANSACTION

RestArea(aSaveArea)

Return                                    

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³SldAntCTI ³ Autor ³ Simone Mie Sato       ³ Data ³ 15.10.01   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Recupera saldo anterior a data inicial                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³SLDANTCTI(cConta,cCusto,cItem,cClasseVlr,dData,cMoeda,cTpsald ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                       ³±±
±±³          ³ ExpC2 = Centro de Custo                                      ³±±
±±³          ³ ExpC3 = Item Contabil                                        ³±±
±±³          ³ ExpC4 = Classe de Valor                                      ³±±
±±³          ³ ExpC5 = Tipo do Lancamento Contabil                          ³±±
±±³          ³ ExpD1 = Data do Lancamento Contabil                          ³±±
±±³          ³ ExpC6 = Moeda do Lancamento Contabil                         ³±±
±±³          ³ ExpN1 = Valor do Lancamento Contabil                         ³±±
±±³          ³ ExpC7 = Tipo do Saldo                                   		 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SLDANTCTI(cConta,cCusto,cItem,cClasseVlr,dData,cMoeda,cTpSald,cFilx,lDbSkip1)
                                                                           
Local aSaveArea	:= GetArea()
Local nAntDeb		:= 0	//Saldo anterior Debito Conta/C.Custo/Item
Local nAntCrd		:= 0	//Saldo anterior Credito Conta/C.Custo/Item           

#IFDEF TOP
	Local aTamVlr		:= TAMSX3("CTI_ATUDEB")
	Local cAliasCTI 	:= ""   		
	Local cOrderCTI 	:= ""	
	Local cQuery		:= ""	
#ENDIF

DEFAULT lDbSkip1 := .T.

If Empty(cFilX)
	cFilX	:= xFilial("CTI")
EndIf

#IFDEF TOP                             
	If TcSrvType() != "AS/400"                     		
		cOrderCTI := SqlOrder(indexKey())
		cAliasCTI := "cAliasCTI"   		

		cQuery := "SELECT CTI_DATA, CTI_ATUDEB, CTI_ATUCRD "
		cQuery += "FROM "+RetSqlName("CTI")+" CTI "
		cQuery += "WHERE CTI.CTI_FILIAL ='"+cFilX+"' AND "
		cQuery += "CTI.CTI_MOEDA ='"+cMoeda+"' AND "
		cQuery += "CTI.CTI_TPSALD ='"+cTpSald+"' AND "
		cQuery += "CTI.CTI_CONTA = '"+cConta+"' AND "		 		
		cQuery += "CTI.CTI_CUSTO='"+cCusto+"' AND "			
		cQuery += "CTI.CTI_ITEM='"+cItem+"' AND "
		cQuery += "CTI.CTI_CLVL='"+cClasseVlr+"' AND "
		cQuery += "CTI.D_E_L_E_T_ <> '*' AND "				
		cQuery += "CTI.CTI_DATA = (SELECT MAX(CTI_DATA) "
		cQuery += "FROM "+RetSqlName("CTI")+" CTI2 "
		cQuery += "WHERE CTI2.CTI_FILIAL ='"+cFilX+"' AND "			
		cQuery += "CTI2.CTI_MOEDA = '"+cMoeda+"' AND "	 
		cQuery += "CTI2.CTI_TPSALD = '"+cTpSald+"' AND "					
		cQuery += "CTI2.CTI_CONTA = '"+cConta+"' AND "		
		cQuery += "CTI2.CTI_CUSTO='"+cCusto+"' AND "			 
		cQuery += "CTI2.CTI_ITEM='"+cItem+"' AND "    
		cQuery += "CTI2.CTI_CLVL='"+cClasseVlr+"' AND "
		cQuery += "CTI2.CTI_DATA < '"+DTOS(dData)+"' AND "		 
		cQuery += "CTI2.D_E_L_E_T_ <> '*') AND "
		cQuery += "CTI.CTI_LP = (SELECT MAX(CTI_LP) "
		cQuery += "FROM "+RetSqlName("CTI")+" CTI3 "
		cQuery += "WHERE CTI3.CTI_FILIAL ='"+cFilX+"' AND "			
		cQuery += "CTI3.CTI_MOEDA = '"+cMoeda+"' AND "	 
		cQuery += "CTI3.CTI_TPSALD = '"+cTpSald+"' AND "					
		cQuery += "CTI3.CTI_CONTA = '"+cConta+"' AND "		
		cQuery += "CTI3.CTI_CUSTO='"+cCusto+"' AND "			 
		cQuery += "CTI3.CTI_ITEM='"+cItem+"' AND "    
		cQuery += "CTI3.CTI_CLVL='"+cClasseVlr+"' AND "
		cQuery += "CTI3.CTI_DATA = (SELECT MAX(CTI_DATA) "
		cQuery += "FROM "+RetSqlName("CTI")+" CTI4 "
		cQuery += "WHERE CTI4.CTI_FILIAL ='"+cFilX+"' AND "			
		cQuery += "CTI4.CTI_MOEDA = '"+cMoeda+"' AND "	 
		cQuery += "CTI4.CTI_TPSALD = '"+cTpSald+"' AND "					
		cQuery += "CTI4.CTI_CONTA = '"+cConta+"' AND "		
		cQuery += "CTI4.CTI_CUSTO='"+cCusto+"' AND "			 
		cQuery += "CTI4.CTI_ITEM='"+cItem+"' AND "    
		cQuery += "CTI4.CTI_CLVL='"+cClasseVlr+"' AND "
		cQuery += "CTI4.CTI_DATA < '"+DTOS(dData)+"' AND "		 
		cQuery += "CTI4.D_E_L_E_T_ <> '*') AND "
		cQuery += "CTI3.D_E_L_E_T_ <> '*')"
		
		cQuery := ChangeQuery(cQuery)		   
			
		If ( Select ( cAliasCTI ) <> 0 )
			dbSelectArea ( cAliasCTI )
			dbCloseArea ()
		Endif

  		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasCTI,.T.,.F.)
  		
		TCSetField(cAliasCTI,"CTI_DATA", "D",8,0)				  		
		TCSetField(cAliasCTI,"CTI_ATUDEB", "N",aTamVlr[1],aTamVlr[2])	
		TCSetField(cAliasCTI,"CTI_ATUCRD", "N",aTamVlr[1],aTamVlr[2])			
  		
		nAntDeb 	:= (cAliasCTI)->CTI_ATUDEB
		nAntCrd 	:= (cAliasCTI)->CTI_ATUCRD			
		
		dbCloseArea()
		dbSelectArea("CTI")	                     
	
		If ( Select ( cAliasCTI ) <> 0 )
			dbSelectArea ( cAliasCTI )
			dbCloseArea ()
		Endif			
	Else
#ENDIF

	If lDbSkip1
		dbSkip(-1)
	Endif
	If (xFilial()+cMoeda+cTpSald+cConta+cCusto+cItem+cClasseVlr) == ;
		(CTI->CTI_FILIAL+CTI->CTI_MOEDA+CTI->CTI_TPSALD+CTI->CTI_CONTA+;
		CTI->CTI_CUSTO+CTI->CTI_ITEM+CTI->CTI_CLVL) .And.;
		(!Bof() .And. !Eof())    
		If CTI->CTI_DATA == dData
			If lDbSkip1 .And. CTI->CTI_LP <> "Z"		
				nAntDeb		:= CTI->CTI_ATUDEB
				nAntCrd		:= CTI->CTI_ATUCRD			
			Else                              
				nAntDeb 	:= CTI->CTI_ANTDEB
				nAntCrd 	:= CTI->CTI_ANTCRD		
			EndIf
		Else                               		
			nAntDeb 	:= CTI->CTI_ATUDEB
			nAntCrd 	:= CTI->CTI_ATUCRD
		EndIf
	Else
		nAntDeb	:= 0
		nAntCrd	:= 0
	EndIf
	If (!Bof())
		dbSkip()
	EndIf

#IFDEF TOP
	Endif
#ENDIF

RestArea(aSaveArea)

Return{nAntDeb,nAntCrd}                                    


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³DSGravaCtI³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³DesGrava Saldos da Classe de Valores  atualiza saldo dia dia³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³DSGRAVACTI(cConta,cCusto,cItem,cClasseVlr,cTipo,dData,cMoeda³±±
±±³			 ³	nValor,cTpSald)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                     ³±±
±±³          ³ ExpC2 = Centro de Custo                                    ³±±
±±³          ³ ExpC3 = Item Contabil                                      ³±±
±±³          ³ ExpC3 = Classe de Valores                                  ³±±
±±³          ³ ExpC4 = Tipo do Lancamento Contabil                        ³±±
±±³          ³ ExpD1 = Data do Lancamento Contabil                        ³±±
±±³          ³ ExpC5 = Moeda do Lancamento Contabil                       ³±±
±±³          ³ ExpN1 = Valor do Lancamento Contabil                  	  ³±±
±±³          ³ ExpC6 = Tipo do Saldo                                  	  ³±±
±±³          ³ ExpL1 = Define se foi chamado pelo Reprocessamento     	  ³±±
±±³          ³ ExpL2 = Define se atualiza saldo basico na dig. lancamento ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function DSGRAVACTI(cConta,cCusto,cItem,cClasseVlr,cTipo,dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,dDataLP,nOpc)

Local aSaveArea		:= GetArea()
Local nAntDeb	 	:= 0
Local nAntCrd	 	:= 0
Local aSldAntCTI 	:= {}
lReproc 			:= Iif(lReproc==Nil,.F.,lReproc)
lAtSldBase			:= Iif(lAtSldBase==Nil,.T.,lAtSldBase) 
dDataLP				:= Iif(dDataLP==Nil,CTOD("  /  /  "),dDataLP)
nOpc				:= Iif(nOpc==Nil,4,nOpc)

DbSelectArea("CTI")
If Empty(dDataLP)
	cChave	:= xFilial()+cMoeda+cTpSald+cConta+cCusto+cItem+cClasseVlr+Dtos(dData)
Else
	cChave	:= xFilial()+cMoeda+cTpSald+cConta+cCusto+cItem+cClasseVlr+Dtos(dData)+"Z"	
EndIf
DbSelectArea("CTI")
DbSetOrder(1)
If !MsSeek(cChave) .Or. Empty(cClasseVlr)
	Return
Else
	//Se nao for lancamento de zeramento e posicionar no saldo de zeramento.
	//Devera ser incluido um novo registro. 		
	If Empty(dDataLP) .And. CTI->CTI_LP == 'Z'
		Return
	EndIf
EndIf

BEGIN TRANSACTION
	//Rotina para recuperar saldo anterior
	aSldAntCTI := SldAntCTI(cConta,cCusto,cItem,cClasseVlr,dData,cMoeda,cTpSald)
                                                                 
	nAntDeb	:= aSldAntCTI[1]
	nAntCrd	:= aSldAntCTI[2]

	// Descalcula
	RecLock("CTI")
	If cTipo == "1"
		If CTI->CTI_DEBITO < nValor
			CTI->CTI_DEBITO := 0
		Else
			CTI->CTI_DEBITO	:= (CTI->CTI_DEBITO - nValor)
			#IFDEF TOP
				CTI->CTI_ANTDEB	:= nAntDeb
				CTI->CTI_ATUDEB	:= CTI->CTI_ANTDEB+CTI->CTI_DEBITO			
				CTI->CTI_ANTCRD	:= nAntCrd
				CTI->CTI_ATUCRD	:= CTI->CTI_ANTCRD+CTI->CTI_CREDIT
			#ENDIF						
		EndIf	
	ElseIf cTipo == "2"
		If CTI->CTI_CREDIT < nValor
			CTI->CTI_CREDIT := 0
		Else
			CTI->CTI_CREDIT	:= (CTI->CTI_CREDIT - nValor)
			#IFDEF TOP
				CTI->CTI_ANTCRD	:= nAntCrd
				CTI->CTI_ATUCRD	:= CTI->CTI_ANTCRD+CTI->CTI_CREDIT			
				CTI->CTI_ANTDEB	:= nAntDeb
				CTI->CTI_ATUDEB	:= CTI->CTI_ANTDEB+CTI->CTI_DEBITO
			#ENDIF						
		EndIf	
	EndIf
	MsUnlock()

	//Se na exclusao, zerar os valores de mov. debito e credito, deleta o registro no 
	//arquivo de saldos, pois no reprocessamento nao refaz os saldos que nao tenham 
	//lancamentos no CT2, e da diferenca no balancete.
	If CTI->CTI_CREDIT == 0  .And. CTI->CTI_DEBITO == 0
		RecLock("CTI",.F.,.T.)
		CTI->(dbDelete())
		CTI->(MsUnlock())
		dbSelectArea("CTI")
		dbSkip()
		//Chama funcao que grava o saldo anterior e o saldo atual			
		//A variavel lAtSldBase esta sendo passada como .T. para atualizar o flag
		If nOpc == 5
			GRVSLDCTI(cTipo,cConta,cCusto,cItem,cClasseVlr,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,.F.,.T.,,,"-")	
		Else
			GRVSLDCTI(cTipo,cConta,cCusto,cItem,cClasseVlr,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,.T.,,,"-")			
		EndIf
	Else
		//Chama funcao que grava o saldo anterior e o saldo atual
		If nOpc == 5 //	//Se for exclusao de lancamento contabil, atualiza os saldos, pois o lancamento contabil eh deletado		
			GRVSLDCTI(cTipo,cConta,cCusto,cItem,cClasseVlr,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,.F.,.T.,,,"-")
		Else
			GRVSLDCTI(cTipo,cConta,cCusto,cItem,cClasseVlr,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,lAtSldBase,,,"-")		
		EndIf
	Endif
	
END TRANSACTION

RestArea(aSaveArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³GRVSLDCTI ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Saldo Anterior e Saldo Atual do CTI				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GRVSLDCTI(cConta,cCusto,cItem,cClasseVlr,cMoeda,cTpSald,   ³±±
±±³          ³  nAntDeb,nAntCrd,lReproc,lAtSldBase)	    		    	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                     ³±±
±±³          ³ ExpC2 = Centro de Custo			                          ³±±
±±³          ³ ExpC3 = Item Contabil			                          ³±±
±±³          ³ ExpC4 = Classe de Valor			                          ³±±
±±³          ³ ExpC5 = Moeda do Lancamento Contabil                       ³±±
±±³          ³ ExpC6 = Tipo do Saldo                                  	  ³±±
±±³          ³ ExpN1 = Valor Anterior Debito                         	  ³±±
±±³          ³ ExpN2 = Valor Anterior Credito                        	  ³±±
±±³          ³ ExpL1 = Indica se deve atual.os saldos dos dias posteriores³±±
±±³          ³ ExpL2 = Indica se devera preencher o flag de atual. saldos ³±±
±±³          ³ ExpC7 = Filial                                         	  ³±±
±±³          ³ ExpL3 = Define se zera os movimentos debito/credito        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GRVSLDCTI(cTipo,cConta,cCusto,cItem,cClasseVlr,cMoeda,cTpSald,dData,nValor,nAntDeb,nAntCrd,lReproc,lAtSldBase,cFilX,lZera,cOperacao)			

Local aSaveArea		:= GetArea()
Local nRegCTI		:= Recno()
#IFDEF TOP
	Local cChave		:= ""
	Local cGrvSldCTI    := ""	
	Local cQuery		:= ""	
	Local nCountReg		:= 0	
	Local nMax			:= 0
	Local nMin			:= 0
	Local nRecCTI		:= 0
#ENDIF

lReproc 			:= Iif(lReproc==Nil,.F.,lReproc)
lAtSldBase			:= Iif(lAtSldBase==Nil,.T.,lAtSldBase) 
cFilX				:= Iif(cFilX==Nil,xFilial("CTI"),cFilX)                                                                     
DEFAULT cOperacao	:= "+"

// Recalcula valores
nRegCTI := Recno()
If lReproc
	If !Eof() .And. CTI->CTI_FILIAL == cFilX .And. ;
			CTI->CTI_TPSALD == cTpSald .And. CTI->CTI_CONTA == cConta .And. ;
			CTI->CTI_CUSTO == cCusto .And. CTI->CTI_ITEM == cItem .And. ;
			CTI->CTI_CLVL == cClasseVlr .And. CTI->CTI_MOEDA == cMoeda
			RecLock("CTI")
			CTI->CTI_ANTDEB	:= nAntDeb 
			CTI->CTI_ANTCRD	:= nAntCrd
			CTI->CTI_ATUDEB	:= nAntDeb + CTI->CTI_DEBITO
			CTI->CTI_ATUCRD	:= nAntCrd + CTI->CTI_CREDIT
			CTI->CTI_SLCOMP := "N"               
			//Se for Reprocessamento, devera estar com flag de atualizado
			//para nao precisar atualizar novamente. 
			If lAtSldBase .Or. lZera
				CTI->CTI_SLBASE	:= "S"
			Else 		 	  //Flag de Atualizacao de saldo,para identificar que o
				CTI->CTI_SLBASE	:= "N"//saldo devera ser atualizado a partir desse reg.    
			EndIf
			MsUnlock()
	EndIf
Else
	#IFDEF TOP                             
		If TcSrvType() != "AS/400"                     			
			CTI->(dbCommit())
			cGrvSldCTI := "cGrvSldCTI"   		
			cQuery   	:= "SELECT R_E_C_N_O_ RECNO "
			cQuery   	+=" FROM "+RetSqlName("CTI")+" CTI "
			cQuery		+= "WHERE CTI.CTI_FILIAL = '"+cFilX+"' AND "
			cQuery   	+= "CTI.CTI_TPSALD = '"+cTpSald+"' AND "                  
			cQuery 		+= "CTI.CTI_CLVL ='"+cClasseVlr+"' AND "												
			cQuery   	+= "CTI.CTI_ITEM ='"+cItem+"' AND "									
			cQuery   	+= "CTI.CTI_CUSTO ='"+cCusto+"' AND "						
			cQuery   	+= "CTI.CTI_CONTA ='"+cConta+"' AND "			
			cQuery   	+= "CTI.CTI_MOEDA ='"+cMoeda+"' AND "			
			cQuery 		+= "CTI_DATA > '"+Dtos(dData)+"' AND "		
			cQuery   	+= "D_E_L_E_T_<>'*' " 		
			cQuery   	+= "ORDER BY RECNO" 					
			cQuery		:= ChangeQuery(cQuery)   
		
			If ( Select ( cGrvSldCTI ) <> 0 )
				dbSelectArea ( cGrvSldCTI )
				dbCloseArea ()
			Endif
			
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cGrvSldCTI,.T.,.F.)
			
			cQuery := "UPDATE "
			cQuery += RetSqlName("CTI")+" "				
			cQuery += "SET " 
			If cTipo = "1"
				cQuery += "CTI_ANTDEB = CTI_ANTDEB " + cOperacao + (Str(nValor,TAMSX3("CTI_ANTDEB")[1],TAMSX3("CTI_ANTDEB")[2])) +", "
				cQuery += "CTI_ATUDEB = CTI_ATUDEB " + cOperacao + (Str(nValor,TAMSX3("CTI_ATUDEB")[1],TAMSX3("CTI_ATUDEB")[2])) + " "   			
			ElseIf cTipo = "2"	
				cQuery += "CTI_ANTCRD =  CTI_ANTCRD " + cOperacao + (Str(nValor,TAMSX3("CTI_ANTCRD")[1],TAMSX3("CTI_ANTCRD")[2])) + ", "   			
				cQuery += "CTI_ATUCRD =  CTI_ATUCRD " + cOperacao + (Str(nValor,TAMSX3("CTI_ATUCRD")[1],TAMSX3("CTI_ATUCRD")[2])) + " "   			    
			EndIf
			cQuery += "WHERE CTI_FILIAL = '"+cFilX+"' AND "
			cQuery += "CTI_TPSALD = '"+cTpSald+"' AND "                           
			cQuery += "CTI_CLVL ='"+cClasseVlr+"' AND "												
			cQuery += "CTI_ITEM ='"+cItem+"' AND "									
			cQuery += "CTI_CUSTO ='"+cCusto+"' AND "						
			cQuery += "CTI_CONTA ='"+cConta+"' AND "			
			cQuery += "CTI_MOEDA ='"+cMoeda+"' AND "			
			cQuery += "CTI_DATA > '"+Dtos(dData)+"' AND "
			cQuery 	+= "D_E_L_E_T_<>'*' AND " 		
		
			While cGrvSldCTI->(!EOF())
		
				nMin := (cGrvSldCTI)->RECNO
				
				nCountReg := 0
				
				While cGrvSldCTI->(!EOF()) .and. nCountReg <= 4096
				
					nMax := (cGrvSldCTI)->RECNO
					nCountReg++
					cGrvSldCTI->(DbSkip())

				End
				
				cChave := "R_E_C_N_O_>="+Str(nMin,10,0)+" AND R_E_C_N_O_<="+Str(nMax,10,0)+""
				TcSqlExec(cQuery+cChave)
				
			End

			If ( Select ( cGrvSldCTI ) <> 0 )
				dbSelectArea ( cGrvSldCTI )
				dbCloseArea ()
			Endif						

			dbSelectArea("CTI")
			nRecCTI	:= CTI->(Recno())
			dbGoto(0)
			dbGoto(nRecCTI)		
		
		Else
	#ENDIF
		While !Eof() .And. CTI->CTI_FILIAL == cFilX .And. ;
				CTI->CTI_TPSALD == cTpSald .And. CTI->CTI_CONTA == cConta .And. ;
				CTI->CTI_CUSTO == cCusto .And. CTI->CTI_ITEM == cItem .And. ;
				CTI->CTI_CLVL == cClasseVlr .And. CTI->CTI_MOEDA == cMoeda
			RecLock("CTI")
			CTI->CTI_ANTDEB	:= nAntDeb 
			CTI->CTI_ANTCRD	:= nAntCrd
			CTI->CTI_ATUDEB	:= nAntDeb + CTI->CTI_DEBITO
			CTI->CTI_ATUCRD	:= nAntCrd + CTI->CTI_CREDIT
			CTI->CTI_SLBASE	:= "S"
			CTI->CTI_SLCOMP := "N"		
			MsUnlock()
			nAntDeb 	:= CTI->CTI_ATUDEB
			nAntCrd		:= CTI->CTI_ATUCRD
			dbSkip()
		EndDo
	#IFDEF TOP		
		EndIf
	#ENDIF
Endif
RestArea(aSaveArea)

Return 


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ C050Next  ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 30/11/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gera numero de Lote e Documento na valida‡„o da Data.       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ C050NextdDataLanc,cLote,cSubLote,cDoc,oLote,oSubLote,oDoc,; ³±±
±±³			 ³	  CTF_LOCK,nOpc,nOperacao)  			                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Ctba050                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpD1 = Data do Lancamento								   ³±±
±±³          ³ ExpC1 = Lote                  							   ³±±
±±³          ³ ExpC2 = SubLote               							   ³±±
±±³          ³ ExpC3 = Documento             							   ³±±
±±³          ³ ExpO1 = Objeto do lote        							   ³±±
±±³          ³ ExpO2 = Objeto do Sublote     							   ³±±
±±³          ³ ExpO3 = Objeto do Documento   							   ³±±
±±³          ³ ExpN1 = Semaforo para proximo documento                     ³±±
±±³          ³ ExpN2 = Numero da Opcao escolhida                           ³±±
±±³          ³ ExpN3 = Numero da Operacao                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function C050Next(dDataLanc,cLote,cSubLote,cDoc,oLote,oSubLote,oDoc,CTF_LOCK,nOpc,nOperacao)

Local aSaveArea:= GetArea()
Local lRet := .T.

dbSelectArea("CTF")
dbSetOrder(1)

If nOperacao == 2 		// Lancamento de integracao
	MsSeek(xFilial()+Dtos(dDataLanc)+cLote+cSubLote+cDoc,.t.)
EndIf	

If nOpc == 3 .Or. nOpc == 6
	
	Ctb105Next(dDataLanc,@cLote ,@cSubLote,@cDoc,nOperacao,@oLote,@oSubLote,@oDoc,@CTF_LOCK)		// Gera n£mero de Documento
	
	If ValType(oLote) == "O" .And. ValType(oSubLote) == "O" .And. ValType(oDoc)  == "O"
		oLote:Refresh()	;oSubLote:Refresh();oDoc:Refresh()		// Atualiza a Tela
	EndIf	
EndIf

RestArea(aSaveArea)

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CTB105Next ³ Autor ³ Pilar S Albaladejo    ³ Data ³04.02.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gera pr¢ximo n£mero de Documento / Lote                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Ctb105Next(dDataLanc,@cLote,@cSubLote,@cDoc)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CTBA050 / CTBA105                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpD1 = Data do Lan‡amento								   ³±±
±±³			 ³ ExpC1 = Lote 											   ³±±
±±³          ³ Expc2 = SubLote											   ³±±
±±³          ³ Expc3 = Documento										   ³±±
±±³          ³ ExpN1 = Numero da Operacao 								   ³±±
±±³          ³ ExpO1 = Objeto do Lote     								   ³±±
±±³          ³ ExpO2 = Objeto do SubLote  								   ³±±
±±³          ³ ExpO3 = Objeto do Documento								   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION CTB105Next(dDataLanc,cLote,cSubLote,cDoc,nOperacao,oLote,oSubLote,oDoc,CTF_LOCK)

Local aSaveArea	:= GetArea()
Local nIndCT2	:= CT2->(IndexOrd())
Local nRecCT2	:= CT2->(Recno())

DEFAULT CTF_LOCK:= 0

// Indica se o lancamento eh manual (1) ou de integracao (2)
nOperacao := Iif(nOperacao == Nil,1,nOperacao)
             
If nOperacao == 1
	If CTF_LOCK > 0							/// SE HOUVER CTF_LOCK INDICA ALTERACAO/EXCLUSAO
		dbSelectArea("CTF")		
		DbGoto(CTF_LOCK)     
		CtbDestrava(CTF->CTF_DATA,CTF->CTF_LOTE,CTF->CTF_SBLOTE,CTF->CTF_DOC,@CTF_LOCK)		///	(MAS CHECA SE OUTRO USUÁRIO NAO GRAVOU CT2 COM O MESMO NUMERO PARA NÃO DELETAR INDEVIDO)
	Endif

	If Empty(cLote)
		If GetNewPar("MV_LOTECON","T") == "T"				// Numero de Lote vindo da Tabela SX5 (MV_LOTECON = T)
			cLote := If(cModulo=="CTB",Tabela("09","CON"),Tabela("09",cModulo))
			cLote := Iif(Len(Alltrim(cLote)) < 6, PADL(cLote,6,"0"),cLote)
		Else							// Numero de Lote Sequencial pelo CTF (MV_LOTECON = U)
			dbSelectArea("CTF") 
			dbSetOrder(1)
			If !MsSeek(xFilial("CTF")+Dtos(dDataLanc)+"ZZZZZZZZZ",.t.)
				dbSkip(-1)         
				If dtos(CTF->CTF_DATA) == dtos(dDataLanc)
					cLote    := Soma1(CTF->CTF_LOTE)
				Else
					cLote    := '000001'
				Endif
			Endif
		Endif
	Endif
	
	If !lSubLote
		cSubLote := cLoteSub
	Endif
Else
	Return(.T.)
EndIf
                  
Do While !ProxDoc(dDataLanc,cLote,cSubLote,@cDoc,@CTF_LOCK)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso o N§ do Doc estourou, incrementa o lote         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cLote := SOMA1(cLote)
	DbSelectArea("SX5")
	MsSeek(xFilial("SX5")+"09"+If(cModulo=="CTB","CON",cModulo))
	RecLock("SX5")
	SX5->X5_DESCRI := Substr(cLote,3,4)
	MsUnlock()
Enddo

CT2->(dbSetOrder(nIndCT2))		//// VOLTA A POSICAO ORIGINAL NO CT2 - INDICE
CT2->(dbGoTo(nRecCT2))			//// VOLTA A POSICAO ORIGINAL NO CT2 - REGISTRO
RestArea(aSaveArea)

If ValType(oLote) == "O" .And. ValType(oSubLote) == "O" .And. ValType(oDoc) == "O"
	oLote:Refresh()	;oSubLote:Refresh();oDoc:Refresh()		// Atualiza a Tela
EndIf	

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³UnLockDoc  ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 30/11/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna o Numero do Documento (apaga registro no CTF)       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ UnLockDoc(Ctf_Lock)				                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Ctba050                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Semaforo para proximo documento                     ³±±                    								   
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function UnLockDoc(Ctf_Lock)

If CTF_Lock > 0
	DbSelectArea("CTF")
	dbGoto(CTF_Lock)                   
	If CTF->(RLock())
		CTF->(MsUnlock())
		Reclock("CTF",.F.)
		CTF->(dbDelete())
		MsUnlock()
	Endif
	CTF_Lock := 0
Endif

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ LockDoc   ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 30/11/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Trava o Documento a ser utilizado no Lan‡amento Cont bil    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LockDoc( dDataLanc , cLote , cDoc )                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ CTBA050 / CTBA105                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpD1 = Data do Lan‡amento 							       ³±±
±±³          ³ ExpC1 = Lote Cont bil 									   ³±±
±±³          ³ ExpC2 = SubLote                     						   ³±±
±±³          ³ ExpC3 = N£mero do Documento 								   ³±±
±±³          ³ ExpN1 = Semaforo para proximo documento                     ³±±                    								   
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LockDoc(dDataLanc,cLote,cSubLote,cDoc,CTF_LOCK )

Local aSaveArea := GetArea()

RecLock("CTF",.T.)
CTF->CTF_FILIAL		:= xFilial("CTF")
CTF->CTF_DATA		:= dDataLanc
CTF->CTF_LOTE		:= cLote
CTF->CTF_SBLOTE		:= cSubLote
CTF->CTF_DOC		:= cDoc
CTF->(MsUnlock())
CTF->(dbCommit())
CTF->(FKCOMMIT())
//³Não efetuar o MsUnlock() - O Registro deve ficar reservado³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄå
RecLock("CTF",.F.)
CTF_LOCK := CTF->(Recno())

RestArea(aSaveArea)

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ ProxDoc   ³ Autor ³ Pilar S Albaladejo    ³ Data ³04.02.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gera pr¢ximo n£mero de Documento baseado na Data / Lote     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ProxDoc ( dDataLan, cLote ,cSublote, @cDoc )	               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. /.F. (Se retornou .F. ‚ por que estourou o doc no Lote) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ CTBA105 , CTBA050                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpD1 = Data do lan‡amento								   ³±±
±±³          ³ ExpC1 = Lote Cont bil 									   ³±±
±±³          ³ ExpC2 = Sub-Lote Cont bil								   ³±±
±±³          ³ Expc3 = N§ do Doc (X Referˆncia)							   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/                 
FUNCTION ProxDoc(dDataLanc,cLote,cSubLote,cDoc,CTF_LOCK)

Local aArea     := GetArea()
Local aAreaCTF  := CTF->(GetArea())
Local aAreaCT2  := CT2->(GetArea())
Local lRet		:= .T.
Local cKeyCTF	:= ""

#IFNDEF TOP
	Local nNumDoc	:= 0                                           	
#ENDIF

DEFAULT CTF_LOCK := 0

dbSelectArea( "CTF" )
dbSetOrder( 1 )   
cKeyCTF := xFilial("CTF")+dtos(dDataLanc)+cLote+cSubLote

If ExistBlock("CTBPRXDOC")
	cDoc := ExecBlock("CTBPRXDOC",.F.,.F.,{dDataLanc,cLote,cSubLote})
Else
	#IFDEF TOP
	 	lQuery := .F.
		cQuery := "SELECT Max(CTF_DOC) MAXDOC "
		cQuery += "FROM "+RetSqlName("CTF")+" CTF "
		cQuery += "WHERE CTF_FILIAL='"+xFilial("CTF")+"' AND "
		cQuery += "CTF_DATA = '"+DTOS(dDataLanc)+"' AND "
		cQuery += "CTF_LOTE = '"+cLote+"' AND "
		cQuery += "CTF_SBLOTE = '"+cSubLote+"' AND "
		cQuery += "D_E_L_E_T_=' ' "
		cQuery := ChangeQuery(cQuery)
	    
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"TMPPRXDOC")
	
		cDoc := ("TMPPRXDOC")->MAXDOC
		
		dbSelectArea("TMPPRXDOC")
		("TMPPRXDOC")->(dbCloseArea())
	
		dbSelectArea("CTF")
		              
		If STRZERO(VAL(cDoc),6) == "999999"
			lRet := .F.
		Else
			If Empty(cDoc)
				cDoc := "000001"	
			Else
				cDoc := StrZero(Val(cDoc)+1,6)
			EndIf
		EndIf
	#ELSE
		MsSeek(cKeyCTF+"999999",.T.)        //// SEEK .T. + DBSkip(-1)
		dbSkip(-1)
		If cKeyCTF == CTF->(CTF_FILIAL+DtoS(CTF_DATA)+CTF_LOTE+CTF_SBLOTE)
			nNumDoc := Val(CTF->CTF_DOC)
			If nNumDoc == 999999
				lRet := .F.
			Else
				cDoc := StrZero(nNumDoc+1,6)		
			EndIf	
		Else
			cDoc := "000001"                                
		EndIf
	#ENDIF
EndIf
If lRet
	dbSelectArea("CT2")
	dbSetOrder(1)
	While !MayIUseCode("CTF"+cKeyCTF+cDoc) .Or. CTF->(MsSeek(cKeyCTF+cDoc,.F.)) .Or. CT2->(MsSeek(cKeyCTF+cDoc,.F.))
		Leave1Code("CTF"+cKeyCTF+cDoc)
		If cDoc == "999999"
			lRet := .F.
			Exit
		Else
			cDoc := StrZero(Val(cDoc)+1,6)
		EndIf	
	EndDo
    If lRet
		LockDoc(dDataLanc,cLote,cSubLote,cDoc,@CTF_LOCK)
		Leave1Code("CTF"+cKeyCTF+cDoc)
	EndIF
EndIf
RestArea(aAreaCT2)
RestArea(aAreaCTF)
RestArea(aArea)

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Ctb050Tot  ³ Autor ³ Pilar S Albaladejo    ³ Data ³04.02.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna totais por lote e por documento                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Ctb050Tot( dDataLan, cLote ,cSubLote,cDoc)	               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ aTotais                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGACTB                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpD1 = Data do lan‡amento								   ³±±
±±³          ³ ExpC1 = Lote Cont bil 									   ³±±
±±³          ³ ExpC2 = Sub-Lote Cont bil								   ³±±
±±³          ³ Expc3 = N§ do Doc                						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Ctb050Tot(dDataLanc,cLote,cSubLote,cDoc)

Local aTotais := {{0,0,0,0},{0,0,0,0}}

dbSelectArea("CTC")
dbSetOrder(1)
If MsSeek(xFilial("CTC") + dtos(dDataLanc) + cLote + cSubLote + cDoc)
	aTotais[1] := {CTC->CTC_DIG,CTC->CTC_DEBITO,CTC->CTC_CREDIT,CTC->CTC_INF}
Else
	aTotais[1] := {0,0,0,0}
EndIf

dbSelectArea("CT6")
dbSetOrder(1)
If MsSeek(xFilial("CT6") + dtos(dDataLanc) + cLote + cSubLote)
	aTotais[2] := {CT6->CT6_DIG,CT6->CT6_DEBITO,CT6->CT6_CREDIT,CT6->CT6_INF}
Else
	aTotais[2] := {0,0,0,0}
EndIf

Return aTotais

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CtbCtaSup ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 08.11.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera Codigo da Conta Superior                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbCtaSup(cCodigo)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³cCod                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo da Conta                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbCtaSup(cCodigo)

Local aAmbSave := { Alias(), Indexord(), Recno() }
Local aAmbCT1  := { CT1->(IndexOrd()) , CT1->(Recno()) }
Local cCod , nCont

cCodigo			:= Alltrim(cCodigo)

dbSelectArea("CT1") ; dbSetOrder(1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PONTO DE ENTRADA CTBCTASU                            ³
//³ Criado para gerar conta superior caso nao            ³
//³ siga a regra padrao do Sistema.                      ³
//³ Recebe em PARAMIXB a Conta Cont bil atual.           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("CTBCTASU")
	cCod := ExecBlock("CTBCTASU",.F.,.F.,cCodigo)
Else
	For nCont := 1 to Len(cCodigo)
		cCod  := padr(Substr(cCodigo,1,Len(cCodigo)-nCont),20)
		If MsSeek(xFilial()+cCod,.f.)
			cCod := CT1->CT1_CONTA
			Exit
		EndIf
	Next
EndIf

CT1->(DbSetOrder(aAmbCT1[1])) ; CT1->(DbGoto(aAmbCt1[2]))
DbSelectArea(aAmbSave[1]) ; DbSetOrder(aAmbSave[2]) ; DbGoto(aAmbSave[3])

Return cCod

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CtbDigCont³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 08.11.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera digito de Controle                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbDigCont(cCodigo)                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³cDig                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbDigCont(cCodigo)

Local nSoma		:= 0 
Local nResult	:= 0
Local nTam		:= 0
Local nDig 		:= 0  
Local nCont := 0

Local cDig		:= ""

nTam := Len(Alltrim(cCodigo))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PONTO DE ENTRADA CTBDIGCT                            ³
//³ Criado para criar permitir gera‡„o diferenciada de   ³
//³ d¡gito verificador para Conta Cont bil.              ³
//³ Recebe em PARAMIXB a Conta Cont bil.                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("CTBDIGCT")
	nDig := ExecBlock("CTBDIGCT",.F.,.F.,cCodigo)
	cDig := STR(nDig,1)
Else
	For nCont:=nTam To 1 Step -1
		nSoma:=Val(Substr(cCodigo,nCont,1))*nTam
		nResult+=nSoma
		nTam--
	Next
	nDig := MOD(nResult,11)
	cDig := If( nDig > 9 , "0" , STR(nDig,1) )
EndIf
Return cDig

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Ctba70Hist³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica validade do hist¢rico padronizado.                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Ctba70Hist()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Valida‡„o do SX3 do Campo CT8_DESC                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION Ctba70Hist()

LOCAL cHist := &(ReadVar())
LOCAL i,j,k,l
LOCAL nBytes:=0
LOCAL z :=0

IF Empty(cHist)
	Help(" ",1,"HISTVAZIO")
	Return .F.
EndIf
For i:=1 TO Len(cHist)
	IF SubStr( cHist,i,1 ) == "@"
		z++
		j := i
		k := ""
		While SubStr( cHist,j,1 ) != " " .and. j < Len( cHist )
			j++
			k += SubStr(cHist,j,1)
		EndDo
		l := Len(Trim(k))
		k := Val(k)
		nBytes := nBytes + k - l
	EndIf
Next
IF (nBytes + Len(Trim(cHist)))-z > 40
	Help(" ",1,"MUIGRD")
	Return .F.
EndIF
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³SaldoCT7  ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Saldo do Plano de Contas                                   			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SaldoCT7(cConta,dData,cMoeda,cTpSald)                      			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³{nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                    		    ³±±
±±³          ³ ExpD1 = Data                                              		    ³±±
±±³          ³ ExpC2 = Moeda                                             		    ³±±
±±³          ³ ExpC3 = Tipo de Saldo                                     		    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SaldoCT7(cConta,dData,cMoeda,cTpSald,cRotina,lImpAntLP,dDataLP,cFilEsp)

Local aSaveArea	:= CT7->(GetArea())
Local aSaveAnt	:= GetArea()
Local lNaoAchei	:= .F.
Local nDebito	:= 0				// Valor Debito na Data
Local nCredito 	:= 0				// Valor Credito na Data
Local nAtuDeb  	:= 0				// Saldo Atual Devedor
Local nAtuCrd	:= 0				// Saldo Atual Credor
Local nAntDeb	:= 0				// Saldo Anterior Devedor
Local nAntCrd	:= 0				// Saldo Anterior Credor
Local nSaldoAnt	:= 0				// Saldo Anterior (com sinal)
Local nSaldoAtu	:= 0				// Saldo Atual (com sinal)
Local bCondicao	:= {||.F.}
Local bCondLP	:= {||.F.}
Local cChaveLP	:= ""
Local aSldLP	:= {0,0}

cTpSald		:= Iif(Empty(cTpSald),"1",cTpSald)                   
dDataLp		:= Iif(dDataLP==Nil,CTOD("  /  /  "),dDataLP)              
cRotina		:= Iif(cRotina==Nil,"",cRotina)
lImpAntLP	:= Iif(lImpAntLP==Nil,.F.,lImpAntLP)
cConta		:= Left(AllTrim(cConta) + Space(Len(CT7->CT7_CONTA)), Len(CT7->CT7_CONTA))

dbSelectArea("CT7")
dbSetOrder(2)
If cFilEsp == Nil
	MsSeek(xFilial()+cConta+cMoeda+cTpSald+Dtos(dData),.T.)
	bCondicao	:= { || (CT7->CT7_FILIAL == xFilial() .And.;
					CT7->CT7_CONTA == cConta .And. CT7->CT7_MOEDA == cMoeda .And.;
					CT7->CT7_TPSALD == cTpSald .And. CT7->CT7_DATA  <= dData) }
	cChaveLP	:=(xFilial()+"Z"+cConta+cMoeda+cTpSald)						
	bCondLP  	:= { || (CT7->CT7_FILIAL == xFilial() .And.;
					CT7->CT7_CONTA == cConta .And. CT7->CT7_MOEDA == cMoeda .And.;
					CT7->CT7_TPSALD == cTpSald .And. CT7->CT7_LP == "Z" .And.;
					dDataLp <= dData) }
Else
	MsSeek(cFilEsp+cConta+cMoeda+cTpSald+Dtos(dData),.T.)
	bCondicao	:= { || (CT7->CT7_FILIAL == cFilEsp .And.;
					CT7->CT7_CONTA == cConta .And. CT7->CT7_MOEDA == cMoeda .And.;
					CT7->CT7_TPSALD == cTpSald .And. CT7->CT7_DATA  <= dData) }
	cChaveLP	:=(cFilEsp+"Z"+cConta+cMoeda+cTpSald)						
	bCondLP  	:= { || (CT7->CT7_FILIAL == cFilEsp .And.;
					CT7->CT7_CONTA == cConta .And. CT7->CT7_MOEDA == cMoeda .And.;
					CT7->CT7_TPSALD == cTpSald .And.  CT7->CT7_LP == "Z" .And.;
					dDataLP <= dData) }	
EndIf

If ! Eval(bCondicao)
	dbSkip(-1)
	lNaoAchei := .T.
Else	//Verificar se existe algum registro de zeramento na mesma data 
	If cRotina$"CTBR400/CTBXFUN"				//// NO RAZAO O SALDO ANTERIOR NAO DEVE CONSIDERAR OS LANCAMENTOS DE APURACAO
		nAntCrd := CT7->CT7_ANTCRD
		nAntDeb := CT7->CT7_ANTDEB
	Endif
	dbSkip()
	If !Eval(bCondicao) //Se nao existir registro na mesma data, volto para o registro anterior. 
		dbSkip(-1)
	EndIf
EndIf

If Eval(bCondicao)
	// Movimentacoes na data
	If CT7->CT7_DATA == dData
		nDebito	:= CT7->CT7_DEBITO
		nCredito	:= CT7->CT7_CREDITO
	Endif	
	nAtuDeb	 	:= CT7->CT7_ATUDEB
	nAtuCrd  	:= CT7->CT7_ATUCRD
	If lNaoAchei
		// Neste caso, como a data nao foi encontrada, considera-se como saldo anterior
		// o saldo atual do registro anterior! -> dbskip(-1)
		nAntDeb  := CT7->CT7_ATUDEB
		nAntCrd  := CT7->CT7_ATUCRD
	Else		
		If !cRotina$"CTBR400/CTBXFUN"			/// NO RAZAO O SALDO ANTERIOR NAO DEVE CONSIDERAR OS LANCAMENTOS DE APURACAO
			nAntDeb  := CT7->CT7_ANTDEB
			nAntCrd  := CT7->CT7_ANTCRD
		Endif
	Endif

	If cRotina = "CTBA210"
		//Se foi chamado pela rotina de apuracao de lucros/perdas,existe um registro
		//na data solcitada e o saldo nao eh o do proprio zeramento, considero como 
		//saldo anterior, o saldo atual antes do zeramento. 
		If CT7->CT7_LP	<> 'Z'
			nAntDeb  := CT7->CT7_ATUDEB                  		
			nAntCrd  := CT7->CT7_ATUCRD		
		Endif
	Endif

	nSaldoAtu:= nAtuCrd - nAtuDeb
	nSaldoAnt:= nAntCrd - nAntDeb
EndIf

//Se considera saldo anterior a apurcao de lucros/perdas
If lImpAntLP
	dbSelectArea("CT7")
	dbSetOrder(5)
	If MsSeek(cChaveLP)				
		aSldLP	:= CtbSldLP("CT7",dDataLP,bCondLP,dData)		
		nAtuDeb	-= aSldLP[1]
		nAtuCrd	-= aSldLP[2]		
		nSaldoAtu := nAtuCrd - nAtuDeb
//		If lNaoAchei
			nAntDeb	-= aSldLP[1]
			nAntCrd -= aSldLP[2]    
			nSaldoAnt	:= nAntCrd - nAntDeb
//		EndIf
	EndIf
EndIf

CT7->(RestArea(aSaveArea))
RestArea(aSaveAnt)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//      [1]       [2]     [3]      [4]     [5]     [6]       [7]     [8]
Return {nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³SaldoCT3  ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Saldo do Centro de custo                                   			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SaldoCT3(cConta,cCusto,dData,cMoeda,cTpSald)               			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³{nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                    		    ³±±
±±³          ³ ExpC2 = Centro de Custo                                   		    ³±±
±±³          ³ ExpD1 = Data                                              		    ³±±
±±³          ³ ExpC3 = Moeda                                             		    ³±±
±±³          ³ ExpC4 = Tipo de Saldo                                     		    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/                                                                       
Function SaldoCT3(cConta,cCusto,dData,cMoeda,cTpSald,cRotina,lImpAntLP,dDataLP)

Local aSaveArea	:= CT3->(GetArea())
Local aSaveAnt	:= GetArea()
Local lNaoAchei	:= .F.
Local nDebito	:= 0					// Valor Debito na Data
Local nCredito 	:= 0					// Valor Credito na Data
Local nAtuDeb  	:= 0					// Saldo Atual Devedor
Local nAtuCrd	:= 0					// Saldo Atual Credor
Local nAntDeb	:= 0					// Saldo Anterior Devedor
Local nAntCrd	:= 0					// Saldo Anterior Credor
Local nSaldoAnt	:= 0					// Saldo Anterior (com sinal)
Local nSaldoAtu	:= 0					// Saldo Atual (com sinal)
Local bCondicao	:= { || CT3->CT3_FILIAL==xFilial("CT3") .And. CT3->CT3_CUSTO == cCusto .And.;
						CT3->CT3_CONTA == cConta .And. CT3->CT3_MOEDA == cMoeda .And.;
						CT3->CT3_TPSALD == cTpSald .and. CT3->CT3_DATA <= dData }
Local bCondLP	:= {|| CT3->CT3_FILIAL==xFilial("CT3") .And. CT3->CT3_CUSTO == cCusto .And.;
						CT3->CT3_CONTA == cConta .And. CT3->CT3_MOEDA == cMoeda .And.;
						CT3->CT3_TPSALD == cTpSald .and. CT3->CT3_LP == "Z" .And.;
						dDataLP <= dData }
Local cChaveLP	:=(xFilial("CT3")+"Z"+cConta+cCusto+cMoeda+cTpSald)						
Local aSldLP	:= {0,0}

cTpSald		:= Iif(Empty(cTpSald),"1",cTpSald)
dDataLp		:= Iif(dDataLP==Nil,CTOD("  /  /  "),dDataLP)              
cRotina		:= Iif(cRotina==Nil,"",cRotina)
lImpAntLP	:= Iif(lImpAntLP==Nil,.F.,lImpAntLP)
cConta		:= Left(AllTrim(cConta) + Space(Len(CT3->CT3_CONTA)), Len(CT3->CT3_CONTA))
cCusto		:= Left(AllTrim(cCusto) + Space(Len(CT3->CT3_CUSTO)), Len(CT3->CT3_CUSTO))

// Saldo composto pela Conta + C.Custo
If !Empty(cConta)
	dbSelectArea("CT3")
	dbSetOrder(2)
	MsSeek(xFilial()+cConta+cCusto+cMoeda+cTpSald+DTOS(dData),.T.)
	If ! Eval(bCondicao)
		DbSkip(-1)
		lNaoAchei := .T.
	Else	//Verificar se existe algum registro de zeramento na mesma data 
		dbSkip()
		If !Eval(bCondicao) //Se nao existir registro na mesma data, volto para o registro anterior. 
			dbSkip(-1)
		EndIf		
	Endif
	If Eval(bCondicao)
		// Movimentacoes na data
		If CT3->CT3_DATA == dData
			nDebito	:= CT3->CT3_DEBITO
			nCredito	:= CT3->CT3_CREDITO
		Endif	
		nAtuDeb	:= CT3->CT3_ATUDEB
		nAtuCrd  := CT3->CT3_ATUCRD
		If lNaoAchei
			// Neste caso, como a data nao foi encontrada, considera-se como saldo anterior
			// o saldo atual do registro anterior! -> dbskip(-1)
			nAntDeb  := CT3->CT3_ATUDEB
			nAntCrd  := CT3->CT3_ATUCRD
		Else		
			nAntDeb  := CT3->CT3_ANTDEB
			nAntCrd  := CT3->CT3_ANTCRD
		Endif    
		
		If cRotina = "CTBA210"
			//Se foi chamado pela rotina de apuracao de lucros/perdas,existe um registro
			//na data solcitada e o saldo nao eh o do proprio zeramento, considero como 
			//saldo anterior, o saldo atual antes do zeramento. 
			If CT3->CT3_LP	<> 'Z'
				nAntDeb  := CT3->CT3_ATUDEB
				nAntCrd  := CT3->CT3_ATUCRD
			Endif
		Endif
		
		nSaldoAtu:= nAtuCrd - nAtuDeb
		nSaldoAnt:= nAntCrd - nAntDeb
	EndIf	
	//Se considera saldo anterior a apuracao de lucros/perdas
	If lImpAntLP
		dbSelectArea("CT3")
		dbSetOrder(8)
		If MsSeek(cChaveLP)				
			aSldLP	:= CtbSldLP("CT3",dDataLP,bCondLP,dData)		
			nAtuDeb	-= aSldLP[1]
			nAtuCrd	-= aSldLP[2]		
			nSaldoAtu := nAtuCrd - nAtuDeb
//			If lNaoAchei
				nAntDeb	-= aSldLP[1]
				nAntCrd -= aSldLP[2]    
				nSaldoAnt	:= nAntCrd - nAntDeb
//			EndIf
		EndIf
	EndIf	
Else
	nDebito		:= 0
	nCredito	:= 0
	nAtuDeb 	:= 0
	nAtuCrd		:= 0
	nAntDeb		:= 0
	nAntCrd		:= 0
	nSaldoAnt	:= 0
	nSaldoAtu	:= 0
EndIf	
Ct3->(RestArea(aSaveArea))
RestArea(aSaveAnt)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//      [1]       [2]     [3]      [4]     [5]     [6]       [7]     [8]
Return {nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³SaldoCT4  ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Saldo do Item Contabil                                     			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SaldoCT4(cConta,cCusto,cItem,dData,cMoeda,cTpSald)         			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³{nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                    		    ³±±
±±³          ³ ExpC2 = Centro de Custo                                   		    ³±±
±±³          ³ ExpC3 = Item Contabil                                     		    ³±±
±±³          ³ ExpD1 = Data                                              		    ³±±
±±³          ³ ExpC4 = Moeda                                             		    ³±±
±±³          ³ ExpC5 = Tipo de Saldo                                     		    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/      
Function SaldoCT4(cConta,cCusto,cItem,dData,cMoeda,cTpSald,cRotina,lImpAntLP,dDataLP)

Local aSaveArea	:= CT4->(GetArea())
Local aSaveAnt	:= GetArea()
Local lNaoAchei	:= .F.
Local nDebito	:= 0				// Valor Debito na Data
Local nCredito	:= 0				// Valor Credito na Data
Local nAtuDeb	:= 0				// Saldo Atual Devedor
Local nAtuCrd	:= 0				// Saldo Atual Credor
Local nAntDeb	:= 0				// Saldo Anterior Devedor
Local nAntCrd	:= 0				// Saldo Anterior Credor
Local nSaldoAnt	:= 0				// Saldo Anterior (com sinal)
Local nSaldoAtu	:= 0				// Saldo Atual (com sinal)
Local bCondicao	:= { || CT4->CT4_FILIAL == xFilial("CT4") .And.;
						CT4->CT4_ITEM == cItem .And.;
						CT4->CT4_CUSTO == cCusto .And.;
						CT4->CT4_CONTA == cConta .And.;
						CT4->CT4_MOEDA == cMoeda .And.;
						CT4->CT4_TPSALD == cTpSald .And. CT4->CT4_DATA <= dData }
Local bCondLP	:= {|| CT4->CT4_FILIAL==xFilial("CT4") .And. CT4->CT4_ITEM == cItem .And. CT4->CT4_CUSTO == cCusto .And.;
						CT4->CT4_CONTA == cConta .And. CT4->CT4_MOEDA == cMoeda .And.;
						CT4->CT4_TPSALD == cTpSald .and. CT4->CT4_LP == "Z" .And.;
						dDataLP <= dData }
Local cChaveLP	:=(xFilial("CT4")+"Z"+cConta+cCusto+cItem+cMoeda+cTpSald)						
Local aSldLP	:= {0,0}

cTpSald 	:= Iif(Empty(cTpSald),"1",cTpSald)                  
dDataLp		:= Iif(dDataLP==Nil,CTOD("  /  /  "),dDataLP)              
cCusto		:= Iif(Empty(cCusto),Space(Len(CT4->CT4_CUSTO)),cCusto)
cRotina		:= Iif(cRotina==Nil,"",cRotina)
lImpAntLP	:= Iif(lImpAntLP==Nil,.F.,lImpAntLP)
cConta		:= Left(AllTrim(cConta) + Space(Len(CT4->CT4_CONTA)), Len(CT4->CT4_CONTA))
cCusto		:= Left(AllTrim(cCusto) + Space(Len(CT4->CT4_CUSTO)), Len(CT4->CT4_CUSTO))
cItem 		:= Left(AllTrim(cItem) + Space(Len(CT4->CT4_ITEM)), Len(CT4->CT4_ITEM))

// Saldo composto por Conta + C.Custo + Item
If !Empty(cConta) .Or. !Empty(cCusto)
	dbSelectArea("CT4")
	dbSetOrder(2)
	MsSeek(xFilial()+cConta+cCusto+cItem+cMoeda+cTpSald+DTOS(dData),.T.)
	If ! Eval(bCondicao)
		dbSkip(-1)
		lNaoAchei := .T.
	Else	//Verificar se existe algum registro de zeramento na mesma data 
		dbSkip()
		If !Eval(bCondicao) //Se nao existir registro na mesma data, volto para o registro anterior. 
			dbSkip(-1)
		EndIf		
	EndIf

	If Eval(bCondicao)
		// Movimentacoes na data
		If CT4->CT4_DATA == dData
			nDebito	:= CT4->CT4_DEBITO
			nCredito	:= CT4->CT4_CREDITO
		Endif	
		nAtuDeb	:= CT4->CT4_ATUDEB
		nAtuCrd  := CT4->CT4_ATUCRD
		If lNaoAchei
			// Neste caso, como a data nao foi encontrada, considera-se como saldo anterior
			// o saldo atual do registro anterior! -> dbskip(-1)
			nAntDeb  := CT4->CT4_ATUDEB
			nAntCrd  := CT4->CT4_ATUCRD
		Else		
			nAntDeb  := CT4->CT4_ANTDEB
			nAntCrd  := CT4->CT4_ANTCRD
		Endif

		If cRotina = "CTBA210"
			//Se foi chamado pela rotina de apuracao de lucros/perdas,existe um registro
			//na data solcitada e o saldo nao eh o do proprio zeramento, considero como 
			//saldo anterior, o saldo atual antes do zeramento. 
			If CT4->CT4_LP	<> 'Z'
				nAntDeb  := CT4->CT4_ATUDEB                  		
				nAntCrd  := CT4->CT4_ATUCRD		
			Endif
		Endif
		
		nSaldoAtu:= nAtuCrd - nAtuDeb
		nSaldoAnt:= nAntCrd - nAntDeb
	EndIf
	//Se considera saldo anterior a apuracao de lucros/perdas
	If lImpAntLP
		dbSelectArea("CT4")
		dbSetOrder(6)
		If MsSeek(cChaveLP)				
			aSldLP	:= CtbSldLP("CT4",dDataLP,bCondLP,dData)		
			nAtuDeb	-= aSldLP[1]
			nAtuCrd	-= aSldLP[2]		
			nSaldoAtu := nAtuCrd - nAtuDeb
//			If lNaoAchei
				nAntDeb	-= aSldLP[1]
				nAntCrd -= aSldLP[2]    
				nSaldoAnt	:= nAntCrd - nAntDeb
//			EndIf
		EndIf
	EndIf		
	
// Saldo Somente do Item
Else               
	nDebito		:= 0
	nCredito	:= 0
	nAtuDeb		:= 0
	nAtuCrd		:= 0
	nAntDeb		:= 0
	nAntCrd		:= 0
	nSaldoAnt	:= 0
	nSaldoAtu	:= 0
EndIf

CT4->(RestArea(aSaveArea))
RestArea(aSaveAnt)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//      [1]       [2]     [3]      [4]     [5]     [6]       [7]     [8]
Return {nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³SaldoCTi  ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Saldo da Classe de Valor                                   			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SaldoCTI(cConta,cCusto,cItem,cClvl,dData,cMoeda,cTpSald)      		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³{nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Contabil                                    		    ³±±
±±³          ³ ExpC2 = Centro de Custo                                   		    ³±±
±±³          ³ ExpC3 = Item Contabil                                     		    ³±±
±±³          ³ ExpC4 = Item Contabil                                     		    ³±±
±±³          ³ ExpD1 = Data                                              		    ³±±
±±³          ³ ExpC5 = Moeda                                             		    ³±±
±±³          ³ ExpC6 = Tipo de Saldo                                     		    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SaldoCTI(cConta,cCusto,cItem,cClasseVlr,dData,cMoeda,cTpSald,cRotina,lImpAntLP,dDataLP)

Local aSaveArea	:= CTI->(GetArea())
Local aSaveAnt	:= GetArea()
Local lNaoAchei	:= .F.
Local nDebito	:= 0					// Valor Debito na Data
Local nCredito 	:= 0					// Valor Credito na Data
Local nAtuDeb  	:= 0					// Saldo Atual Devedor
Local nAtuCrd	:= 0					// Saldo Atual Credor
Local nAntDeb	:= 0					// Saldo Anterior Devedor
Local nAntCrd	:= 0					// Saldo Anterior Credor
Local nSaldoAnt	:= 0					// Saldo Anterior (com sinal)
Local nSaldoAtu	:= 0					// Saldo Atual (com sinal)
Local bCondicao	:= { || CTI->CTI_FILIAL == xFilial("CTI") .And.;
						CTI->CTI_CLVL == cClasseVlr .And.;
						CTI->CTI_ITEM == cItem .And.;
						CTI->CTI_CUSTO == cCusto .And.;
						CTI->CTI_CONTA == cConta .And.;
						CTI->CTI_MOEDA == cMoeda .And.;
						CTI->CTI_TPSALD == cTpSald .And. CTI->CTI_DATA <= dData }
Local bCondLP	:= {|| CTI->CTI_FILIAL==xFilial("CTI") .And. CTI->CTI_CLVL== cClasseVlr .And. ;
						CTI->CTI_ITEM == cItem .And. ;
						CTI->CTI_CUSTO == cCusto .And.;
						CTI->CTI_CONTA == cConta .And. CTI->CTI_MOEDA == cMoeda .And.;
						CTI->CTI_TPSALD == cTpSald .and. CTI->CTI_LP == "Z" .And.;
						dDataLP <= dData }
Local cChaveLP	:=(xFilial("CTI")+"Z"+cConta+cCusto+cItem+cClasseVlr+cMoeda+cTpSald)						
Local aSldLP	:= {0,0}

cTpSald 	:= Iif(Empty(cTpSald),"1",cTpSald)
dDataLp		:= Iif(dDataLP==Nil,CTOD("  /  /  "),dDataLP)              
cRotina		:= Iif(cRotina==Nil,"",cRotina)
lImpAntLP	:= Iif(lImpAntLP==Nil,.F.,lImpAntLP)
cConta		:= Left(AllTrim(cConta) + Space(Len(CTI->CTI_CONTA)), Len(CTI->CTI_CONTA))
cCusto		:= Left(AllTrim(cCusto) + Space(Len(CTI->CTI_CUSTO)), Len(CTI->CTI_CUSTO))
cItem 		:= Left(AllTrim(cItem) + Space(Len(CTI->CTI_ITEM)), Len(CTI->CTI_ITEM))
cClasseVlr	:= Left(AllTrim(cClasseVlr) + Space(Len(CTI->CTI_CLVL)), Len(CTI->CTI_CLVL))

// Saldo composto Conta + C Custo + Item + Classe Valor
If !Empty(cConta) .Or. !Empty(cCusto) .Or. !Empty(cItem)
	dbSelectArea("CTI")
	dbSetOrder(2)
	MsSeek(xFilial()+cConta+cCusto+cItem+cClasseVlr+cMoeda+cTpSald+DTOS(dData),.T.)
	If ! Eval(bCondicao)
		dbSkip(-1)
		lNaoAchei := .T.
	Else	//Verificar se existe algum registro de zeramento na mesma data 
		dbSkip()
		If !Eval(bCondicao) //Se nao existir registro na mesma data, volto para o registro anterior. 
			dbSkip(-1)
		EndIf		
	EndIf
	
	If Eval(bCondicao)
		// Movimentacoes na data
		If CTI->CTI_DATA == dData
			nDebito		:= CTI->CTI_DEBITO
			nCredito	:= CTI->CTI_CREDITO
		Endif	
		nAtuDeb	:= CTI->CTI_ATUDEB
		nAtuCrd  := CTI->CTI_ATUCRD
		If lNaoAchei
			// Neste caso, como a data nao foi encontrada, considera-se como saldo anterior
			// o saldo atual do registro anterior! -> dbskip(-1)
			nAntDeb  := CTI->CTI_ATUDEB
			nAntCrd  := CTI->CTI_ATUCRD
		Else		
			nAntDeb  := CTI->CTI_ANTDEB
			nAntCrd  := CTI->CTI_ANTCRD
		Endif

		If cRotina = "CTBA210"
			//Se foi chamado pela rotina de apuracao de lucros/perdas,existe um registro
			//na data solcitada e o saldo nao eh o do proprio zeramento, considero como 
			//saldo anterior, o saldo atual antes do zeramento. 
			If CTI->CTI_LP	<> 'Z'
				nAntDeb  := CTI->CTI_ATUDEB                  		
				nAntCrd  := CTI->CTI_ATUCRD		
			Endif
		Endif
	EndIf
	
	nSaldoAtu:= nAtuCrd - nAtuDeb
	nSaldoAnt:= nAntCrd - nAntDeb

	
	//Se considera saldo anterior a apuracao de lucros/perdas
	If lImpAntLP
		dbSelectArea("CTI")
		dbSetOrder(6)
		If MsSeek(cChaveLP)				
			aSldLP	:= CtbSldLP("CTI",dDataLP,bCondLP,dData)		
			nAtuDeb	-= aSldLP[1]
			nAtuCrd	-= aSldLP[2]		
			nSaldoAtu := nAtuCrd - nAtuDeb
//			If lNaoAchei
				nAntDeb	-= aSldLP[1]
				nAntCrd -= aSldLP[2]    
				nSaldoAnt	:= nAntCrd - nAntDeb
//			EndIf
		EndIf
	EndIf		
Else
	nDebito		:= 0
	nCredito 	:= 0
	nAtuDeb  	:= 0
	nAtuCrd		:= 0
	nAntDeb		:= 0
	nAntCrd		:= 0
	nSaldoAnt	:= 0
	nSaldoAtu	:= 0
EndIf

RestArea(aSaveAnt)
CTI->(RestArea(aSaveArea))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//      [1]       [2]     [3]      [4]     [5]     [6]       [7]     [8]
Return {nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³SaldoCT6  ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Saldo de Total do Lote                                     			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SaldoCT6(cLote,cSubLote,dData,cMoeda,cTpSald) 			     		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³{nSaldoAtu,nDebito,nCredito)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Lote                                              		    ³±±
±±³          ³ ExpC2 = SubLote                                           		    ³±±
±±³          ³ ExpD1 = Data                                              		    ³±±
±±³          ³ ExpC3 = Moeda                                             		    ³±±
±±³          ³ ExpC4 = Tipo de Saldo                                     		    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SaldoCT6(cLote,cSubLote,dData,cMoeda,cTpSald)

Local aSaveArea	:= CT6->(GetArea())
Local aSaveAnt	:= GetArea()

Local nDebito	:= 0					// Valor Debito na Data
Local nCredito 	:= 0					// Valor Credito na Data
Local nSaldoAtu	:= 0					// Saldo Atual (com sinal)

dbSelectArea("CT6")
dbSetOrder(2)
MsSeek(xFilial()+cLote+cSubLote+cMoeda+cTpSald+DTOS(dData),.T.)
If !(FOUND())
	dbSkip(-1)
Endif
	
If CT6->CT6_FILIAL == xFilial() 	.And. CT6->CT6_LOTE == cLote		.And.;
   CT6->CT6_SBLOTE == cSubLote 	.And. CT6->CT6_MOEDA == cMoeda 	.And.;
   CT6->CT6_TPSALD == cTpSald 		.And. CT6->CT6_DATA  <= dData
	// Movimentacoes na data
	If CT6->CT6_DATA == dData
		nDebito		:= CT6->CT6_DEBITO
		nCredito	:= CT6->CT6_CREDITO
	Endif	
EndIf
nSaldoAtu := nCredito - nDebito
CT6->(RestArea(aSaveAREA))
RestArea(aSaveAnt)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//      [1]       [2]     [3]      [4]     [5]     [6]       [7]     [8]
Return {nSaldoAtu,nDebito,nCredito}

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³SaldoCTC  ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Saldo de Total do Documento                                			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SaldoCT6(cLote,cSubLote,cDoc,dData,cMoeda,cTpSald) 		    		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³{nSaldoAtu,nDebito,nCredito)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Lote                                              		    ³±±
±±³          ³ ExpC2 = SubLote                                           		    ³±±
±±³          ³ ExpC3 = Documento                                         		    ³±±
±±³          ³ ExpD1 = Data                                              		    ³±±
±±³          ³ ExpC4 = Moeda                                             		    ³±±
±±³          ³ ExpC5 = Tipo de Saldo                                     		    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SaldoCTC(cLote,cSubLote,cDoc,dData,cMoeda,cTpSald)

Local aSaveArea	:= CTC->(GetArea())
Local aSaveAnt	:= GetArea()
Local nDebito	:= 0					// Valor Debito na Data
Local nCredito 	:= 0					// Valor Credito na Data
Local nSaldoAtu	:= 0					// Saldo Atual (com sinal)

dbSelectArea("CTC")
dbSetOrder(2)
MsSeek(xFilial()+cLote+cSubLote+cDoc+cMoeda+cTpSald+DTOS(dData),.T.)
If (!FOUND())
	dbSkip(-1)
Endif	
If CTC->CTC_FILIAL == xFilial() 	.And. CTC->CTC_LOTE == cLote 		.And.;
   CTC->CTC_SBLOTE == cSubLote 	.And. CTC->CTC_DOC == cDoc 		.And.;
   CTC->CTC_MOEDA == cMoeda 		.And. CTC->CTC_TPSALD == cTpSald 	.And.;
   CTC->CTC_DATA <= dData
	// Movimentacoes na data
	If CTC->CTC_DATA == dData
		nDebito	:= CTC->CTC_DEBITO
		nCredito	:= CTC->CTC_CREDITO
	Endif	
EndIf

nSaldoAtu := nCredito - nDebito
CTC->(RestArea(aSaveArea))
RestArea(aSaveAnt)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//      [1]       [2]     [3]      [4]     [5]     [6]       [7]     [8]
Return {nSaldoAtu,nDebito,nCredito}

****************************************************************
*			VALIDACOES DA DATA
*			COMUM A CTBA105 E CTBA050
****************************************************************
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbDtComp ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Verificacao da Data e Moeda                                 			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbDtComp(nOpc,dData,cMoeda)                        		    		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T./.F.                                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Numero da opcao                                   		    ³±±
±±³          ³ ExpD1 = Data                                              		    ³±±
±±³          ³ ExpC1 = Moeda                                             		    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbDtComp(nOpc,dData,cMoeda,lMessage)

Local lRet 		:= nOpc = 2
Local nErro		:= 0
Local aSaveArea:= GetArea()
Default lMessage := .T.

If nOpc <> 2			// Inclusão / Alteração / Exclusão
	dbSelectArea("CTE")
	dbSetOrder(1)
	MsSeek(xFilial()+cMoeda)
	While !Eof() .And. CTE->CTE_FILIAL == xFilial() .And. CTE->CTE_MOEDA == cMoeda
		lRet 	:= .T.
		cCalend := CTE->CTE_CALEND
		dbSelectArea("CTG")
		dbSetOrder(3)
		MsSeek(xFilial() + cCalend + DTOS(dData),.T.)
		If !Eof()
			IF	DTOS(dData) <= DTOS(CTG->CTG_DTFIM) .And.;
				DTOS(dData) >= DTOS(CTG->CTG_DTINI)
				If CTG->CTG_STATUS == "1"          
					nErro := 0
					Exit
				Else 
					nErro := 1	
					Exit
				EndIf	
			Else	
				nErro := 2
			EndIF
		Else
			lRet := .F.
		EndIf
		If ! lRet
			Exit
		Endif
		dbSelectArea("CTE")
		dbSkip()
	EndDo		
	If ! lRet .And. nErro = 0 .And. lMessage
		// Não há nenhuma calendário montado
		Help("  ",1,"CTGNOCAD")
	Endif
EndIf

If nErro == 1
	If lMessage
		Help(" ",1,"CTGDTCOMP")
	Endif
	lRet := .F.
ElseIf nErro == 2
	If lMessage
		Help("  ",1,"CTGDTOUT")
	Endif
	lRet := .F.
EndIf	

RestArea(aSaveArea)

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³EntidadeCTB³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Imprime a Entidade Contabil                                 			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³EntidadeCTB(cEntidade,nLinha,nColuna,nTam,lPosiciona,cMascara,         ³±±
±±³          ³cSeparador,cAlias,nOrder,lGraf,oPrint)CtbDtComp(nOpc,dData,cMoeda)     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.   .                                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo da Entidade               	                 		 ³±±
±±³          ³ ExpN1 = Numero da Linha                                   		     ³±±
±±³          ³ ExpN2 = Numero da Coluna                                  		     ³±±
±±³          ³ ExpN3 = Tamanho                                           		     ³±±
±±³          ³ ExpL1 = Se precisa procurar no arquivo de cadastro        		     ³±±
±±³          ³ ExpC2 = Codigo da Mascara                                 		     ³±±
±±³          ³ ExpC3 = separador                                         		     ³±±
±±³          ³ ExpC4 = Alias                                             		     ³±±
±±³          ³ ExpN4 = Ordem                                             		     ³±±
±±³          ³ ExpL2 = Se eh relatorio grafico										 ³±±
±±³          ³ ExpO1 = Objeto oPrint                                     		     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function EntidadeCTB(cEntidade,nLinha,nColuna,nTam,lPosiciona,cMascara,cSeparador,cAlias,nOrder,lGraf,oPrint)

Local aSaveArea := GetArea()
Local aTamEntid
Local cEntEmp	:= ""

If cAlias == "CT1"
	aTamEntid := TamSx3("CT1_CONTA")
	If lPosiciona
		dbSelectArea("CT1")
		dbSetOrder(nOrder)
		MsSeek(xFilial()+cEntidade)
	EndIf
ElseIf cAlias == "CTT"
	aTamEntid := TamSX3("CTT_CUSTO")
	If lPosiciona
		dbSelectArea("CTT")
		dbSetOrder(nOrder)
		MsSeek(xFilial()+cEntidade)
	EndIf
ElseIf cAlias == "CTD"
	aTamEntid := TamSX3("CTD_ITEM")
	If lPosiciona
		dbSelectArea("CT1")
		dbSetOrder(nOrder)
		MsSeek(xFilial()+cEntidade)
	EndIf
ElseIf cAlias == "CTH"
	aTamEntid := TamSX3("CTH_CLVL")
	If lPosiciona
		dbSelectArea("CTH")
		dbSetOrder(1)
		MsSeek(xFilial()+cEntidade)
	EndIf
EndIf		
	
If lGraf
	cEntEmp := MascaraCTB(cEntidade,cMascara,nTam,cSeparador,cAlias)
	oPrint:Say(nLinha,nColuna,cEntEmp,oFont08 )	
Else
	@ nLinha, nColuna pSay MascaraCTB(cEntidade,cMascara,nTam,cSeparador,cAlias)
Endif

RestArea(aSaveArea)

Return .t.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ValorCTB   ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Imprime O Valor                                             			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ValorCtb(nSaldo,nLin,nCol,nTamanho,nDecimais,lSinal,cPicture,;         ³±±
±±³          ³						cTipo,cConta,lGraf,oPrint)					  	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.   .                                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Valor                            	                 		 ³±±
±±³          ³ ExpN2 = Numero da Linha                                   		     ³±±
±±³          ³ ExpN3 = Numero da Coluna                                  		     ³±±
±±³          ³ ExpN4 = Tamanho                                           		     ³±±
±±³          ³ ExpN5 = Numero de Decimais											 ³±±
±±³          ³ ExpL1 = Se devera ser impresso com sinal ou nao.          		     ³±±
±±³          ³ ExpC1 = Picture                                           		     ³±±
±±³          ³ ExpC2 = Tipo                                              		     ³±±
±±³          ³ ExpC3 = Conta                                             		     ³±±
±±³          ³ ExpC4 = Se eh grafico ou nao                              		     ³±±
±±³          ³ ExpO1 = Objeto oPrint                                     		     ³±±
±±³          ³ ExpC4 = Tipo do sinal utilizado                           		     ³±±
±±³          ³ ExpC5 = Identificar [USADO em modo gerencial]             		     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValorCtb(	nSaldo,nLin,nCol,nTamanho,nDecimais,lSinal,cPicture,;
					cTipo,cConta,lGraf,oPrint,cTipoSinal, cIdentifi,lPrintZero)

Local aSaveArea	:= GetArea()
Local cImpSaldo := ""
Local lDifZero	:= .T.
Local lInformada:= .T.                      
Local cCharSinal:= ""

lPrintZero := Iif(lPrintZero==Nil,.T.,lPrintZero)

// Nao imprime o valor 0,00
If !lPrintZero 
	If (Int(nSaldo*100)/100) == 0
		lDifZero := .F.			// O saldo nao eh diferente de zero
	EndIf
EndIf		

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tipo D -> Default (D/C)												  ³
//³ Tipo S -> Imprime saldo com sinal									  ³
//³ Tipo P -> Imprime saldo entre parenteses (qdo. negativo)	  ³
//³ Tipo C -> So imprime "C" (o "D" nao e impresso)              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT cTipoSinal := GetMV("MV_TPVALOR")       // Assume valor default

cTipo 		:= Iif(cTipo == Nil, Space(1), cTipo)
nDecimais	:= Iif(nDecimais==Nil,GetMv("MV_CENT"),nDecimais)

dbSelectArea("CT1")
dbSetOrder(1)

If !Empty(cConta) .And. Empty(cTipo)
	If MsSeek(cFilial+cConta)
		cTipo := CT1->CT1_NORMAL
	Endif
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorna a picture. Caso nao exista espaco, retira os pontos  ³
//³ separadores de dezenas, centenas e milhares 					  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(cPicture)        
	If cTipoSinal $ "D/C"
		cPicture := TmContab(Abs(nSaldo),nTamanho,nDecimais)
	Else
		cPicture := TmContab(nSaldo,nTamanho,nDecimais)
	EndIf	
	lInformada  := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³* Alguns valores, apesar de  terem sinal devem ser impressos  ³
//³ sem sinal (lSinal). Ex: valores de colunas Debito e Credito  ³
//³* Se estiver com a opcao de lingua estrangeira (lEstrang) a   ³
//³ picture sera invertida para exibir valores: 999,999,999.99   ³
//³* O tipo de sinal "D" - default nao leva em consideracao a    ³
//³ a natureza da conta. Dessa forma valores negativos serao	  ³
//³ impressos sem sinal, e ao seu lado "D" (Devedor) e valores   ³
//³ positivos terao um "C" (Credito) impresso ao seu lado.       ³
//³* O tipo de Sinal "P" - Parenteses, imprimira valores de saldo³
//³  invertidos da condicao normal da conta entre parenteses.	  ³
//³* O tipo de Sinal "S" - Sinal, imprimira valores de saldo in- ³
//³  vertidos da condicao normal da conta com sinal - 			  ³
//³EXEMPLOS  -  EXEMPLOS  -  EXEMPLOS	-	EXEMPLOS  - EXEMPLOS   ³
//³Cond Normal 	Saldo 	Default      Sinal   Parenteses		  ³
//³	D			   -1000	   1000 D 		 1000		 1000			  	  ³
//³	D				 1000 	1000 C		-1000 	(1000)			  ³
//³	C				-1000 	1000 D		-1000 	(1000)			  ³
//³	C				 1000 	1000 C		 1000 	 1000 			  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

// So imprime valor se for diferente de zero!
If lDifZero
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Neste caso (Default), nao importa a natureza da conta! Saldos³
	//³ devedores serao impressos com "D" e credores com "C".        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	// Neste caso, nao importa a natureza da conta!!
	If cTipoSinal == "D" .Or. cTipoSinal == "C"         // D(Default) ou C(so Credito)
		If !lInformada
			cPicture := "@E " + cPicture
		Endif	         
		If lSinal
			If nSaldo < 0
				If lGraf                                     
					If cTipoSinal == "D"				
						If cIdentifi # Nil .And. cIdentifi $ "34"
							cCharSinal := Iif(cPaisLoc<>"MEX","D","C")
						Else
							cCharSinal := Iif(cPaisLoc<>"MEX","D","C")
						Endif
					EndIf
				Else	 
					// No Tipo C -> so sao impressos os "C´s"
					If cTipoSinal == "D"
						cCharSinal := Iif(cPaisLoc<>"MEX","D","C")
					EndIf	
				Endif
			ElseIf nSaldo > 0
				If lGraf                                                                
					If cIdentifi # Nil .And. cIdentifi $ "34"                                                           
						If cTipoSinal == "D"
							cCharSinal := Iif(cPaisLoc<>"MEX","D","C")
						EndIf
					Else
						cCharSinal := Iif(cPaisLoc<>"MEX","C","A")
					Endif
				Else
					cCharSinal := Iif(cPaisLoc<>"MEX","C","A")
				Endif
			EndIf
			cCharSinal := " "+cCharSinal			
		EndIf
		cImpSaldo := Transform(Abs(nSaldo),cPicture)+cCharSinal
		If lGraf                                                
			If cIdentifi # Nil .And. cIdentifi $ "34"
				oPrint:Say(nLin,nCol,cImpSaldo,oCouNew08S)
			Else
				oPrint:Say(nLin,nCol,cImpSaldo,oFont08)				
			Endif
		Else  
			@ nLin, nCol pSay cImpSaldo 
		Endif
		
	Else
		//Utiliza conceito de conta estourada e a conta eh redutora.
		If Select("cArqTmp") > 0 .And. cArqTmp->(FieldPos("ESTOUR")) <> 0 .And.  cArqTmp->ESTOUR == "1"
			If cTipo == "1" 								// Conta Devedora
				If cTipoSinal == "S"              			// Sinal
					If !lSinal
						nSaldo := Abs(nSaldo)
					EndIf
					If !lInformada
						cPicture := "@E " + cPicture
					EndIf 
					If lGraf
						cImpSaldo := Transform(nSaldo,cPicture)			
						If cIdentifi # Nil .And. cIdentifi $ "34"
							oPrint:Say(nLin,nCol,cImpSaldo,oCouNew08S)
						Else
							oPrint:Say(nLin,nCol,cImpSaldo,oFont08)
						Endif
					Else
						@ nLin, nCol PSAY nSaldo Picture cPicture
					Endif
				ElseIf (cTipoSinal) == "P"              	// Parenteses
					If !lSinal 
						nSaldo := Abs(nSaldo)
					EndIf

					If !lInformada         				
						cPicture := "@E( " + cPicture
					EndIf
					If lGraf
						cImpSaldo := Transform(nSaldo,cPicture)			
						If cIdentifi # Nil .And. cIdentifi $ "34"
							oPrint:Say(nLin,nCol,cImpSaldo,oCouNew08S)
						Else
							oPrint:Say(nLin,nCol,cImpSaldo,oFont08)
						Endif
					Else
						@ nLin, nCol pSay nSaldo Picture cPicture
					Endif
				EndIf
			Else
				If (cTipoSinal) == "S"                  	// Sinal
					If lSinal 
						nSaldo := nSaldo * (-1)
//					If !lSinal .And. cTipo == "2" 			// Conta Credora
					Else
						nSaldo := Abs(nSaldo)
					EndIf
					If lGraf
						cImpSaldo := Transform(nSaldo,cPicture)			
						If cIdentifi # Nil .And. cIdentifi $ "34"
							oPrint:Say(nLin,nCol,cImpSaldo,oCouNew08S)
						Else
							oPrint:Say(nLin,nCol,cImpSaldo,oFont08)
						Endif
					Else
						@ nLin, nCol PSAY nSaldo Picture cPicture
					Endif
				ElseIf (cTipoSinal) == "P"              // Parenteses
					If lSinal                  
						nSaldo := nSaldo * (-1)					
//					If !lSinal .And. cTipo == "2" 			// Conta Credora
					Else
						nSaldo := Abs(nSaldo)
					EndIf
					If !lInformada
						cPicture := "@E( " + cPicture
					EndIf    
					If lGraf
						cImpSaldo := Transform(nSaldo,cPicture)			// Debito
						If cIdentifi # Nil .And. cIdentifi $ "34"
							oPrint:Say(nLin,nCol,cImpSaldo,oCouNew08S)
						Else
							oPrint:Say(nLin,nCol,cImpSaldo,oFont08)
						Endif					
					Else
						@ nLin, nCol pSay nSaldo Picture cPicture
					Endif
				EndIf		
			EndIf		
	    Else	//Se nao utiliza conceito de conta estourada
			If cTipo == "1" 								// Conta Devedora
				If cTipoSinal == "S"              			// Sinal
					If lSinal
						nSaldo := nSaldo * (-1)
					Else
						nSaldo := Abs(nSaldo)
					EndIf
					If !lInformada
						cPicture := "@E " + cPicture
					EndIf 
					If lGraf
						cImpSaldo := Transform(nSaldo,cPicture)			
						If cIdentifi # Nil .And. cIdentifi $ "34"
							oPrint:Say(nLin,nCol,cImpSaldo,oCouNew08S)
						Else
							oPrint:Say(nLin,nCol,cImpSaldo,oFont08)
						Endif
					Else
						@ nLin, nCol PSAY nSaldo Picture cPicture
					Endif
				ElseIf (cTipoSinal) == "P"              	// Parenteses
					If lSinal 
						nSaldo := nSaldo * (-1) 		  		// a Picture so exibe parenteses para numeros negativos
					Else
						nSaldo := Abs(nSaldo)
					EndIf
        	
					If !lInformada         				
						cPicture := "@E( " + cPicture
					EndIf
					If lGraf
						cImpSaldo := Transform(nSaldo,cPicture)			
						If cIdentifi # Nil .And. cIdentifi $ "34"
							oPrint:Say(nLin,nCol,cImpSaldo,oCouNew08S)
						Else
							oPrint:Say(nLin,nCol,cImpSaldo,oFont08)
						Endif
					Else
						@ nLin, nCol pSay nSaldo Picture cPicture
					Endif
				EndIf
			Else
				If (cTipoSinal) == "S"                  	// Sinal
					If !lSinal .And. cTipo == "2" 			// Conta Credora
						nSaldo := Abs(nSaldo)
					EndIf
					If lGraf
						cImpSaldo := Transform(nSaldo,cPicture)			
						If cIdentifi # Nil .And. cIdentifi $ "34"
							oPrint:Say(nLin,nCol,cImpSaldo,oCouNew08S)
						Else
							oPrint:Say(nLin,nCol,cImpSaldo,oFont08)
						Endif
					Else
						@ nLin, nCol PSAY nSaldo Picture cPicture
					Endif
				ElseIf (cTipoSinal) == "P"              // Parenteses
					If !lSinal .And. cTipo == "2" 			// Conta Credora
						nSaldo := Abs(nSaldo)
					EndIf
					If !lInformada
						cPicture := "@E( " + cPicture
					EndIf    
					If lGraf
						cImpSaldo := Transform(nSaldo,cPicture)			// Debito
						If cIdentifi # Nil .And. cIdentifi $ "34"
							oPrint:Say(nLin,nCol,cImpSaldo,oCouNew08S)
						Else
							oPrint:Say(nLin,nCol,cImpSaldo,oFont08)
						Endif					
					Else
						@ nLin, nCol pSay nSaldo Picture cPicture
					Endif
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
RestArea(aSaveArea)

Return
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DecimalCTB ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Verifica o numero de decimais                               			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³DecimalCTB(aSetOfBook,cMoeda)										     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³nDecimais                                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array ref. aSetOfBook             	                 		 ³±±
±±³          ³ ExpC1 = Moeda                                             		     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function DecimalCTB(aSetOfBook,cMoeda)

Local aSaveArea := GetArea()
Local nDecimais := 0

//Se nao estiver usando configuracao de livros, considera o numero de casas decimais do cadastro
//de moedas
If Empty(aSetOfBook[1])
	dbSelectArea("CTO")
	dbSetOrder(1)
	MsSeek(xFilial()+cMoeda)
	If nDecimais <> CTO->CTO_DECIM
		nDecimais := CTO->CTO_DECIM
	EndIf
Else               
	//Se a picture nao estiver preenchida, considera o numero de casas decimais da configuracao de
	//livros. Se a picture estiver preenchida, ira considerar as casas decimais da picture. 	
	If Empty(aSetOfBook[4])
		nDecimais	:= aSetOfBook[3]
	EndIf		              
EndIf

RestArea(aSaveArea)

Return nDecimais

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbMoeda   ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Verifica a moeda                                            			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbMoeda(cMoeda)   	             								     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array contendo os dados da moeda                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Moeda                             	                 		 ³±±
±±³          ³ ExpN1 = Fator de divisao                  	                 		 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbMoeda(cMoeda, nDivisao)

Local aSaveArea := GetArea()
Local aCtbMoeda := {0,"","","","",0}
Local cString	:= ""

dbSelectArea("CTO")
dbSetOrder(1)

If nDivisao != Nil .And. nDivisao > 1
	If nDivisao == 100
		cString := STR0006			// "Centena"
	ElseIf nDivisao == 1000
		cString := STR0007 			// "Mil"
	ElseIf nDivisao == 1000000	
		cString := STR0008			// "Milhares"
	EndIf	
EndIf	
If MsSeek(xFilial()+cMoeda)
	aCtbMoeda := {	CTO->CTO_MOEDA,CTO->CTO_DESC,CTO->CTO_SIMB,CTO->CTO_BLOQ,CTO_DECIM,;
					cString	}
EndIf

aCtbMoeda[3] := AllTrim(aCtbMoeda[3]) + " " + cString

RestArea(aSaveArea)

Return aCtbMoeda

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbSetOf   ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna Array com o set of book                             			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbMoeda(cSetOfBook)	             								     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array contendo os dados do set Of book                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Set Of book             	                 		 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbSetOf(cSetOfBook)

Local aSaveArea := GetArea()
Local aSetOfBook:= {"","",0,"","","","","",1,""}

dbSelectArea("CTN")
cSetOfBook := Padr(cSetOfBook,Len(CTN->CTN_CODIGO))
dbSetOrder(1)
If MsSeek(xFilial()+cSetOfBook,.F.)
	// Codigo Set / Mascara Conta / Decimais / Picture Valores
	// Plano Gerencial / Mascara C Custo/ Mascara Item / Mascara CLVL
	aSetOfBook := {	CTN->CTN_CODIGO,CTN->CTN_MASC1,CTN->CTN_DECIM,CTN->CTN_PICTV,;
					CTN->CTN_PLAGER,CTN->CTN_MASC2,CTN->CTN_MASC3,CTN->CTN_MASC4,;
					1,AllTrim(CTN_DESC)}
EndIf

RestArea(aSaveArea)

Return aSetOfBook

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbPlGeren ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna Array com o set of book                             			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CTBPlGeren(oMeter,oText,oDlg,lEnd,dDataIni,dDataFim,cMoeda,aSetOfBook) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpO1 = Objeto oMeter                     	                 		 ³±±
±±³          ³ ExpO2 = Objeto oText                      	                 		 ³±±
±±³          ³ ExpO3 = Objeto oDlg                       	                 		 ³±±
±±³          ³ ExpL1 = Acao do CodeBlock                 	                 		 ³±±
±±³          ³ ExpD1 = Data Inicial                      	                 		 ³±±
±±³          ³ ExpD2 = Data Final                        	                 		 ³±±
±±³          ³ ExpC1 = Moeda                              	                 		 ³±±
±±³          ³ ExpA1 = Array Set Of Book                  	                 		 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbPlGeren(oMeter,oText,oDlg,lEnd,dDataIni,dDataFim,cMoeda,aSetOfBook,;
					cAlias,cIdent,lImpAntLP,dDataLP,lVlrZerado,cEntFil1,cEntFil2,aGeren,lImpSint)

Local aSaveArea := GetArea()
Local aSaldoAnt	
Local aSaldoAtu
Local aSaldoSEM
Local aSaldoPER

Local cConta
Local cCodNor
Local cNormal
Local cContaSup
Local cDesc
Local cPlanGer := aSetOfBook[5]
Local cZZZCT1	:= Repl("Z",Len(Criavar("CT1_CONTA")))
Local cZZZCTT	:= Repl("Z",Len(Criavar("CTT_CUSTO")))
Local cZZZCTD	:= Repl("Z",Len(Criavar("CTD_ITEM")))
Local cZZZCTH	:= Repl("Z",Len(Criavar("CTH_CLVL")))   
Local cContaIni	:= Space(Len(Criavar("CT1_CONTA")))
Local cContaFim	:= cZZZCT1
Local cCustoIni	:= Space(Len(Criavar("CTT_CUSTO")))
Local cCustoFim	:= cZZZCTT
Local cItemIni	:= Space(Len(Criavar("CTD_ITEM")))
Local cItemFim	:= cZZZCTD
Local cClvlIni	:= Space(Len(Criavar("CTH_CLVL")))
Local cClVlFim	:= cZZZCTH

Local cCtaFil1
Local cCtaFil2
Local cCCFil1
Local cCCFil2
Local cItemFil1
Local cItemFil2
Local cCLVLFil1
Local cCLVLFil2
Local lConta 	:= .F.
Local lCusto	:= .F.
Local lItem		:= .F.
Local lClasse	:= .F.

Local nReg
Local nFator	 := 1
Local nPos		:= 0	
Local nSaldoAnt := 0
Local nSaldoDeb := 0
Local nSaldoCrd := 0

Local nSaldoAtu := 0		// Saldo ate a data final
Local nSaldoSEM := 0		// Saldo ate a variavel dSemestre
Local nSaldoPER := 0		// Saldo ate a variavel dPeriodo0
Local nMOVIMPER	:= 0

Local nSaldoAntD:= 0
Local nSaldoAntC:= 0
Local nSaldoAtuD:= 0
Local nSaldoAtuC:= 0
Local lSemestre := FieldPos("SALDOSEM") > 0		// Saldo por semestre
Local lPeriodo0 := FieldPos("SALDOPER") > 0		// Saldo dois periodos anteriores

Local lComNivel := FieldPos("NIVEL") > 0		// Nivel hierarquico
Local lColuna	:= FieldPos("COLUNA") > 0
Local nNivel	:= 0
Local nContador	:= 0
Local cFilCTS	:= xFilial("CTS")
Local lMovCusto := CtbMovSaldo("CTT")
Local lMovItem	:= CtbMovSaldo("CTD")
Local lMovClass := CtbMovSaldo("CTH")
DEFAULT lImpSint	:= .T.

lTRegCts	:= Type("lTRegCts") # "U" .And. ValType(lTRegCts) = "L" .And. lTRegCts
cAlias		:= Iif(cAlias == Nil,"",cAlias)
cIdent		:= Iif(cIdent == Nil,"",cIdent)
lVlrZerado	:= Iif(lVlrZerado == Nil,.T.,lVlrZerado)

If aGeren != Nil
	cCtaFil1  :=	If(Ascii(aGeren[1])== 13,"",aGeren[1])
	cCtaFil2  :=	If(Ascii(aGeren[2])== 13,"",aGeren[2])
	cCCFil1   :=	If(Ascii(aGeren[3])== 13,"",aGeren[3])
	cCCFil2   :=	If(Ascii(aGeren[4])== 13,"",aGeren[4])
	cItemFil1 :=	If(Ascii(aGeren[5])== 13,"",aGeren[5])
	cItemFil2 :=	If(Ascii(aGeren[6])== 13,"",aGeren[6])
	cCLVLFil1 :=	If(Ascii(aGeren[7])== 13,"",aGeren[7])
	cCLVLFil2 :=	If(Ascii(aGeren[8])== 13,"",aGeren[8])
EndIf	
lCT1Fil := .F.
lCTTFil := .F.
lCTDFil	:= .F.
lCTHFil	:= .F.

// Filtragem da entidade compositora do Plano Gerencial (Centro de Custo da Getdados)		
If !Empty(cCtaFil1) .Or. !Empty(cCtaFil2)
	lCT1Fil := .T.
	If cCtaFil1 > cContaIni 
		cContaIni := cCtaFil1
	EndIf
	If cCtaFil2 < cContaFim	
		cContaFim := cCtaFil2
	EndIf	
EndIf	

// Filtragem da entidade compositora do Plano Gerencial (Centro de Custo da Getdados)		
If lMovCusto
	If !Empty(cCCFil1) .Or. !Empty(cCCFil2)
		lCTTFil := .T.
		If cCCFil1 > cCustoIni 
			cCustoIni := cCCFil1
		EndIf
		If cCCFil2 < cCustoFim	
			cCustoFim := cCcFil2
		EndIf	
	EndIf	
EndIf
/* Observacoes:
C.Custo do Plano Gerencial
001	002	003
			
C.Custo Informado no Filtro
000	001	002	003	004
			
O relatorio so podera imprimir: 001 002 003	*/

// Filtragem da entidade compositora do Plano Gerencial (Item Contabil da Getdados)
If lMovItem
	If !Empty(cItemFil1) .Or. !Empty(cItemFil2)
		lCTDFil := .T.
		If cItemFil1 > cItemIni 
			cItemIni := cItemFil1
		EndIf
		If cItemFil2 < cItemFim	
			cItemFim := cItemFil2
		EndIf	
	EndIf	
EndIf

// Filtragem da entidade compositora do Plano Gerencial (Classe de Valor da Getdados)
If lMovClass
	If !Empty(cCLVLFil1) .Or. !Empty(cCLVLFil2)
		lCTHFil := .T.
		If cCLVLFil1 > cClVlIni 
			cClVlIni := cClVlFil1
		EndIf
		If cCLVLFil2 < cClVlFim	
			cClVlFim := cClVlFil2
		EndIf	
	EndIf	
EndIf

dbSelectArea("CTS")
oMeter:nTotal := CTS->(RecCount())
dbSetOrder(1)

MsSeek(cFilCTS+cPlanGer,.T.)

While !Eof() .And. 	CTS->CTS_FILIAL == cFilCTS .And.;
					CTS->CTS_CODPLA == cPlanGer

	If CTS->CTS_CLASSE == "1"// .And. (! CTS->CTS_IDENT $ "3456")
		dbSkip()
		Loop
	EndIf

	//Efetua o filtro dos parametros considerando o plano gerencial.
	If !Empty(cEntFil1) .Or. !Empty(cEntFil2)
		If CTS->CTS_CONTAG < cEntFil1 .Or. CTS->CTS_CONTAG > cEntFil2
			dbSkip()
			Loop
		EndIf	
	EndIf	                                   
	// Recarrega variáveis
	lConta 	:= .F.
	lCusto	:= .F.
	lItem	:= .F.
	lClasse	:= .F.

	// Grava conta analitica
	cConta 	:= CTS->CTS_CONTAG
	cDesc	:= CTS->CTS_DESCCG
	cOrdem	:= CTS->CTS_ORDEM

	nSaldoAnt 	:= 0	// Zero as variaveis para acumular
	nSaldoDeb 	:= 0
	nSaldoCrd 	:= 0

	nSaldoAtu 	:= 0
	nSaldoSEM 	:= 0
	nSaldoPer	:= 0

	nSaldoAntD	:= 0
	nSaldoAntC	:= 0
	nSaldoAtuD	:= 0
	nSaldoAtuC	:= 0
	nMOVIMPER	:= 0
	dbSelectArea("CTS")
	dbSetOrder(1)

	While !Eof() .And. CTS->CTS_FILIAL == cFilCTS .And.;
						CTS->CTS_CODPLA == cPlanGer  .And. CTS->CTS_ORDEM	== cOrdem
		aSaldoAnt	:= { 0, 0, 0, 0, 0, 0, 0, 0 }
		aSaldoAtu	:= { 0, 0, 0, 0, 0, 0, 0, 0 }
		aSaldoSEM	:= { 0, 0, 0, 0, 0, 0, 0, 0 }
		aSaldoPER	:= { 0, 0, 0, 0, 0, 0, 0, 0 }

		lClasse := .F.
		lItem	:= .F.
		lCusto	:= .F.
		lConta	:= .F.

		If !lCTHFil
			If !Empty(CTS->CTS_CTHINI) .Or. !Empty(CTS->CTS_CTHFIM)		// Saldo a partir da classe
				cClVlIni	:= CTS->CTS_CTHINI
				cClVlFim	:= CTS->CTS_CTHFIM
				lClasse := .T.
			Else
				cCLVLIni	:= ""
				cCLVLFim	:= cZZZCTH
			EndIf
		Else
			lClasse := .T.
		Endif

		If !lCTDFil
			If !Empty(CTS->CTS_CTDINI) .Or. !Empty(CTS->CTS_CTDFIM)	// Saldo a partir do Item
				cItemIni	:= CTS->CTS_CTDINI
				cItemFim	:= CTS->CTS_CTDFIM			
				lItem := .T.
			Else
				cItemIni	:= ""
				cItemFim	:= cZZZCTD        		
			EndIf
		Else
			lItem	:= .T.
		Endif
		
		If !lCTTFil
			If !Empty(CTS->CTS_CTTINI) .Or. !Empty(CTS->CTS_CTTFIM)	// Saldo a partir do C.Custo
				cCustoIni	:= CTS->CTS_CTTINI
				cCustoFim	:= CTS->CTS_CTTFIM
				lCusto := .T.
			Else
				cCustoIni	:= ""
				cCustoFim	:= cZZZCTT        
			EndIf
		Else
			lCusto	:= .T.
		Endif

		If !lCT1Fil
			If !Empty(CTS->CTS_CT1INI) .Or. !Empty(CTS->CTS_CT1FIM)	// Saldo a partir da Conta
				cContaIni	:= CTS->CTS_CT1INI
				cContaFim	:= CTS->CTS_CT1FIM
				lConta := .T.
			Else
				cContaIni	:= ""
				cContaFim	:= cZZZCT1
			EndIf
		Else
			lConta	:= .T.		
		EndIf
		If lClasse .and. lMovClass
			aSaldoAnt := SaldTotCTI(cClVlIni,cClVlFim,cItemIni,;
									cItemFim,cCustoIni,cCustoFim,cContaIni,;
									cContaFim,dDataIni,cMoeda,CTS->CTS_TPSALD)
								
			aSaldoAtu := SaldTotCTI(cClVlIni,cClVlFim,cItemIni,;
									cItemFim,cCustoIni,cCustoFim,cContaIni,;
									cContaFim,dDataFim,cMoeda,CTS->CTS_TPSALD)
			If lSemestre
				aSaldoSem := SaldTotCTI(cClVlIni,cClVlFim,cItemIni,;
										cItemFim,cCustoIni,cCustoFim,cContaIni,;
										cContaFim,dSemestre,cMoeda,CTS->CTS_TPSALD)
			Endif
			If lPeriodo0
				aSaldoPer := SaldTotCTI(cClVlIni,cClVlFim,cItemIni,;
										cItemFim,cCustoIni,cCustoFim,cContaIni,;
										cContaFim,dPeriodo0,cMoeda,CTS->CTS_TPSALD)
			Endif
		ElseIf lItem .and. lMovItem		
			aSaldoAnt := SaldTotCT4(cItemIni,cItemFim,cCustoIni,;
									cCustoFim,cContaIni,cContaFim,;
									dDataIni,cMoeda,CTS->CTS_TPSALD)
								
			aSaldoAtu := SaldTotCT4(cItemIni,cItemFim,cCustoIni,;
									cCustoFim,cContaIni,cContaFim,;
									dDataFim,cMoeda,CTS->CTS_TPSALD)
			If lSemestre
				aSaldoSem := SaldTotCT4(cItemIni,cItemFim,cCustoIni,;
										cCustoFim,cContaIni,cContaFim,;
										dSemestre,cMoeda,CTS->CTS_TPSALD)
			Endif
			If lPeriodo0
				aSaldoPEr := SaldTotCT4(cItemIni,cItemFim,cCustoIni,;
										cCustoFim,cContaIni,cContaFim,;
										dPeriodo0,cMoeda,CTS->CTS_TPSALD)
			Endif
		ElseIf lCusto .and. lMovCusto
			aSaldoAnt := SaldTotCT3(cCustoIni,cCustoFim,cContaIni,;
									cContaFim,dDataIni,cMoeda,CTS->CTS_TPSALD)
			aSaldoAtu := SaldTotCT3(cCustoIni,cCustoFim,cContaIni,;
									cContaFim,dDataFim,cMoeda,CTS->CTS_TPSALD)
			If lSemestre
				aSaldoSem := SaldTotCT3(cCustoIni,cCustoFim,cContaIni,;
										cContaFim,dSemestre,cMoeda,CTS->CTS_TPSALD)
			Endif
			If lPeriodo0
				aSaldoPer := SaldTotCT3(cCustoIni,cCustoFim,cContaIni,;
										cContaFim,dPeriodo0,cMoeda,CTS->CTS_TPSALD)
			Endif
		ElseIf lConta
			aSaldoAnt := SaldTotCT7(cContaIni,cContaFim,dDataIni,cMoeda,CTS->CTS_TPSALD,lImpAntLP,dDataLP)
			aSaldoAtu := SaldTotCT7(cContaIni,cContaFim,dDataFim,cMoeda,CTS->CTS_TPSALD,lImpAntLP,dDataLP)
			If lSemestre
				aSaldoSem := SaldTotCT7(cContaIni,cContaFim,dSemestre,cMoeda,CTS->CTS_TPSALD,lImpAntLP,dDataLP)
			Endif
			If lPeriodo0
				aSaldoPer := SaldTotCT7(cContaIni,cContaFim,dPeriodo0,cMoeda,CTS->CTS_TPSALD,lImpAntLP,dDataLP)
			Endif
		EndIf		

		If aSetOfBook[9] > 1	// Divisao por fator
			nLSldAnt := Len(aSaldoAnt)
			nLSldAtu := Len(aSaldoAtu)
			nLSldSem := Len(aSaldoSem)
			nLSldPer := Len(aSaldoPer)
			For nPos := 1 To nLSldAnt
				aSaldoAnt[nPos] := Round(NoRound((aSaldoAnt[nPos]/aSetOfBook[9]),3),2)
			Next
			For nPos := 1 To nLSldAtu
				aSaldoAtu[nPos] := Round(NoRound((aSaldoAtu[nPos]/aSetOfBook[9]),3),2)
			Next
			If lSemestre
				For nPos := 1 To nLSldSem
					aSaldoSem[nPos] := Round(NoRound((aSaldoSem[nPos]/aSetOfBook[9]),3),2)
				Next
			Endif
			If lPeriodo0
				For nPos := 1 To nLSldPer
					aSaldoPer[nPos] := Round(NoRound((aSaldoPer[nPos]/aSetOfBook[9]),3),2)
				Next
			Endif
		Endif

		If Left(CTS->CTS_FORMUL, 7) == "ROTINA="
			nLSldAnt := Len(aSaldoAnt)
			nLSldAtu := Len(aSaldoAtu)
			nLSldSem := Len(aSaldoSem)
			nLSldPer := Len(aSaldoPer)
			nFator := &(Subs(CTS->CTS_FORMUL, 8))
			For nPos := 1 To nLSldAnt
				aSaldoAnt[nPos] *= nFator
			Next
			For nPos := 1 To nLSldAtu
				aSaldoAtu[nPos] *= nFator
			Next
			If lSemestre
				For nPos := 1 To nLSldSem
					aSaldoSem[nPos] *= nFator
				Next
			Endif
			If lPeriodo0
				For nPos := 1 To nLSldPer
					aSaldoPer[nPos] *= nFator
				Next
			Endif
		Endif
			
		// Calculos com os Fatores
		If CTS->CTS_IDENT = "1"				// Somo os saldos
			nSaldoAnt 	+= aSaldoAnt[6]		// Saldo Anterior
			nSaldoAtu 	+= aSaldoAtu[1]		// Saldo Atual
			If lSemestre
				nSaldoSem += aSaldoSEM[1]	// Saldo Semestre
			Endif
			If lPeriodo0
				nSaldoPer += aSaldoPER[1]	// Saldo variavel dPeriodo0
			Endif
				
			nSaldoAntD 	+= aSaldoAnt[7]
			nSaldoAntC 	+= aSaldoAnt[8]

			nSaldoAtuD 	+= aSaldoAtu[4]
			nSaldoAtuC 	+= aSaldoAtu[5] 
		
			nSaldoDeb  	:= (nSaldoAtuD - nSaldoAntD)
			nSaldoCrd  	:= (nSaldoAtuC - nSaldoAntC)
				
		ElseIf CTS->CTS_IDENT = "2"			// Subtraio os saldos
			nSaldoAnt 	-= aSaldoAnt[6]		// Saldo Anterior
			nSaldoAtu 	-= aSaldoAtu[1]		// Saldo Atual
			If lSemestre
				nSaldoSem -= aSaldoSEM[1]	// Saldo Semestre
			Endif
			If lPeriodo0
				nSaldoPer -= aSaldoPER[1]	// Saldo Periodo determinado
			Endif
				
			nSaldoAntD 	-= aSaldoAnt[7]
			nSaldoAntC 	-= aSaldoAnt[8]
		
			nSaldoAtuD 	-= aSaldoAtu[4]
			nSaldoAtuC 	-= aSaldoAtu[5] 
		
			nSaldoDeb  	:= (nSaldoAtuD - nSaldoAntD)
			nSaldoCrd  	:= (nSaldoAtuC - nSaldoAntC)
		
		EndIf
       
		nMOVIMPER += (aSaldoAnt[5] - aSaldoPer[8]) - (aSaldoAnt[4] - aSaldoPer[7])

		dbSelectArea("CTS")
		dbSetOrder(1)  
		nReg := Recno()
		dbSkip()
		
		If lTRegCts .And. CTS_COLUNA > 0	// A coluna 0 nao respeita desmembramento
			Exit
		Endif		
	EnddO

	dbSelectArea("CTS")
	dbSetOrder(2)
	dbGoTo(nReg)
	cCodNor := CTS->CTS_NORMAL

	If !lVlrZerado .And. (nSaldoCrd-nSaldoDeb = 0 .And. nSaldoAnt == 0 .And. nSaldoAtu == 0) .And. ;
		(nSaldoDeb = 0 .And. nSaldoCRD = 0) 
		///DbDelete()			/// RETIRADO DELETE 
		
		dbSelectArea("CTS")	
		dbSetOrder(1)
		dbGoTo(nReg)
		dbSkip()
   		Loop					/// SÓ INCLUI NO TMP SE O SALDO NÃO ESTIVER ZERADO (NAO PRECISA ATUALIZAR SUPERIORES)
    EndIf	
    
	dbSelectArea("cArqTmp")
	dbSetOrder(1)	
	If !MsSeek(cConta)
		dbAppend()                    
		If cAlias = 'CTU'
			Do Case
			Case cIdent	= 'CTT'
				Replace CUSTO 	With  cConta
				Replace DESCCC	With cDesc						
				Replace TIPOCC 	With CTS->CTS_CLASSE				
			Case cIdent = 'CTD'
				Replace ITEM 		With cConta
				Replace DESCITEM    With cDesc			
				Replace TIPOITEM	With CTS->CTS_CLASSE
			Case cIdent = 'CTH'
				Replace CLVL		With cConta
				Replace DESCCLVL	With cDesc			
				Replace TIPOCLVL	With CTS->CTS_CLASSE							
			EndCase                          
		Else
			Replace CONTA 		With cConta
			Replace DESCCTA    	With cDesc
		EndIf
		Replace SUPERIOR  	With CTS->CTS_CTASUP
		Replace TIPOCONTA 	With CTS->CTS_CLASSE
		Replace NORMAL    	With CTS->CTS_NORMAL
		Replace ORDEM		With CTS->CTS_ORDEM
		Replace IDENTIFI	With CTS->CTS_IDENT
		If lColuna
			Replace COLUNA  With CTS->CTS_COLUNA
		Endif

		If lTRegCts
			CT1->(DbSeek(xFilial("CT1") + CTS->CTS_CT1INI))
			Replace DESCORIG 	With &("CT1->CT1_DESC" + cMoeda),;
					TIPOCONTA 	With CT1->CT1_CLASSE,;
					NORMAL    	With CT1->CT1_NORMAL
		Endif		
	EndIf

	If Left(CTS->CTS_FORMUL, 6) = "TEXTO="		// Adiciona texto a descricao
		Replace ("cArqTmp")->DESCCTA With 	AllTrim(("cArqTmp")->DESCCTA) + Space(1) +;
												&(Subs(CTS->CTS_FORMUL, 7))
	Endif

	dbSelectArea("cArqTmp")
	Replace	SALDOANT With nSaldoAnt			// Saldo Anterior
	Replace SALDOATU With nSaldoAtu			// Saldo Atual

	Replace SALDOATUDB With nSaldoAtuD		//Saldo Atual Devedor
	Replace SALDOATUCR With nSaldoAtuC		//Saldo Atual Credor
	
	If lSemestre
		Replace SALDOSEM With nSaldoSEM		// Saldo Semestre
	Endif
	
	If lPeriodo0	// Saldo periodo determinado
		Replace SALDOPER 	With nSaldoPER
		Replace MOVIMPER  	With nMOVIMPER 
	Endif

	If nSaldoDeb < 0 //.And. cCodNor == "1"
		Replace SALDOCRD	With nSaldoDeb
	ElseIf nSaldoDeb >= 0 //.And. cCodNor == "1"
		Replace SALDODEB	With nSaldoDeb
	EndIf
	If nSaldoCrd < 0// .And. cCodNor == "2"
		Replace SALDODEB	With nSaldoCrd
	ElseIf nSaldoCrd >= 0 //.And. cCodNor == "2"
		Replace SALDOCRD	With nSaldoCrd
	EndIf
	
	Replace MOVIMENTO With nSaldoCrd-nSaldoDeb
    	
	If lComNivel
		aNivel := {}
		Aadd(aNivel, Recno())
	Endif
 
	If lImpSint
		dbSelectArea("CTS")
		dbSetOrder(2)
		// Grava contas sinteticas
		If !Empty(CTS->CTS_CTASUP)
			While !Eof() .And. 	CTS->CTS_FILIAL == cFilCTS .And. ;
									CTS->CTS_CODPLAN == cPlanGer
		
				cContaSup 	:= CTS->CTS_CTASUP
				
				dbSelectArea("CTS")
				dbSetOrder(2)
				If MsSeek(cFilCTS+cPlanGer+cContaSup)
					cDesc 	:= CTS->CTS_DESCCG
					cNormal := CTS->CTS_NORMAL
				Else
					cNormal	:= cCodNor	
				EndIf
   	
				dbSelectArea("cArqTmp")
				dbSetOrder(1)
				If !MsSeek(cContaSup)
					dbAppend() 
					If cAlias = 'CTU'	                     
						Do Case
						Case cIdent = 'CTT'
							Replace CUSTO 		With cContaSup			
							Replace DESCCC		With cDesc								
							Replace TIPOCC		With CTS->CTS_CLASSE
						Case cIdent	= 'CTD'
							Replace ITEM 		With cContaSup
							Replace DESCITEM	With cDesc          
							Replace TIPOITEM	With CTS->CTS_CLASSE
						Case cIdent = 'CTH'
							Replace CLVL 		With cContaSup
							Replace DESCCLVL	With cDesc          
						Replace TIPOCLVL	With CTS->CTS_CLASSE
						EndCase
					Else	
						Replace CONTA	With cContaSup
						Replace DESCCTA With cDesc		
					EndIf
					Replace SUPERIOR  	With CTS->CTS_CTASUP
					Replace TIPOCONTA	With CTS->CTS_CLASSE
					Replace NORMAL   	With CTS->CTS_NORMAL
					Replace ORDEM		With CTS->CTS_ORDEM
					Replace IDENTIFI	With CTS->CTS_IDENT
					If lColuna
						Replace COLUNA  With CTS->CTS_COLUNA
					Endif
					If lTRegCts
						CT1->(DbSeek(xFilial("CT1") + CTS->CTS_CT1INI))
						Replace DESCORIG 	With &("CT1->CT1_DESC" + cMoeda),;
								TIPOCONTA 	With CT1->CT1_CLASSE,;
								NORMAL    	With CT1->CT1_NORMAL
					Endif
				EndIf    
		
				Replace	SALDOANT With SALDOANT + nSaldoAnt			// Saldo Anterior
				Replace SALDOATU With SALDOATU + nSaldoAtu			// Saldo Atual
				
				Replace SALDOATUDB With SALDOATUDB + nSaldoAtuD		//Saldo Atual Devedor
				Replace SALDOATUCR With SALDOATUCR + nSaldoAtuC		//Saldo Atual Credor
				
				If nSaldoDeb < 0 //.And. cNormal == "1"
					Replace SALDOCRD	With SALDOCRD + nSaldoDeb
				ElseIf nSaldoDeb >= 0 //.And. cNormal == "1"
					Replace SALDODEB	With SALDODEB + nSaldoDeb
				EndIf
				If nSaldoCrd < 0 //.And. cNormal == "2"
					Replace SALDODEB	With SALDODEB + nSaldoCrd
				ElseIf nSaldoCrd >= 0 //.And. cNormal == "2"
					Replace SALDOCRD	With SALDOCRD + nSaldoCrd
				EndIf
   	
//				Replace MOVIMENTO With nSaldoCrd-nSaldoDeb
				Replace MOVIMENTO With SALDOCRD-SALDODEB
				
				If lSemestre		// Saldo por semestre
					Replace SALDOSEM With SALDOSEM + nSaldoSEM
				Endif
				If lPeriodo0		// Saldo periodo determinado
					Replace SALDOPER With SALDOPER + nSaldoPER
				Endif
   	
  	            If lComNivel
					Aadd(aNivel, Recno())
				Endif
				
				dbSelectArea("CTS")
				If !Eof() .And. Empty(CTS->CTS_CTASUP)
					dbSelectArea("cArqTmp")
					Replace NIVEL1 With .T.
					dbSelectArea("CTS")
					Exit
				EndIf
			EndDo
		
			If lComNivel
				dbSelectArea("cArqTmp")
				nContador 	:= 1
				For nNivel 	:= Len(aNivel) To 1 Step -1
					DbGoto(aNivel[nNivel])
					Replace NIVEL With nContador ++
				Next		
			Endif
		
		EndIf
	Endif
	
	dbSelectArea("CTS")
	dbSetOrder(1)
	dbGoTo(nReg)
	dbSkip()

EndDo

RestArea(aSaveArea)

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbOk      ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Mensagem no botao Ok                                        			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbOk()                                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Mensagem                                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nwnhum                                    	                 		 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbOk()

Return MsgYesNo(OemToAnsi(STR0002),OemToAnsi(STR0003))

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetMasCTB  ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna a mascara da entirdade                              			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³RetMasCTB(cCodigo,cSeparador)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³cMascara                                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo da Mascara                 	                 		 ³±±
±±³          ³ ExpC2 = Separador                         	                 		 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function RetMasCTB(cCodigo,cSeparador)

Local aSaveArea := GetArea()
Local cMascara  := ""
Local cDigito

dbSelectArea("CTM")
dbSetOrder(1)
MsSeek(xFilial()+cCodigo)
While !Eof() .And. CTM->CTM_FILIAL == xFilial() .And.;
		CTM->CTM_CODIGO == cCodigo

	cDigito 	:= CTM->CTM_DIGITO
	cMascara 	+= Alltrim(cDigito)
	cSeparador	+= CTM->CTM_SEPARA
	dbSkip()

EndDo

RestArea(aSaveArea)

Return cMascara

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MascaraCTB ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna a entidade com a mascara                            			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MascaraCTB(Codigo,cMascara,nTamanho,cSeparador)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³cCodigo                                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo da Entidade                	                 		 ³±±
±±³          ³ ExpC2 = Mascara                           	                 		 ³±±
±±³          ³ ExpN1 = Tamanho                           	                 		 ³±±
±±³          ³ ExpC3 = Separador                         	                 		 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MascaraCTB(cCodigo,cMascara,nTamanho,cSeparador,cAlias)

Local cCodLido := AllTrim ( cCodigo )
Local cCaracter:= ""
Local cPosicao	:= ""
Local cCodMasc	:= ""
Local nTamPos	:= 0
Local nTam		:= 0
Local nCont		:= 0
Local nNivel	:= 0
Local nPosicao := 0

If !Empty(cMascara) .And. !Empty(cSeparador)
	nTamanho 		:= Iif(nTamanho == NIL,Len(cCodigo)+Len(cMascara)-1,nTamanho)
	cCodigo			:= AllTrim(cCodigo)	
	If (Len(cSeparador)+Len(cCodigo)) > nTamanho
		nTam 			:= (Len(cSeparador)+Len(cCodigo)) - nTamanho
		cSeparador 	:= Substr(cSeparador,1,(Len(cSeparador)-nTam))
	EndIf

	For nNivel = 1 to Len ( cMascara ) Step 2
		nPosicao += Val ( Substr ( cMascara, nNivel, 2 ) ) + 1
		nCont++
		cCaracter := Substr(cSeparador,nCont,1)
		If ( nPosicao <= Len ( cCodigo ) )
			cCodigo := Stuff ( cCodigo, nPosicao, 0, cCaracter)
		End
	Next
Else
	// Manter compatibilidade com versao anterior do fonte.
	cCodigo		:= AllTrim ( cCodigo )
	If (cMascara == Nil .And. cAlias != Nil)
		If cAlias == "CT1"
			cMascara := GetMv("MV_MASCARA")
		ElseIf cAlias == "CTT"
			cMascara := GetMv("MV_MASCCUS")
		EndIf		
	EndIf
	cMascara 	:= Iif(cMascara == NIL,GetMV("MV_MASCARA"),cMascara)
	cSeparador  := Iif(cSeparador == Nil .Or. Empty(cSeparador),Repl(".", Len(cMascara) - 1),cSeparador)
	nTamanho 	:= Iif(nTamanho == NIL,Len(cCodigo)+Len(cMascara)-1,nTamanho)
                        
	If !Empty(cMascara) .And. !Empty(cCodigo)
	    For nNivel := 1 to Len(cCodLido)
			cPosicao := Substr(cMascara,nNivel,1)
			
			If 65 <= ASC(cPosicao) .And. ASC(cPosicao) <= 90
			   nTamPos := ASC(cPosicao)-55	
			ElseIf 97 <= ASC(cPosicao) .And. ASC(cPosicao) <= 122
			   nTamPos := ASC(cPosicao)-81
			Else 
			   nTamPos := Val(cPosicao)    
			EndIf
			
			cCodMasc += Left(cCodLido,nTamPos)
			cCodLido := Substr(cCodLido,nTamPos+1)
			If ! Empty(cCodLido)
				cCodMasc += Substr(cSeparador,nNivel,1)
			Endif
		Next
	    cCodigo := cCodMasc + cCodLido
	EndIf
EndIf

cCodigo := PadR ( cCodigo, nTamanho )

Return ( cCodigo )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbValiDt  ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³validacao da data                                           			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbValidt(nOpc,dData)                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T./.F.                                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Numero da opcao escolhida         	                 		 ³±±
±±³          ³ ExpD1 = Data                              	                 		 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbValiDt(nOpc,dData)

Local aSaveArea := GetArea()
Local nRet		:= 0
Local nMoedas	:= 0     
Local nCont		:= 0

If __nQuantas == 0
	__nQuantas := CtbMoedas()
EndIf	

For nCont := 1 To __nQuantas
	dbSelectArea("CTO")
	dbSetOrder(1)
	If	MsSeek(xFilial()+StrZero(nCont,2))
		If CtbDtComp(nOpc,dData,CTO->CTO_MOEDA,.F.)
			nRet ++
		EndIf
	Else
		nMoedas++
	EndIf
Next nCont

If nMoedas == __nQuantas 
	Help(" ",1,"NOMOEDCTO")
	nRet := 0
ElseIf nRet == 0
	Help(" ",1,"CTGDTCOMP")
EndIf

RestArea(aSaveArea)

Return nRet > 0
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtTipoLan  ³ Autor ³ Pilar S Albaladejo    ³ Data ³ 15.12.99 		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³validacao do tipo do lancamento                             			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtTipoLan()                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T./.F.                                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                    	                 		 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtTipoLan()

Local aSaveArea := GetArea()
Local aRateio
Local cTipant	:= TMP->CT2_DC
Local cVar		:= ReadVar()
Local cTipoDC	
Local cTipo
Local lRet 		:= .T.
Local lCancel	:= .F.
Local nValRat     
Local nValor 	:= TMP->CT2_VALOR
Local nValorAnt := 0
Local nTotalDeb := 0
Local nTotalCrd := 0
Local nRecTmp	:= 0
Local nOrdTMP	:= 1
Local cMensagem	:= ""
Local cSeqLan	:= ""                  
Local cSeqHis	:= "001"
               
cTipoDc	:= &(ReadVar())

If cTipAnt == "4" .And. cTipAnt <> cTipoDc 						//// NÃO DEVE EXECUTAR RATEIO OU LP SEM PASSAR POR ESTA VALIDACAO
	//Se for Complemento de historico, nao deixar alterar. Devera deletar o registro e incluir uma 
	//nova linha.
	cMensagem	:= STR0055 + chr(13) 
	cMensagem	+= STR0056
	MsgInfo(cMensagem)
	lRet	:= .F.		
ElseIF !Empty(cTipAnt) .and. cTipoDC$("56")					//// SE NÃO FOR REGISTRO NOVO (DC JA PREENCHIDO) E INDICADO TIPO RATEIO/LP
	cMensagem	:= STR0066 + chr(13) 
	cMensagem	+= STR0056
	MsgInfo(cMensagem)
	lRet	:= .F.	
ElseIf cTipoDC == "6"				// Lancamento Padrao
	cPadrao 	:= CtbEscPad(@lCancel)
	If !Empty(cPadrao)
		cTipo 	:= CtbEnche(cPadrao,.F.)
		&cVar		:= cTipo
	Else
		If !lCancel					// Usuario nao cancelou a escolha do rateio, e o rateio nao existe!
			Help("",1,"NOLCTOPAD")
			lRet := .F.
		Else   
			lRet := .F.
		EndIf	
	EndIf
ElseIf cTipoDC == "5"			// Rateio
	aRateio:=CtbEscRat(@lCancel)
	IF Len(aRateio) != 0
		cRateio	:= aRateio[1]
		nValRat	:= aRateio[2]
		cTipo 	:= CtbRateio(	cRateio,nValRat,@nTotalDeb,@nTotalCrd,;
								aRateio[3],aRateio[4],aRateio[5])
		&cVar		:= cTipo
		
		If !lCancel
			// Usuario nao cancelou a escolha do rateio, e o rateio nao existe!
			If cTipo = "5" 
				Help("",1,	"NoRateio",,	CHR(13)+;
							"Ou todas as contas do rateio estao zeradas"+;
							CHR(13),4,0)
				lRet := .F.
			Endif
		Else
			lRet := .F.		
		EndIf

		If lRet
			aTotRdpe := {{0,0,0,0},{0,0,0,0}}

			nRecTmp := TMP->(Recno())
			TMP->(DbGoTop())
			While ! TMP->(Eof())		
				If ! TMP->CT2_FLAG
					CTB102Exibe(TMP->CT2_VALOR,0,TMP->CT2_DC,TMP->CT2_DC,GetMv("MV_SOMA"))
				Endif
				TMP->(DbSkip())		
			EndDo
			TMP->(DbGoTo(nRecTmp))
		Endif
	Else
		If !lCancel					// Usuario nao cancelou a escolha do rateio, e o rateio nao existe!
			Help("",1,"NoRateio")
			lRet := .F.
		Else   
			lRet := .F.
		EndIf	
	EndIF            
Else
	&cVar			:= cTipoDc
	// Atualiza rodape -> MSGETDB
	If cTipoDC != cTipAnt
		CTB102Exibe(nValor,nValorAnt,cTipoDC,cTipAnt,GetMv("MV_SOMA"))
	EndIf	
	TMP->CT2_DC := cTipoDC
                              
	//Gravacao do TMP->CT2_SEQLAN
	If cTipoDc <> cTipAnt .Or. Empty(TMP->CT2_SEQLAN)
		dbSelectArea("TMP")                                                                		
		nOrdTMP	:= IndexOrd()
		nRecTMP	:= Recno()
		dbSetOrder(2)
		dbSkip(-1) 			//Procuro pela sequencia, para poder calcular a proxima. 
		If !Bof() .And. !Eof()   
			If cTipoDC == "4"
				cSeqHis	:= StrZero((Val(TMP->CT2_SEQHIS)+1),3)				
			Else
				cSeqHis	:= "001"
			EndiF				
	
			If cTipoDC == "4"	
				cSeqLan	:= TMP->CT2_SEQLAN
			Else
				If TMP->CT2_DC == "4"			
					While !TMP->(Bof()) .and. TMP->CT2_DC == "4"
						dbSkip(-1)
					End           
					cSeqLan 			:= StrZero((Val(TMP->CT2_SEQLAN)+1),3)										
				Else
					cSeqLan 			:= StrZero((Val(TMP->CT2_SEQLAN)+1),3)			
				EndIf 
			EndIf
		Else 
			cSeqLan 			:= '001'
		Endif			            

		dbGoto(nRecTMP)
		dbSetOrder(nOrdTMP)

		TMP->CT2_SEQLAN		:= cSeqLan
		TMP->CT2_SEQHIS		:= cSeqHis
	EndIf
EndIf                      

RestArea(aSaveArea)

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ReadCtbIni³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 27/11/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Leitura do arquivo SIGACTB.INI para carregar array aCTBINI  ³±±
±±³			 ³c/ configuracao da apropriacao de custos					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ReadCTBIni												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³ Array aCtbIni											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum   												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ReadIniCtb(lCarrega)

Local cTitCC
Local cTitItem
Local cTitClasse
Local cTamCC
Local cTamItem
Local cTamClVl
Local nHdlCusto := 0
Local nBytes:=0
Local nTamArq
Local xBuffer

DEFAULT lCarrega := .F.

If Len(aCtbIni) # 0 .And. ! lCarrega
	Return aCtbIni
Endif
aCtbIni := {}

IF !file("SIGACTB.INI")
	nHdlCusto := MSFCreate("SIGACTB.INI",0)
	IF nHdlCusto == -1
		HELP(" ",1,"CTB_ERROR")
		Final("Erro F_"+str(ferror(),2)+" em SIGACTB.INI")
	Endif
	cTitCC		:= RetTitle("CTT_CUSTO",10)
	cTitItem		:= RetTitle("CTD_ITEM",10)
	cTitClasse	:= RetTitle("CTH_CLVL",10)
	cTamCC 		:= StrZero(Len(CriaVar("CTT_CUSTO")),2)
	cTamItem		:= StrZero(Len(CriaVar("CTD_ITEM")),2)
	cTamClVL		:= StrZero(Len(CriaVar("CTH_CLVL")),2)

	fWrite(nHdlCusto,"01"+cTitCC+cTamCC+"1CTT"+chr(13)+chr(10))
	fWrite(nHdlCusto,"02"+cTitItem+cTamItem+"2CTD"+chr(13)+chr(10))
	fWrite(nHdlCusto,"03"+cTitCLasse+cTamCLVL+"2CTH"+chr(13)+chr(10))
	fClose(nHdlCusto)
Endif

nHdlCusto := FOPEN("SIGACTB.INI",64)

If nHdlCusto <0
	HELP(" ",1,"CTB_ERROR")
	Final("SIGACTB.INI")
EndIf
nTamArq:=FSEEK(nHdlCusto,0,2)		// VerIfica tamanho do arquivo
FSEEK(nHdlCusto,0,0)					// Volta para inicio do arquivo

While nBytes<nTamArq
	
	xBuffer:=Space(20)
	FREAD(nHdlCusto,@xBuffer,20)
	
	AADD(	aCtbIni,SubStr(xBuffer,1,02)+" "+SubStr(xBuffer,03,10)+" "+;
			SubStr(xBuffer,13,02) + " " + SubStr(xBuffer,15,01) +" "+;
			Substr(xBuffer,16,03) )
	nBytes+=20
End

Fclose(nHdlCusto)

Return aCtbIni


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³CtbMovSaldo³ Autor ³ Pilar S. Albaladejo  ³ Data ³ 27/11/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Verifica se a o centro de custo, item ou classe de valor    ³±±
±±³			 ³esta em uso.                              				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³CtbMovSaldo(cAlias)										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³.T./.F.         											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo a ser verificado				  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbMovSaldo(cAlias, lMessage)
	
Local lRet		:= .f.
Local nPos
Local aCtbIni 	:= ReadIniCtb()
Local bSx3 		:= { |cCampo| (	SX3->(DbSetOrder(2)), SX3->(DbSeek(cCampo)),;
								SX3->(DbSetOrder(1)), SX3->X3_USADO) }

DEFAULT lMessage := .F.

If ! CtbInUse()		// Compatibilizacao com o SigaCon
	If cAlias = "CTT"
		lRet 	:= X3Uso(Eval(bSx3, "I2_CCC")) .And. X3Uso(Eval(bSx3, "I2_CCD"))
	ElseIf cAlias = "CTD"
		lRet 	:= X3Uso(Eval(bSx3, "I2_ITEMC")) .And. X3Uso(Eval(bSx3, "I2_ITEMD"))
	Else
		lRet	:= .F.
	Endif
Else
	nPos := Ascan(aCtbIni, {|x| Substr(x,20,03) = Upper(cAlias) })
	If nPos > 0
		lRet := Iif(Substr(aCtbIni[nPos],18,1) == "1",.T.,.F.)
	Endif
Endif

If ! lRet .And. lMessage .And. cAlias = "CTH"
	Help(" ",1,"NCONSALCV")
ElseIf ! lRet .And. lMessage .And. cAlias = "CTD"
	Help(" ",1,"NCONSALITE")
ElseIf ! lRet .And. lMessage .And. cAlias = "CTT"
	Help(" ",1,"NCONSALCC")
Endif

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³CtbSayApro ³ Autor ³ Pilar S. Albaladejo  ³ Data ³ 27/11/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna a descricao do centro de custo, item ou classe de   ³±±
±±³			 ³valor configurada no SIGACTB.INI          				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³CtbSayApro(cAlias))										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³cTexto.         											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo a ser verificado				  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbSayApro(cAlias)
	
Local cTexto	:= ""
Local nPos
Local aCtbIni 	:= ReadIniCtb()

If ! CtbInUse()		// Compatibilizacao com o SigaCon
	Return If(cAlias = "CTH", "", If(cAlias = "CTT", STR0017, STR0018)) //"Centro custo"###"Item Contabil"
Endif

nPos := Ascan(aCtbIni, {|x| Substr(x,20,03) = Upper(cAlias) })
If nPos > 0
	cTexto := Substr(aCtbIni[nPos],04,10)
Endif

Return cTexto

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³SaldtotCT7 ³ Autor ³ Pilar S. Albaladejo 			   ³ Data ³ 27/11/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna os saldos do intervalo da conta ate a conta 			         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³SaldtotCT7(cContaIni,cContaFim,dData,cMoeda,cTpSald)		 			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												 			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta Inicial                    				 			 ³±±
±±³          ³ ExpC2 = Conta Final                      				 			 ³±±
±±³          ³ ExpD1 = Data                              			 				 ³±±
±±³          ³ ExpC3 = Moeda                            				 			 ³±±
±±³          ³ ExpC4 = Tipo de Saldo                       				 			 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SaldTotCT7(cContaIni,cContaFim,dData,cMoeda,cTpSald,lImpAntLP,dDataLP,cFilEsp)

Local aSaveArea	:= CT7->(GetArea())
Local aSaveAnt	:= GetArea()
Local lNaoAchei	:= .F.
Local nDebito	:= 0					// Valor Debito na Data
Local nCredito 	:= 0					// Valor Credito na Data
Local nAtuDeb  	:= 0					// Saldo Atual Devedor
Local nAtuCrd	:= 0					// Saldo Atual Credor
Local nVlDebAtu := 0					// Valor do Debito Atual
Local nVlCrdAtu := 0                    // Valor do Credito Atual
Local nVlDebAnt := 0					// Valor do Debito Anterior
Local nVlCrdAnt := 0                    // Valor do Credito Anterior
Local nAntDeb	:= 0					// Saldo Anterior Devedor
Local nAntCrd	:= 0					// Saldo Anterior Credor
Local nSaldoAnt	:= 0					// Saldo Anterior (com sinal)
Local nSaldoAtu	:= 0					// Saldo Atual (com sinal)
Local cChave, cChaveTot, bCondicao
Local bCondFil     
Local cConta	:= ""

DEFAULT lImpAntLp := .F.

cTpSald := Iif(Empty(cTpSald),"1",cTpSald)

#IFDEF TOP
	If TcGetDb() <> "AS/400"
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Query do Saldo Anterior³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cQuery := " SELECT SUM(CT7_DEBITO) SLDANTDB, SUM(CT7_CREDIT) SLDANTCR "
		cQuery += " FROM "+RetSqlName("CT7")
		If cFilEsp == Nil
			cQuery += " WHERE CT7_FILIAL = '"+xFilial("CT7")+"' "
		Else
			cQuery += " WHERE CT7_FILIAL = '"+cFilEsp+"' "		
		Endif
		cQuery += " AND CT7_CONTA >= '"+cContaIni+"' "
		cQuery += " AND CT7_CONTA <= '"+cContaFim+"' "
		cQuery += " AND CT7_MOEDA = '"+cMoeda+"' "
		cQuery += " AND CT7_TPSALD = '"+cTpSald+"' "
		cQuery += " AND CT7_DATA < '"+DTOS(dData)+"' "
		If lImpAntLP
			cQuery += "  AND (CT7_LP <> 'Z' OR (CT7_LP = 'Z' AND CT7_DTLP < '"+dDataLP+"')) "
		Endif
		cQuery += " AND D_E_L_E_T_ <> '*' "

		cQuery := ChangeQuery(cQuery)				
		If Select("SLDTOTCT7") > 0
			dbSelectArea("SLDTOTCT7")
			SldTotCt7->(dbCloseArea())
		Endif
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SLDTOTCT7",.T.,.F.)		

		TcSetField("SLDTOTCT7","SLDANTDB","N",__aTamVlr[1],__aTamVlr[2])	
		TcSetField("SLDTOTCT7","SLDANTCR","N",__aTamVlr[1],__aTamVlr[2])			        
		
		nAntDeb 	:= SLDTOTCT7->SLDANTDB
		nAntCrd 	:= SLDTOTCT7->SLDANTCR

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Query do Mov. no Dia   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
		cQuery := "SELECT SUM(CT7_DEBITO) DEBITO, SUM(CT7_CREDIT) CREDIT  "
		cQuery += "FROM "+RetSqlName("CT7")
		If cFilEsp == Nil
			cQuery += " WHERE CT7_FILIAL = '"+xFilial("CT7")+"' "
		Else
			cQuery += " WHERE CT7_FILIAL = '"+cFilEsp+"' "		
		Endif
		cQuery += " AND CT7_CONTA >= '"+cContaIni+"' "
		cQuery += " AND CT7_CONTA <= '"+cContaFim+"' "
		cQuery += " AND CT7_MOEDA = '"+cMoeda+"' "
		cQuery += " AND CT7_TPSALD = '"+cTpSald+"' "
		cQuery += " AND CT7_DATA = '"+DTOS(dData)+"' "
		If lImpAntLP
			cQuery += "  AND (CT7_LP <> 'Z' OR (CT7_LP = 'Z' AND CT7_DTLP < '"+dDataLP+"')) "
		Endif
		cQuery += " AND D_E_L_E_T_ <> '*' "

		cQuery := ChangeQuery(cQuery)				
		If Select("SLDTOTCT7") > 0
			dbSelectArea("SLDTOTCT7")
			SldTotCt7->(dbCloseArea())
		Endif
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SLDTOTCT7",.T.,.F.)		
		
		TcSetField("SLDTOTCT7","DEBITO"  ,"N",__aTamVlr[1],__aTamVlr[2])	
		TcSetField("SLDTOTCT7","CREDIT"  ,"N",__aTamVlr[1],__aTamVlr[2])			
		
		dbSelectArea("SLDTOTCT7")
		dbGoTop()
		// Movimentacao da data
		nDebito		:= SLDTOTCT7->DEBITO
		nCredito	:= SLDTOTCT7->CREDIT
	
		nAtuDeb := nAntDeb + nDebito
		nAtuCrd := nAntCrd + nCredito
			
		nSaldoAtu := nAtuCrd - nAtuDeb
		nSaldoAnt := nAntCrd - nAntDeb		
	Else
#ENDIF

dbSelectArea("CT7")
dbSetOrder(1)
If cFilEsp == Nil
	MsSeek(xFilial("CT7")+cMoeda+cTpSald+cContaIni,.T.) // Posiciona na primeira conta
	bCondFil	:= { || CT7_FILIAL == xFilial("CT7") }
Else
	MsSeek(cFilEsp+cMoeda+cTpSald+cContaIni,.T.) // Posiciona na primeira conta
	bCondFil	:= { || CT7_FILIAL == cFilEsp }	
EndIf 

// Processa todas as contas do intervalo
While !Eof() .And. ;
		Eval(bCondFil) 	  .And.;		
		CT7->CT7_MOEDA  == cMoeda    .And.;
		CT7->CT7_TPSALD == cTpSald   .And.;
		CT7->CT7_CONTA  <= cContaFim
		
	// Armazena a conta atual para ir para a proxima conta
	cChaveTot := CT7_FILIAL+CT7->CT7_MOEDA+CT7->CT7_TpSald+CT7->CT7_CONTA
	cChave    := CT7_FILIAL+CT7->CT7_CONTA+CT7->CT7_MOEDA+CT7->CT7_TpSald
	cConta	  := CT7_CONTA

	CT7->(DbSetOrder(2))
	
	// Dentro da mesma conta, pesquisa o primeiro saldo anterior ou igual
	// a data solicitada
	lNaoAchei := .F.

	CT7->(MsSeek(cChave+DTOS(dData),.T.))

	bCondicao	:= { || (	CT7_FILIAL+CT7->CT7_CONTA+CT7->CT7_MOEDA+;
							CT7->CT7_TpSald=cChave .And. CT7->CT7_DATA  <= dData) }

	CtQualSaldo(lImpAntLP, @lNaoAchei, bCondicao)
	
	// Contabiliza os saldos das contas solicitadas na data solicitada.
	IF !Eof() 							.And.;
		Eval(bCondFil)				 	.And.;
		CT7->CT7_MOEDA  == cMoeda    	.And.;
		CT7->CT7_TPSALD == cTpSald   	.And.;
		CT7->CT7_CONTA	== cConta		.And.;		
		CT7->CT7_DATA   <= dData             
		
//		CT7->CT7_CONTA  >= cContaIni 	.And.;
//		CT7->CT7_CONTA  <= cContaFim 	.And.;		
		
		// Movimentacao da data
		If CT7->CT7_DATA == dData
			nDebito	+= CT7->CT7_DEBITO
			nCredito	+= CT7->CT7_CREDITO
		Endif
		
		nAtuDeb	 += CT7->CT7_ATUDEB
		nAtuCrd  += CT7->CT7_ATUCRD
		nVlDebAtu := CT7->CT7_ATUDEB
		nVlCrdAtu := CT7->CT7_ATUCRD		
		
		If lNaoAchei
			// Neste caso, como a data nao foi encontrada, considera-se como saldo anterior
			// o saldo atual do registro anterior! -> dbskip(-1)
			nAntDeb    += CT7->CT7_ATUDEB
			nAntCrd    += CT7->CT7_ATUCRD			
			nVLDebAnt  := CT7->CT7_ATUDEB
			nVLCrdAnt  := CT7->CT7_ATUCRD						
		Else		
			nAntDeb    += CT7->CT7_ANTDEB
			nAntCrd    += CT7->CT7_ANTCRD			
			nVLDebAnt  := CT7->CT7_ANTDEB
			nVLCrdAnt  := CT7->CT7_ANTCRD						
		Endif

		// Caso queira desconsiderar um lucros e perdas e desde que esse lucros e perdas
		// seja inferior a data final, diminou o saldo do registro de zeramento do saldo encontrado
		// Desde que nao seja uma lancamento de zeramento

		If lImpAntLP .And. dDataLp < CT7_DATA .And. MsSeek(cChave+Dtos(dDataLP)+"Z", .F.)
			nAntDeb 	-= CT7_DEBITO
			nAntCrd 	-= CT7_CREDIT
			nVLDebAnt  	-= CT7_DEBITO
			nVLCrdAnt  	-= CT7_CREDIT

			nAtuDeb		-= CT7_DEBITO
			nAtuCrd		-= CT7_CREDIT
			nVlDebAtu 	-= CT7_DEBITO
			nVlCrdAtu 	-= CT7_CREDIT
		Endif

		nSaldoAtu	+= (nVlCrdAtu - nVlDebAtu)
		nSaldoAnt	+= (nVLCrdAnt - nVlDebAnt)
	EndIf
	
	CT7->(DbSetOrder(1))
	// Vai para a proxima conta
	CT7->(MsSeek(IncLast(cChaveTot),.T.))
	
Enddo
#IFDEF TOP
	Endif
#ENDIF

CT7->(RestArea(aSaveArea))
RestARea(aSaveAnt)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//      [1]       [2]     [3]      [4]     [5]     [6]       [7]     [8]
Return {nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³SaldtotCT3 ³ Autor ³ Pilar S. Albaladejo 			   ³ Data ³ 27/11/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna os saldos do intervalo de contas e centro de custo		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³SaldtotCT3(cCusIni,cCusFim,cContaIni,cContaFim,dData,cMoeda,cTpSald)	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												 			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Centro de Custo Inicial          				 			 ³±±
±±³          ³ ExpC2 = Centro de Custo Final            				 			 ³±±
±±³          ³ ExpC3 = Conta Final                      				 			 ³±±
±±³          ³ ExpC4 = Conta Final                      				 			 ³±±
±±³          ³ ExpD1 = Data                              			 				 ³±±
±±³          ³ ExpC3 = Moeda                            				 			 ³±±
±±³          ³ ExpC4 = Tipo de Saldo                       				 			 ³±±
±±³          ³ ExpC5 = Filial Especifica                   				 			 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SaldTotCT3(cCusIni,cCusFim,cContaIni,cContaFim,dData,cMoeda,cTpSald,cFilEsp)

Local aSaveArea	:= CT3->(GetArea())
Local aSaveAnt	:= GetArea()
Local lNaoAchei	:= .F.
Local nDebito	:= 0					// Valor Debito na Data
Local nCredito 	:= 0					// Valor Credito na Data
Local nAtuDeb  	:= 0					// Saldo Atual Devedor
Local nAtuCrd	:= 0					// Saldo Atual Credor
Local nVlDebAtu := 0					// Valor do Debito Atual
Local nVlCrdAtu := 0                    // Valor do Credito Atual
Local nVlDebAnt := 0					// Valor do Debito Anterior
Local nVlCrdAnt := 0                    // Valor do Credito Anterior
Local nAntDeb	:= 0					// Saldo Anterior Devedor
Local nAntCrd	:= 0					// Saldo Anterior Credor
Local nSaldoAnt:= 0						// Saldo Anterior (com sinal)
Local nSaldoAtu:= 0						// Saldo Atual (com sinal)
Local cCC
Local cConta
Local bCondFil

cTpSald := Iif(Empty(cTpSald),"1",cTpSald)
#IFDEF TOP
	If TcGetDb() <> "AS/400"
		
		cQuery := " SELECT SUM(CT3_DEBITO) SLDANTDB, SUM(CT3_CREDIT) SLDANTCR "
		cQuery += " FROM "+RetSqlName("CT3")
		If cFilEsp == Nil
			cQuery += " WHERE CT3_FILIAL = '"+xFilial("CT3")+"' "
		Else
			cQuery += " WHERE CT3_FILIAL = '"+cFilEsp+"' "
		Endif
		cQuery += " AND CT3_CONTA >= '"+cContaIni+"' "
		cQuery += " AND CT3_CONTA <= '"+cContaFim+"' "
		cQuery += " AND CT3_CUSTO >= '"+cCusIni+"' "
		cQuery += " AND CT3_CUSTO <= '"+cCusFim+"' "
		cQuery += " AND CT3_MOEDA = '"+cMoeda+"' "
		cQuery += " AND CT3_TPSALD = '"+cTpSald+"' "
		cQuery += " AND CT3_DATA < '"+DTOS(dData)+"' "
		/*If lImpAntLP
			cQuery += "  AND (CT3_LP <> 'Z' OR (CT3_LP = 'Z' AND CT3_DTLP < '"+dDataLP+"')) "
		Endif*/
		cQuery += " 	 AND D_E_L_E_T_ <> '*' "

		cQuery := ChangeQuery(cQuery)				
		If Select("SLDTOTCT3") > 0
			dbSelectArea("SLDTOTCT3")
			SLDTOTCT3->(dbCloseArea())
		Endif
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SLDTOTCT3",.T.,.F.)		

		TcSetField("SLDTOTCT3","SLDANTDB","N",__aTamVlr[1],__aTamVlr[2])	
		TcSetField("SLDTOTCT3","SLDANTCR","N",__aTamVlr[1],__aTamVlr[2])			
		
		dbSelectArea("SLDTOTCT3")
		dbGoTop()        

		nAntDeb 	:= SLDTOTCT3->SLDANTDB
		nAntCrd 	:= SLDTOTCT3->SLDANTCR    

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Query Mov. no Dia³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		cQuery := " SELECT SUM(CT3_DEBITO) DEBITO, SUM(CT3_CREDIT) CREDIT  "
		cQuery += " FROM "+RetSqlName("CT3")
		If cFilEsp == Nil
			cQuery += " WHERE CT3_FILIAL = '"+xFilial("CT3")+"' "
		Else
			cQuery += " WHERE CT3_FILIAL = '"+cFilEsp+"' "
		Endif
		cQuery += " AND CT3_CONTA >= '"+cContaIni+"' "
		cQuery += " AND CT3_CONTA <= '"+cContaFim+"' "
		cQuery += " AND CT3_CUSTO >= '"+cCusIni+"' "
		cQuery += " AND CT3_CUSTO <= '"+cCusFim+"' "
		cQuery += " AND CT3_MOEDA = '"+cMoeda+"' "
		cQuery += " AND CT3_TPSALD = '"+cTpSald+"' "
		cQuery += " AND CT3_DATA = '"+DTOS(dData)+"' "
		/*If lImpAntLP
			cQuery += "  AND (CT3_LP <> 'Z' OR (CT3_LP = 'Z' AND CT3_DTLP < '"+dDataLP+"')) "
		Endif*/
		cQuery += " 	 AND D_E_L_E_T_ <> '*' "

		cQuery := ChangeQuery(cQuery)				
		If Select("SLDTOTCT3") > 0
			dbSelectArea("SLDTOTCT3")
			SLDTOTCT3->(dbCloseArea())
		Endif
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SLDTOTCT3",.T.,.F.)		
		
		TcSetField("SLDTOTCT3","DEBITO"  ,"N",__aTamVlr[1],__aTamVlr[2])	
		TcSetField("SLDTOTCT3","CREDIT"  ,"N",__aTamVlr[1],__aTamVlr[2])			
		
		dbSelectArea("SLDTOTCT3")
		dbGoTop()
		
		// Movimentacao da data
		nDebito		:= SLDTOTCT3->DEBITO
		nCredito	:= SLDTOTCT3->CREDIT
	
		nAtuDeb := nAntDeb + nDebito
		nAtuCrd := nAntCrd + nCredito
			
		nSaldoAtu := nAtuCrd - nAtuDeb
		nSaldoAnt := nAntCrd - nAntDeb		
	Else
#ENDIF

dbSelectArea("CT3")
dbSetOrder(1)
If cFilEsp == Nil
	MsSeek(xFilial("CT3")+cMoeda+cTpSald+cContaIni,.T.) // Posiciona na primeira conta
	bCondFil	:= { || CT3_FILIAL == xFilial("CT3") }
Else
	MsSeek(cFilEsp+cMoeda+cTpSald+cContaIni,.T.) // Posiciona na primeira conta
	bCondFil	:= { || CT3_FILIAL == cFilEsp }	
EndIf 

// Processa todos as Contas do intervalo
While !Eof() 							  .And.;
		Eval(bCondFil)	 .And.;
		CT3->CT3_MOEDA  == cMoeda    .And.;
		CT3->CT3_TPSALD == cTpSald   .And.;
		CT3->CT3_CONTA  <= cContaFim

	// Armazena a conta atual para ir para a proxima Conta
	cConta := CT3->(CT3_FILIAL+CT3_MOEDA+CT3_TpSald+CT3_CONTA)	
	
	// Dentro da mesma Conta, processa os CC do intervalo
	CT3->(MsSeek(cConta+cCusIni,.T.))
	
	// Processa todos os CC do intervalo
	While !Eof() .And. ;
         CT3->CT3_FILIAL + ;
         CT3->CT3_MOEDA  + ;
         CT3->CT3_TPSALD + ;
         CT3->CT3_CONTA  == cConta .And.;
         CT3->CT3_CUSTO  <= cCusFim
			
		// Armazena o centro de custo atual para ir para o proximo CC
		cCC := CT3->(CT3_FILIAL+CT3_MOEDA+CT3_TpSald+CT3_CONTA+CT3_CUSTO)
		
		// Dentro da mesma conta, do mesmo centro de custo, pesquisa 
		// o primeiro saldo anterior ou igual a data solicitada
		lNaoAchei := .F.
		If ! CT3->(MsSeek(cCC+DTOS(dData),.T.))
			CT3->(DbSkip(-1))
			lNaoAchei := .T.
		Endif
		
		// Contabiliza os saldos das contas e dos centros de custo solicitados 
		// na data solicitada.
      If CT3->(!Eof())          .And.;
         CT3->CT3_FILIAL +;
         CT3->CT3_MOEDA  +;
         CT3->CT3_TPSALD +;
         CT3->CT3_CONTA  +;
         CT3->CT3_CUSTO  == cCC .And.;
  	 	 CT3->CT3_DATA   <= dData
			
			// Movimentacao da data
			If CT3->CT3_DATA == dData
				nDebito	+= CT3->CT3_DEBITO
				nCredito	+= CT3->CT3_CREDITO
			Endif	
			nAtuDeb	+= CT3->CT3_ATUDEB
			nAtuCrd  += CT3->CT3_ATUCRD			
			nVlDebAtu := CT3->CT3_ATUDEB
			nVlCrdAtu := CT3->CT3_ATUCRD		
			
		If lNaoAchei
				// Neste caso, como a data nao foi encontrada, considera-se como saldo anterior
				// o saldo atual do registro anterior! -> dbskip(-1)
				nAntDeb   += CT3->CT3_ATUDEB
				nAntCrd   += CT3->CT3_ATUCRD
				nVlDebAnt := CT3->CT3_ATUDEB
				nVlCrdAnt := CT3->CT3_ATUCRD		
			Else		
				nAntDeb   += CT3->CT3_ANTDEB
				nAntCrd   += CT3->CT3_ANTCRD     
				nVlDebAnt := CT3->CT3_ANTDEB
				nVlCrdAnt := CT3->CT3_ANTCRD		
			Endif
			nSaldoAtu	+= (nVlCrdAtu - nVlDebAtu)
			nSaldoAnt	+= (nVLCrdAnt - nVlDebAnt)			
		Endif
		// Vai para o proximo Centro de custo
		CT3->(MsSeek(IncLast(cCC),.T.))
	Enddo
	// Vai para a proxima conta
	CT3->(MsSeek(IncLast(cConta),.T.))
Enddo

#IFDEF TOP
	Endif
#ENDIF

CT3->(RestArea(aSaveArea))
RestArea(aSaveAnt)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//      [1]       [2]     [3]      [4]     [5]     [6]       [7]     [8]
Return {nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³SaldtotCT4 ³ Autor ³ Pilar S. Albaladejo 			   ³ Data ³ 27/11/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna os saldos do intervalo de conta,item e centro de custo		 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³SaldtotCT4(cItemIni,cItemFim,cCusIni,cCusFim,cContaini,cContaFim,   	 ³±±
±±³       	 ³dData,cMoeda,cTpSald)                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												 			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Item Inicial                     				 			 ³±±
±±³		     ³ ExpC1 = Item Final                       				 			 ³±±
±±³          ³ ExpC1 = Centro de Custo Inicial          				 			 ³±±
±±³          ³ ExpC2 = Centro de Custo Final            				 			 ³±±
±±³          ³ ExpC3 = Conta Final                      				 			 ³±±
±±³          ³ ExpC4 = Conta Final                      				 			 ³±±
±±³          ³ ExpD1 = Data                              			 				 ³±±
±±³          ³ ExpC3 = Moeda                            				 			 ³±±
±±³          ³ ExpC4 = Tipo de Saldo                       				 			 ³±±
±±³          ³ ExpC5 = Filial Especifica                   				 			 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SaldTotCT4(cItemIni,cItemFim,cCusIni,cCusFim,cContaIni,cContaFim,;
						  dData,cMoeda,cTpSald,cFilEsp)

Local aSaveArea	:= CT4->(GetArea())
Local aSaveAnt	:= GetArea()
Local lNaoAchei	:= .F.
Local nDebito	:= 0					// Valor Debito na Data
Local nCredito 	:= 0					// Valor Credito na Data
Local nAtuDeb  	:= 0					// Saldo Atual Devedor
Local nAtuCrd	:= 0					// Saldo Atual Credor
Local nVlDebAtu := 0					// Valor do Debito Atual
Local nVlCrdAtu := 0                    // Valor do Credito Atual
Local nVlDebAnt := 0					// Valor do Debito Anterior
Local nVlCrdAnt := 0                    // Valor do Credito Anterior
Local nAntDeb	:= 0					// Saldo Anterior Devedor
Local nAntCrd	:= 0					// Saldo Anterior Credor
Local nSaldoAnt	:= 0					// Saldo Anterior (com sinal)
Local nSaldoAtu	:= 0					// Saldo Atual (com sinal)
Local cCC
Local cConta
Local cItem
Local bCondFil

cTpSald := Iif(Empty(cTpSald),"1",cTpSald)

#IFDEF TOP
	If TcGetDb() <> "AS/400"

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ ¿
		//³Query Saldo Anterior³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Ù
		cQuery := " SELECT SUM(CT4_DEBITO) SLDANTDB, SUM(CT4_CREDIT) SLDANTCR "
		cQuery += " FROM "+RetSqlName("CT4")
		If cFilEsp == Nil
			cQuery += " WHERE CT4_FILIAL = '"+xFilial("CT4")+"' "
		Else
			cQuery += " WHERE CT4_FILIAL = '"+cFilEsp+"' "
		Endif
		cQuery += " AND CT4_CONTA >= '"+cContaIni+"' "
		cQuery += " AND CT4_CONTA <= '"+cContaFim+"' "
		cQuery += " AND CT4_CUSTO >= '"+cCusIni+"' "
		cQuery += " AND CT4_CUSTO <= '"+cCusFim+"' "
		cQuery += " AND CT4_ITEM  >= '"+cItemIni+"' "
		cQuery += " AND CT4_ITEM  <= '"+cItemFim+"' "
		cQuery += " AND CT4_MOEDA = '"+cMoeda+"' "
		cQuery += " AND CT4_TPSALD = '"+cTpSald+"' "
		cQuery += " AND CT4_DATA < '"+DTOS(dData)+"' "
		/*If lImpAntLP
			cQuery += "  AND (CT4_LP <> 'Z' OR (CT4_LP = 'Z' AND CT4_DTLP < '"+dDataLP+"')) "
		Endif*/
		cQuery += " 	 AND D_E_L_E_T_ <> '*' "

		cQuery := ChangeQuery(cQuery)				
		If Select("SLDTOTCT4") > 0
			dbSelectArea("SLDTOTCT4")
			SLDTOTCT4->(dbCloseArea())
		Endif
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SLDTOTCT4",.T.,.F.)				

		TcSetField("SLDTOTCT4","SLDANTDB","N",__aTamVlr[1],__aTamVlr[2])	
		TcSetField("SLDTOTCT4","SLDANTCR","N",__aTamVlr[1],__aTamVlr[2])			
		
		dbSelectArea("SLDTOTCT4")
		dbGoTop()

		nAntDeb 	:= SLDTOTCT4->SLDANTDB
		nAntCrd 	:= SLDTOTCT4->SLDANTCR
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Query Mov. no Dia³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cQuery := " SELECT SUM(CT4_DEBITO) DEBITO, SUM(CT4_CREDIT) CREDIT  "
		cQuery += " FROM "+RetSqlName("CT4")
		If cFilEsp == Nil
			cQuery += " WHERE CT4_FILIAL = '"+xFilial("CT4")+"' "
		Else
			cQuery += " WHERE CT4_FILIAL = '"+cFilEsp+"' "
		Endif
		cQuery += " AND CT4_CONTA >= '"+cContaIni+"' "
		cQuery += " AND CT4_CONTA <= '"+cContaFim+"' "
		cQuery += " AND CT4_CUSTO >= '"+cCusIni+"' "
		cQuery += " AND CT4_CUSTO <= '"+cCusFim+"' "
		cQuery += " AND CT4_ITEM  >= '"+cItemIni+"' "
		cQuery += " AND CT4_ITEM  <= '"+cItemFim+"' "
		cQuery += " AND CT4_MOEDA = '"+cMoeda+"' "
		cQuery += " AND CT4_TPSALD = '"+cTpSald+"' "
		cQuery += " AND CT4_DATA = '"+DTOS(dData)+"' "
		/*If lImpAntLP
			cQuery += "  AND (CT4_LP <> 'Z' OR (CT4_LP = 'Z' AND CT4_DTLP < '"+dDataLP+"')) "
		Endif*/
		cQuery += " 	 AND D_E_L_E_T_ <> '*' "

		cQuery := ChangeQuery(cQuery)				
		If Select("SLDTOTCT4") > 0
			dbSelectArea("SLDTOTCT4")
			SLDTOTCT4->(dbCloseArea())
		Endif
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SLDTOTCT4",.T.,.F.)		
		
		TcSetField("SLDTOTCT4","DEBITO"  ,"N",__aTamVlr[1],__aTamVlr[2])	
		TcSetField("SLDTOTCT4","CREDIT"  ,"N",__aTamVlr[1],__aTamVlr[2])			
		
		dbSelectArea("SLDTOTCT4")
		dbGoTop()
		
		// Movimentacao da data
		nDebito		:= SLDTOTCT4->DEBITO
		nCredito	:= SLDTOTCT4->CREDIT
	
		nAtuDeb := nAntDeb + nDebito
		nAtuCrd := nAntCrd + nCredito
			
		nSaldoAtu := nAtuCrd - nAtuDeb
		nSaldoAnt := nAntCrd - nAntDeb		
	Else
#ENDIF

dbSelectArea("CT4")
dbSetOrder(1)
If cFilEsp == Nil
	MsSeek(xFilial("CT4")+cMoeda+cTpSald+cContaIni,.T.) // Posiciona na primeira conta
	bCondFil	:= { || CT4_FILIAL == xFilial("CT4") }
Else
	MsSeek(cFilEsp+cMoeda+cTpSald+cContaIni,.T.) // Posiciona na primeira conta
	bCondFil	:= { || CT4_FILIAL == cFilEsp }	
EndIf 

// Processa todas as Contas do intervalo
While !Eof() .And. ;
		Eval(bCondFil)  .And.;
		CT4->CT4_MOEDA  == cMoeda    .And.;
		CT4->CT4_TPSALD == cTpSald   .And.;
		CT4->CT4_CONTA  <= cContaFim
		
	// Armazena a Conta atual para ir para a proximo Conta
	cConta := CT4->(CT4_FILIAL+CT4_MOEDA+CT4_TpSald+CT4_CONTA)
	
	// Dentro da mesma CONTA, processa os CC do intervalo
	CT4->(MsSeek(cConta+cCusIni,.T.))
	
	// Processa todos os CC do intervalo
	While !Eof() 					  .And.;
			CT4->CT4_FILIAL +;
			CT4->CT4_MOEDA  +;
			CT4->CT4_TPSALD +;
			CT4->CT4_CONTA  == cConta .And.;
			CT4->CT4_CUSTO  <= cCusFim
			
		// Armazena o centro de custo atual para ir para o proximo CC
		cCC := CT4->(CT4_FILIAL+CT4_MOEDA+CT4_TpSald+CT4_CONTA+CT4_CUSTO)
		
		// Dentro da mesma CONTA+CC, processa os items do intervalo
		CT4->(MsSeek(cCC+cItemIni,.T.))
		
		// Processa todos os Items do intervalo
		While !Eof() 			  .And.;
				CT4->CT4_FILIAL +;
				CT4->CT4_MOEDA  +;
				CT4->CT4_TPSALD +;
				CT4->CT4_CONTA  +;
				CT4->CT4_CUSTO  == cCC .And.;
				CT4->CT4_ITEM   <= cItemFim
				
			// Armazena o Item atual para ir para o proximo Item
			cItem := CT4->(CT4_FILIAL+CT4_MOEDA+CT4_TpSald+CT4_CONTA+CT4_CUSTO+CT4_ITEM)
		
			// Dentro da mesma conta, do mesmo centro de custo, do mesmo item, 
			// pesquisa o primeiro saldo anterior ou igual a data solicitada
			lNaoAchei := .F.
			If ! CT4->(MsSeek(cItem+DTOS(dData),.T.))
				CT4->(DbSkip(-1))
				lNaoAchei := .T.
			Endif
		
			// Contabiliza os saldos das contas, dos centros de custo e dos
			// Items solicitados na data solicitada.
			IF CT4->(!Eof()) 					  .And.;
				CT4->CT4_FILIAL +;
				CT4->CT4_MOEDA  +;
				CT4->CT4_TPSALD +;
				CT4->CT4_CONTA  +;
				CT4->CT4_CUSTO  +;
				CT4->CT4_ITEM   == cItem  .And.;
				CT4->CT4_DATA   <= dData
				
				// Movimentacao da data
				If CT4->CT4_DATA == dData
					nDebito	+= CT4->CT4_DEBITO
					nCredito	+= CT4->CT4_CREDITO
				Endif
				nAtuDeb	  += CT4->CT4_ATUDEB
				nAtuCrd   += CT4->CT4_ATUCRD
				nVlDebAtu := CT4->CT4_ATUDEB
				nVlCrdAtu := CT4->CT4_ATUCRD		
				
				If lNaoAchei
					// Neste caso, como a data nao foi encontrada, considera-se como saldo anterior
					// o saldo atual do registro anterior! -> dbskip(-1)
					nAntDeb  += CT4->CT4_ATUDEB
					nAntCrd  += CT4->CT4_ATUCRD
					nVlDebAnt := CT4->CT4_ATUDEB
					nVlCrdAnt := CT4->CT4_ATUCRD							
				Else		
					nAntDeb  += CT4->CT4_ANTDEB
					nAntCrd  += CT4->CT4_ANTCRD
					nVlDebAnt := CT4->CT4_ANTDEB
					nVlCrdAnt := CT4->CT4_ANTCRD															
				Endif
				nSaldoAtu	+= (nVlCrdAtu - nVlDebAtu)
				nSaldoAnt	+= (nVLCrdAnt - nVlDebAnt)						
			Endif
			// Vai para o proximo Item
			CT4->(MsSeek(IncLast(cItem),.T.))
		Enddo
		// Vai para o proximo Centro de custo
		CT4->(MsSeek(IncLast(cCC),.T.))
	Enddo
	// Vai para a proxima conta
	CT4->(MsSeek(IncLast(cConta),.T.))
Enddo

#IFDEF TOP
	EndIf
#ENDIF

CT4->(RestArea(aSaveArea))
RestArea(aSaveAnt)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//      [1]       [2]     [3]      [4]     [5]     [6]       [7]     [8]
Return {nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}
                   
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³SaldtotCTI ³ Autor ³ Pilar S. Albaladejo 			   ³ Data ³ 27/11/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna os saldos do intervalo de conta,item,c.custo e classe de valor ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³SaldtotCTI(cClasseIni,cClasseFim,cItemIni,cItemFim,cCusIni,cCusFim, 	 ³±±
±±³       	 ³cContaini,cContaFim,dData,cMoeda,cTpSald)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												 			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Cl.Valor Inicial                 				 			 ³±±
±±³		     ³ ExpC2 = Cl.Valor Final                   				 			 ³±±
±±³          ³ ExpC3 = Item Inicial                     				 			 ³±±
±±³		     ³ ExpC4 = Item Final                       				 			 ³±±
±±³          ³ ExpC1 = Centro de Custo Inicial          				 			 ³±±
±±³          ³ ExpC2 = Centro de Custo Final            				 			 ³±±
±±³          ³ ExpC5 = Conta Final                      				 			 ³±±
±±³          ³ ExpC6 = Conta Final                      				 			 ³±±
±±³          ³ ExpD1 = Data                              			 				 ³±±
±±³          ³ ExpC7 = Moeda                            				 			 ³±±
±±³          ³ ExpC8 = Tipo de Saldo                       				 			 ³±±
±±³          ³ ExpC9 = Filial Especifica                   				 			 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SaldTotCTI(cClasseIni,cClasseFim,cItemIni,cItemFim,cCusIni,cCusFim,;
						cContaIni,cContaFim,dData,cMoeda,cTpSald,cFilEsp)

Local aSaveArea	:= CTI->(GetArea())
Local aSaveAnt	:= GetArea()
Local lNaoAchei	:= .F.
Local nDebito	:= 0					// Valor Debito na Data
Local nCredito 	:= 0					// Valor Credito na Data
Local nAtuDeb  	:= 0					// Saldo Atual Devedor
Local nAtuCrd	:= 0					// Saldo Atual Credor
Local nVlDebAtu := 0					// Valor do Debito Atual
Local nVlCrdAtu := 0                    // Valor do Credito Atual
Local nVlDebAnt := 0					// Valor do Debito Anterior
Local nVlCrdAnt := 0                    // Valor do Credito Anterior
Local nAntDeb	:= 0					// Saldo Anterior Devedor
Local nAntCrd	:= 0					// Saldo Anterior Credor
Local nSaldoAnt	:= 0					// Saldo Anterior (com sinal)
Local nSaldoAtu	:= 0					// Saldo Atual (com sinal)
Local cCC
Local cConta
Local cItem
Local cClasseVlr

cTpSald := Iif(Empty(cTpSald),"1",cTpSald)

#IFDEF TOP
	If TcGetDb() <> "AS/400"
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Query Sld Anterior³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cQuery := " SELECT SUM(CTI_DEBITO) SLDANTDB, SUM(CTI_CREDIT) SLDANTCR "
		cQuery += " FROM "+RetSqlName("CTI")
		If cFilEsp == Nil
			cQuery += " WHERE CTI_FILIAL = '"+xFilial("CTI")+"' "
		Else
			cQuery += " WHERE CTI_FILIAL = '"+cFilEsp+"' "
		Endif
		cQuery += " AND CTI_CONTA >= '"+cContaIni+"' "
		cQuery += " AND CTI_CONTA <= '"+cContaFim+"' "
		cQuery += " AND CTI_CUSTO >= '"+cCusIni+"' "
		cQuery += " AND CTI_CUSTO <= '"+cCusFim+"' "
		cQuery += " AND CTI_ITEM  >= '"+cItemIni+"' "
		cQuery += " AND CTI_ITEM  <= '"+cItemFim+"' "
		cQuery += " AND CTI_CLVL  >= '"+cClasseIni+"' "
		cQuery += " AND CTI_CLVL  <= '"+cClasseFim+"' "
		cQuery += " AND CTI_MOEDA = '"+cMoeda+"' "
		cQuery += " AND CTI_TPSALD = '"+cTpSald+"' "
		cQuery += " AND CTI_DATA < '"+DTOS(dData)+"' "
		/*If lImpAntLP
			cQuery += "  AND (CTI_LP <> 'Z' OR (CTI_LP = 'Z' AND CTI_DTLP < '"+dDataLP+"')) "
		Endif*/
		cQuery += " 	 AND D_E_L_E_T_ <> '*' "
        
		cQuery := ChangeQuery(cQuery)				
		If Select("SLDTOTCTI") > 0
			dbSelectArea("SLDTOTCTI")
			SLDTOTCTI->(dbCloseArea())
		Endif
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SLDTOTCTI",.T.,.F.)		
		
		TcSetField("SLDTOTCTI","SLDANTDB"  ,"N",__aTamVlr[1],__aTamVlr[2])	
		TcSetField("SLDTOTCTI","SLDANTCR"  ,"N",__aTamVlr[1],__aTamVlr[2])			
		
		dbSelectArea("SLDTOTCTI")
		dbGoTop()
        
		nAntDeb 	:= SLDTOTCTI->SLDANTDB
		nAntCrd 	:= SLDTOTCTI->SLDANTCR
       
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Query Mov. no Dia³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                      
		cQuery := " SELECT SUM(CTI_DEBITO) DEBITO, SUM(CTI_CREDIT) CREDIT  "
		cQuery += " FROM "+RetSqlName("CTI")
		If cFilEsp == Nil
			cQuery += " WHERE CTI_FILIAL = '"+xFilial("CTI")+"' "
		Else
			cQuery += " WHERE CTI_FILIAL = '"+cFilEsp+"' "
		Endif
		cQuery += " AND CTI_CONTA >= '"+cContaIni+"' "
		cQuery += " AND CTI_CONTA <= '"+cContaFim+"' "
		cQuery += " AND CTI_CUSTO >= '"+cCusIni+"' "
		cQuery += " AND CTI_CUSTO <= '"+cCusFim+"' "
		cQuery += " AND CTI_ITEM  >= '"+cItemIni+"' "
		cQuery += " AND CTI_ITEM  <= '"+cItemFim+"' "
		cQuery += " AND CTI_CLVL  >= '"+cClasseIni+"' "
		cQuery += " AND CTI_CLVL  <= '"+cClasseFim+"' "
		cQuery += " AND CTI_MOEDA = '"+cMoeda+"' "
		cQuery += " AND CTI_TPSALD = '"+cTpSald+"' "
		cQuery += " AND CTI_DATA = '"+DTOS(dData)+"' "
		/*If lImpAntLP
			cQuery += "  AND (CTI_LP <> 'Z' OR (CTI_LP = 'Z' AND CTI_DTLP < '"+dDataLP+"')) "
		Endif*/
		cQuery += " 	 AND D_E_L_E_T_ <> '*' "

		cQuery := ChangeQuery(cQuery)				
		If Select("SLDTOTCTI") > 0
			dbSelectArea("SLDTOTCTI")
			SLDTOTCTI->(dbCloseArea())
		Endif
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SLDTOTCTI",.T.,.F.)		
		
		TcSetField("SLDTOTCTI","DEBITO"  ,"N",__aTamVlr[1],__aTamVlr[2])	
		TcSetField("SLDTOTCTI","CREDIT"  ,"N",__aTamVlr[1],__aTamVlr[2])			
	
		dbSelectArea("SLDTOTCTI")
		dbGoTop()
		
		// Movimentacao da data
		nDebito		:= SLDTOTCTI->DEBITO
		nCredito	:= SLDTOTCTI->CREDIT
	
		nAtuDeb := nAntDeb + nDebito
		nAtuCrd := nAntCrd + nCredito
			
		nSaldoAtu := nAtuCrd - nAtuDeb
		nSaldoAnt := nAntCrd - nAntDeb		
	Else
#ENDIF

dbSelectArea("CTI")
dbSetOrder(1)
If cFilEsp == Nil
	MsSeek(xFilial("CTI")+cMoeda+cTpSald+cContaIni,.T.) // Posiciona na primeira conta
	bCondFil	:= { || CTI_FILIAL == xFilial("CTI") }
Else
	MsSeek(cFilEsp+cMoeda+cTpSald+cContaIni,.T.) // Posiciona na primeira conta
	bCondFil	:= { || CTI_FILIAL == cFilEsp }	
EndIf 

// Processa todas as Contas do intervalo
While !Eof() .And. ;
		Eval(bCondFil) .And.;
		CTI->CTI_MOEDA  == cMoeda    .And.;
		CTI->CTI_TPSALD == cTpSald   .And.;
		CTI->CTI_CONTA  <= cContaFim
		
	// Armazena a Conta atual para ir para a proxima Conta
	cConta := CTI->(CTI_FILIAL+CTI_MOEDA+CTI_TpSald+CTI_CONTA)	
	
	// Dentro da mesma Conta, processa os CC do intervalo
	CTI->(MsSeek(cConta+cCusIni,.T.))
	
	// Processa todos os CC do intervalo
	While !Eof() 							  .And.;
			CTI->CTI_FILIAL +;
			CTI->CTI_MOEDA  +;
			CTI->CTI_TPSALD +;
			CTI->CTI_CONTA  == cConta .And. ;
			CTI->CTI_CUSTO  <= cCusFim   
			
		// Armazena o centro de custo atual para ir para o proximo CC
		cCC := CTI->(CTI_FILIAL+CTI_MOEDA+CTI_TpSald+CTI_CONTA+CTI_CUSTO)
		
		// Dentro da mesma CONTA+CC, processa os items do intervalo
		CTI->(MsSeek(cCC+cItemIni,.T.))
		
		// Processa todos os Items do intervalo
		While !Eof() 							  .And.;
				CTI->CTI_FILIAL +;
				CTI->CTI_MOEDA  +;
				CTI->CTI_TPSALD +;
				CTI->CTI_CONTA  +;
				CTI->CTI_CUSTO  == cCC   .And.;
				CTI->CTI_ITEM   <= cItemFim
				
			// Armazena o Item atual para ir para o proximo Item
			cItem := CTI->(CTI_FILIAL+CTI_MOEDA+CTI_TpSald+CTI_CONTA+;
								CTI_CUSTO+CTI_ITEM)
		
			// Dentro da mesma CONTA+CC+ITEM, processa as Classes do intervalo
			CTI->(MsSeek(cItem+cClasseIni,.T.))
				
			// Processa todas as Classes do intervalo
			While !Eof() 							  .And.;
					CTI->CTI_FILIAL +;
					CTI->CTI_MOEDA  +;
					CTI->CTI_TPSALD +;
					CTI->CTI_CONTA  +;
					CTI->CTI_CUSTO  +;
					CTI->CTI_ITEM   == cItem .And.;
					CTI->CTI_CLVL   <= cClasseFim
			
				// Armazena a Classe atual para ir para a proxima Classe
				cClasseVlr := CTI->(CTI_FILIAL+CTI_MOEDA+CTI_TpSald+CTI_CONTA+;
										  CTI_CUSTO+CTI_ITEM+CTI_CLVL)
		
				// Dentro da mesma conta, do mesmo centro de custo, do mesmo item, 
				// da mesma classe de valor, pesquisa o primeiro saldo anterior ou 
				// igual a data solicitada
				lNaoAchei := .F.
				If ! CTI->(MsSeek(cClasseVlr+DTOS(dData),.T.))
					CTI->(DbSkip(-1))
					lNaoAchei := .T.
				Endif
		
				// Contabiliza os saldos das contas, dos centros de custo, dos
				// Items e das Classes de Valores solicitados na data solicitada
				IF CTI->(!Eof()) 				  .And.;
					CTI->CTI_FILIAL +;
					CTI->CTI_MOEDA  +;
					CTI->CTI_TPSALD +;
					CTI->CTI_CONTA  +;
					CTI->CTI_CUSTO  +;
					CTI->CTI_ITEM   +;
					CTI->CTI_CLVL   == cClasseVlr .And. ;
					CTI->CTI_DATA   <= dData
				
					// Movimentacao da data
					If CTI->CTI_DATA == dData
						nDebito	+= CTI->CTI_DEBITO
						nCredito	+= CTI->CTI_CREDITO
					Endif
					nAtuDeb	  += CTI->CTI_ATUDEB
					nAtuCrd   += CTI->CTI_ATUCRD
					nVlDebAtu := CTI->CTI_ATUDEB
					nVlCrdAtu := CTI->CTI_ATUCRD							
					
					If lNaoAchei
						// Neste caso, como a data nao foi encontrada, considera-se como saldo anterior
						// o saldo atual do registro anterior! -> dbskip(-1)
						nAntDeb   += CTI->CTI_ATUDEB
						nAntCrd   += CTI->CTI_ATUCRD
						nVlDebAnt := CTI->CTI_ATUDEB
						nVlCrdAnt := CTI->CTI_ATUCRD
					Else		
						nAntDeb  += CTI->CTI_ANTDEB
						nAntCrd  += CTI->CTI_ANTCRD
						nVlDebAnt := CTI->CTI_ANTDEB
						nVlCrdAnt := CTI->CTI_ANTCRD
					Endif
					nSaldoAtu	+= (nVlCrdAtu - nVlDebAtu)
					nSaldoAnt	+= (nVLCrdAnt - nVlDebAnt)							
				Endif
				// Vai para a proxima Classe de Valor
				CTI->(MsSeek(IncLast(cClasseVlr),.T.))
			EndDo	
			// Vai para o proximo Item
			CTI->(MsSeek(IncLast(cItem),.T.))
		EndDo
		// Vai para o proximo Centro de custo
		CTI->(MsSeek(IncLast(cCC),.T.))
	EndDo
	// Vai para a proxima conta
	CTI->(MsSeek(IncLast(cConta),.T.))
Enddo

#IFDEF TOP
	Endif
#ENDIF

CTI->(RestArea(aSaveArea))
RestArea(aSaveAnt)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//      [1]       [2]     [3]      [4]     [5]     [6]       [7]     [8]
Return {nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³IncLast    ³ Autor ³ Claudio Donizete    			   ³ Data ³ 27/11/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Soma um no ultimo byte de uma string, normalmente para ser utilizado  ³±±
±±³			 ³ em pesquisas com softseek on, para posicionar no	ultimo registro + 1	 ³±±
±±³          ³de uma chave.															 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³IncLast(cString)                                                    	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³LEFT(cString, LEN(cString)-1)+ CHR(ASC(RIGHT(cString,1))+1) 			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												 			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = String a ser pesquisada          				 			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observ.   ³  Ex.:																 ³±±
±±³			 ³	// cChave := "CLAUDIO"											     ³±±
±±³			 ³	// MsSeek(IncLast(cChave)),.T.) // MsSeek("CLAUDIP")				 ³±±
±±³			 ³	// Se na base tiver:												 ³±±
±±³			 ³	// CLAUDIO <-- Ponteiro atual    (1)                                 ³±±
±±³			 ³	// CLAUDIO															 ³±±
±±³			 ³	// CLAUDIO															 ³±±
±±³			 ³	// CLAUDIO															 ³±±
±±³			 ³	// DANIELA <-- Apos o MsSeek     (2)								 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION IncLast( cString )
RETURN LEFT(cString, LEN(cString)-1)+;
       CHR(ASC(RIGHT(cString,1))+1)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³CtbPeriodos³ Autor ³ Pilar S. Albaladejo 			   ³ Data ³ 27/11/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna os periodos para a moeda.                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³CtbPeriodos(cMoeda,dDtIni,dDtFim,lExercicio,lZeradas)                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³aRet                                                        			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												 			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Moeda                            				 			 ³±±
±±³			 ³ ExpD1 = Data Inicial													 ³±±
±±³			 ³ ExpD2 = Data Final  													 ³±±
±±³			 ³ ExpL1 = Indica se a verificacao do periodo deve ser por exercicio     ³±±
±±³			 ³ ExpL2 = Indica se a existirem calendarios fora da data solicita       ³±±
±±³			 ³         Retornara matriz com informacoes em branco                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION CtbPeriodos( cMoeda, dDtIni, dDtFim, lExercicio, lZeradas )


LOCAL aRet := {}
Local aAreaPer:= GetArea()
DEFAULT lExercicio := .F.
DEFAULT lZeradas   := .T.

dDtFim := Iif(Empty(dDtFim),dDtIni,dDtFim)

// Localiza a moeda 
dbSelectArea("CTO")
dbSetOrder(1)
If MsSeek(xFilial("CTO")+cMoeda)
	dbSelectArea("CTE")
	dbSetOrder(1)    
	If MsSeek(xFilial()+cMoeda)
		While !Eof() .And. CTE_FILIAL == xFilial() .And. CTE->CTE_MOEDA == cMoeda
			// Localiza os periodos para a moeda
			dbSelectArea("CTG")
			dbSetOrder(1)
			MsSeek(xFilial()+CTE->CTE_CALEND)
			While 	CTG->(!Eof()) 							.AND.;
					CTG->CTG_FILIAL == xFilial("CTG") 		.AND.;
					CTG->CTG_CALEND == CTE->CTE_CALEND
	         // Se estiver dentro do periodo solicitado
				If 	If(lExercicio,  Year(CTG->CTG_DTFIM) <= Year(dDtFim) .And.;
									Year(CTG->CTG_DTINI) >= Year(dDtIni),;
					CTG->CTG_DTINI <= dDtIni .AND.;
					CTG->CTG_DTFIM >= dDtFim)
					// Adiciona os periodos na matriz de retorno
					Aadd( aRet, { 	CTG->CTG_DTINI, CTG->CTG_DTFIM,;
									CTG->CTG_EXERC, CTG->CTG_STATUS } )
				ElseIf lZeradas
					Aadd( aRet, {	CTOD("  /  /  "), CTOD("  /  /  "), Space(4), " " })
				Endif					  
				dbSkip()
			EndDo
			dbSelectArea("CTE")
			dbSkip()
		EndDo	
		If Len(aRet) = 0
			Aadd( aRet, {	CTOD("  /  /  "), CTOD("  /  /  "), Space(4), " " })
		Endif			
	Else
		Aadd( aRet, {	CTOD("  /  /  "), CTOD("  /  /  "), Space(4), " " })
	EndIf
Else                                                                         
	Aadd( aRet, {	CTOD("  /  /  "), CTOD("  /  /  "), Space(4), " " })
EndIf	

RestArea(aAreaPer)
RETURN aRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³CtbDsGrava ³ Autor ³ Pilar S. Albaladejo 			   ³ Data ³ 27/11/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Desgravacao de Saldos                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³CtbDsGrava(cLote,cSubLote,cDoc,dData,cTipo,cMoeda,cDebito,cCredito, 	 ³±±
±±³       	 ³cCustoDeb,cCustoCrd,cItemDeb,cItemCrd,cClVlDeb,cClVlCrd,nValor,cTpSald,³±±
±±³       	 ³nOpc,cDebitoAnt,cCreditoAnt,cCustoDAnt,cCustoCAnt,cItemDAnt,cItemCAnt, ³±±
±±³       	 ³cCLVLDAnt,cCLVLCant,nValorAnt,cTipoant,cTpSaldAnt,cMoedaAnt,lCusto,	 ³±±
±±³       	 ³lItem,lClVl,nTotInf)                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³Nenhum                                                      			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												 			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Lote                             				 			 ³±±
±±³			 ³ ExpC2 = SubLote     													 ³±±
±±³			 ³ ExpC3 = Documento   													 ³±±
±±³			 ³ ExpD1 = Data        													 ³±±
±±³			 ³ ExpC4 = Tipo do lancamento											 ³±±
±±³			 ³ ExpC5 = Moeda              											 ³±±
±±³			 ³ ExpC6 = Conta debito        											 ³±±
±±³			 ³ ExpC7 = Conta credito       											 ³±±
±±³			 ³ ExpC8 = Centro de custo debito										 ³±±
±±³			 ³ ExpC9 = Centro de custo credito										 ³±±
±±³			 ³ ExpC10= Item Debito             										 ³±±
±±³			 ³ ExpC11= Item Credito            										 ³±±
±±³			 ³ ExpC12= Classe de Valor Debito  										 ³±±
±±³			 ³ ExpC13= Classe de Valor Credito 										 ³±±
±±³			 ³ ExpN1 = Valor														 ³±±
±±³			 ³ ExpC14= Tipo de Saldo           										 ³±±
±±³			 ³ ExpN2 = Numero da Opcao escolhida					   				 ³±±
±±³			 ³ ExpC15= Conta debito anterior										 ³±±
±±³			 ³ ExpC16= Conta credito anterior										 ³±±
±±³			 ³ ExpC17= Centro de custo debito anterior								 ³±±
±±³			 ³ ExpC18= Centro de custo credito	anterior							 ³±±
±±³			 ³ ExpC19= Item Debito anterior    										 ³±±
±±³			 ³ ExpC20= Item Credito anterior   										 ³±±
±±³			 ³ ExpC21= Classe de Valor Debito anterior								 ³±±
±±³			 ³ ExpC22= Classe de Valor Credito anterior								 ³±±
±±³			 ³ ExpN3 = Valor anterior												 ³±±
±±³			 ³ ExpC22= Tipo de lancamento anterior									 ³±±
±±³			 ³ ExpC23= Tipo de Saldo anterior  										 ³±±
±±³			 ³ ExpC24= Moeda Anterior          										 ³±±
±±³			 ³ ExpL1 = Indica se atualiza centro de custo							 ³±±
±±³			 ³ ExpL2 = Indica se atualiza item               						 ³±±
±±³			 ³ ExpL3 = Indica se atualiza classe de valor							 ³±±
±±³			 ³ ExpN4 = Valor Total informado              							 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbDSGrava(cLote,cSubLote,cDoc,dData,cTipo,cMoeda,cDebito,;
					cCredito,cCustoDeb,cCustoCrd,cItemDeb,cItemCrd,;
					cClVlDeb,cClVlCrd,nValor,cTpSald,nOpc,cDebitoAnt,;
					cCreditoAnt,cCustoDAnt,cCustoCAnt,cItemDAnt,;
					cItemCAnt,cCLVLDAnt,cCLVLCAnt,nValorAnt,;
					cTipoAnt,cTpSaldAnt,cMoedaAnt,lCusto,lItem,lClVL,nTotInf,;
					lReproc,lAtSldBase,dDataLP,lGrvCT7,lGrvCT3,lGrvCT4,lGrvCTI,;
					lAtuSldCT7,lAtuSldCT3,lAtuSldCT4,lAtuSldCTI)
					
Local lAltDeb		:= .F.
Local lAltCrd		:= .F.
Local lAltValor 	:= .F.
Local lAltTpSald	:= .F.
Local lAltMoeda		:= .F.
Local lPartDob		:= .F. 
Local cChave		:= ""    
lAtSldBase 			:= Iif(lAtSldBase==Nil,.T.,lAtSldBase)                                                                               
lReproc				:= Iif(lAtSldBase,.F.,.T.)
dDataLP				:= Iif(dDataLP ==Nil,CTOD("  /  /  "),dDataLP)

DEFAULT lGrvCT7	:= .F.
DEFAULT lGrvCT3	:= .F.
DEFAULT lGrvCT4	:= .F.
DEFAULT lGrvCTI	:= .F.
DEFAULT lAtuSldCT7	:= .T.
DEFAULT lAtuSLdCT3	:= .T.
DEFAULT lAtuSldCT4	:= .T.
DEFAULT lAtuSldCTI	:= .T.

// Garanto que as variaveis tenha o mesmo conteudo caso em branco
// Para evitar processamento desnecessarios

If Empty(cDebitoAnt)
	cDebitoAnt := cDebito
Endif
If Empty(cCreditoAnt)
	cCreditoAnt := cCredito
Endif
If Empty(cCustoDAnt)
	cCustoDAnt := cCustoDeb
Endif
If Empty(cCustoCAnt)
	cCustoCAnt := cCustoCrd
Endif
If Empty(cItemDAnt)
	cItemDAnt := cItemDeb
Endif
If Empty(cItemCAnt)
	cItemCAnt := cItemCrd
Endif
If Empty(cCLVLDAnt)
	cCLVLDAnt := cClVlDeb
Endif
If Empty(cCLVLCAnt)
	cCLVLCAnt := cClVlCrd
Endif

// Verifica o que ira descalcular - comparando variaveis que irão afetar a gravação do
// saldo -> Tipo Lcto, Valor, Tipo do Saldo, Moeda do Lcto
If nOpc == 4 .Or. nOpc == 6
	CtbOQMudou(@lAltDeb,@lAltCrd,@lAltValor,@lAltTpSald,@lAltMoeda,;
					cTipo,cTipoAnt,nValor,nValorAnt,cTpSald,cTpSaldAnt,cMoeda,;
					cMoedaAnt,"D")
EndIf
If cTipoAnt == '3'
	lPartDob	:= .T.
Else
	lPartDob	:= .F.
EndIf	


// Desgravacao de Saldos de Lote
If ((lAltDeb .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda .Or. cTipo <> cTipoAnt) .Or. nOpc == 5) ;
	.And. cTipoAnt $ '1/3'
	DsGravaCT6(cLote,cSubLote,"1",dData,cMoedaAnt,nValorAnt,cTpSaldAnt,lPartDob)
EndIf
If ((lAltCrd .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda .Or. cTipo <> cTipoAnt) .Or. nOpc == 5) ;
	.And. cTipoAnt $ '2/3'
	DsGravaCT6(cLote,cSubLote,"2",dData,cMoedaAnt,nValorAnt,cTpSaldAnt,lPartDob)
EndIf

// Desgravacao de Saldos de Documento
If ((lAltDeb .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda .Or. cTipo <> cTipoAnt) .Or. nOpc == 5)  ;
	.And. cTipoAnt $ '1/3'
	DsGravaCTC(cLote,cSubLote,cDoc,"1",dData,cMoedaAnt,nValorAnt,cTpSaldAnt,lPartDob)
EndIF	
If ((lAltCrd .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda .Or. cTipo <> cTipoAnt) .Or. nOpc == 5) ;
	.And. cTipoAnt $ '2/3'
	DsGravaCTC(cLote,cSubLote,cDoc,"2",dData,cMoedaAnt,nValorAnt,cTpSaldAnt,lPartDob)
EndIF	
					
// DesGravacao de Saldos de Contas
If lAtuSldCT7
	If (cDebitoAnt != cDebito .Or. ;
		lAltDeb .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5
		DSGravaCT7(cDebitoAnt,"1",dData,cMoedaAnt,nValorAnt,cTpSaldAnt,lReproc,lAtSldBase,dDataLP,nOpc)	
	EndIf
	If (cCreditoAnt != cCredito .Or.;
		 lAltCrd .Or. lAltValor .Or. lAltTpSald .Or.lAltMoeda) .Or. nOpc == 5
		DSGravaCT7(cCreditoAnt,"2",dData,cMoedaAnt,nValorAnt,cTpSaldAnt,lReproc,lAtSldBase,dDataLP,nOpc)
	EndIf
EndIf

	// DesGravacao de Saldos de Centro de Custo
If lCusto .And. lAtuSldCT3
	If (cDebitoAnt != cDebito .Or. cCustoDAnt != cCustoDeb .Or.;
		lAltDeb .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5
		DSGravaCT3(cDebitoAnt,cCustoDAnt,"1",dData,cMoedaAnt,nValorAnt,cTpSaldAnt,lReproc,lAtSldBase,dDataLP,nOpc)
		
    	//So ira atualizar o flag de saldos compostos se nao existir nenhum dos pontos de entrada de atualizacao de 
    	//saldos.
		If !lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI		
			//Atualiza Flag de Saldos Compostos do Centro de Custo Debito                       		
			If (cCustoDAnt	!= cCustoDeb .Or. ;
				lAltValor .Or. lAltTpSald .Or. lAltmoeda) .Or. nOpc == 5
				cChave	:= "CTT"+cMoedaAnt+cTpSaldAnt+cCustoDant+DTOS(dData)
				FlgSldComp("CTU",cChave)		
				#IFNDEF TOP	//Se for codebase atualiza o flag do CT2
					AtuFlgCmp(dData,"CTT",cCustoDAnt,cMoedaAnt,cTpSaldAnt)
				#ENDIF
			EndIf
		EndIf		
		
	EndIf
	If (cCreditoAnt != cCredito .Or. cCustoCAnt != cCustoCrd .Or.;
		lAltCrd .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5
		DSGravaCT3(cCreditoAnt,cCustoCAnt,"2",dData,cMoedaAnt,nValorAnt,cTpSaldAnt,lReproc,lAtSldBase,dDataLP,nOpc)
		//So ira atualizar o flag de saldos compostos se nao existir nenhum dos pontos de entrada de atualizacao de 
    	//saldos.
		If !lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI		
			//Atualiza Flag de Saldos Compostos do Centro de Custo Credito		
			If (cCustoCAnt	!= cCustoCrd .Or.; 
				lAltValor .Or. lAltTpSald .Or. lAltMoeda).Or. nOpc == 5
				cChave	:= "CTT"+cMoedaAnt+cTpSaldAnt+cCustoCant+DTOS(dData)
				FlgSldComp("CTU",cChave)				
				#IFNDEF TOP	//Se for codebase atualiza o flag do CT2
					AtuFlgCmp(dData,"CTT",cCustoCAnt,cMoedaAnt,cTpSaldAnt)
				#ENDIF
			EndIf
		EndIf
		
	EndIf              	
EndIf

If lItem .And. lAtuSldCT4
	// DesGravacao de Saldos de Item Contabil
	If nOpc == 4 .Or. nOpc == 5
		If (cDebitoAnt != cDebito .Or. cCustoDAnt != cCustoDeb .Or.;
			cItemDAnt != cItemDeb .Or. ;
			lAltDeb .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5
			DSGravaCT4(cDebitoAnt,cCustoDAnt,cItemDAnt,"1",dData,cMoedaAnt,nValorAnt,cTpSaldAnt,lReproc,lAtSldBase,dDataLP,nOpc)
			
			//So ira atualizar o flag de saldos compostos se nao existir nenhum dos pontos de entrada de atualizacao de 
			//saldos.
			
			If !lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI			
				//Atualiza Flag de Saldos Compostos do Item Debito
				If (cItemDAnt != cItemDeb .Or. ;
					lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5
					cChave	:= "CTD"+cMoedaAnt+cTpSaldAnt+cItemDAnt+DTOS(dData)
					FlgSldComp("CTU",cChave)		   
					#IFNDEF TOP	//Se for codebase atualiza o flag do CT2
						AtuFlgCmp(dData,"CTD",cItemDAnt,cMoedaAnt,cTpSaldAnt)						
					#ENDIF
				EndIf
			
				//Atualiza Flag de Saldos Compostos Item/C.Custo Debito
				If (cItemDAnt != cItemDeb .Or. cCustoDAnt != cCustoDeb .Or. ;
					lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5			
					cChave	:= cMoedaAnt+cTpSaldAnt+cItemDAnt+cCustoDAnt+DTOS(dData)
					FlgSldComp("CTV",cChave)				
				EndIf													
			EndIf                                       

		EndIf               		
		
		If (cCreditoAnt != cCredito .Or. cCustoCAnt != cCustoCrd .Or.;
			cItemCAnt != cItemCrd .Or.;
			lAltCrd .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5
			DSGravaCT4(cCreditoAnt,cCustoCAnt,cItemCAnt,"2",dData,cMoedaAnt,nValorAnt,cTpSaldAnt,lReproc,lAtSldBase,dDataLP,nOpc)
    		//So ira atualizar o flag de saldos compostos se nao existir nenhum dos pontos de entrada de atualizacao de 
    		//saldos.
    		
			If !lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI			
				//Atualiza Flag de Saldos Compostos do Item Credito			
				If (cItemCAnt != cItemCrd .Or. ;                                      
					lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5						
					cChave	:= "CTD"+cMoedaAnt+cTpSaldAnt+cItemCAnt+DTOS(dData)
					FlgSldComp("CTU",cChave)				            
					#IFNDEF TOP		//Se for codebase atualiza o flag do CT2
						AtuFlgCmp(dData,"CTD",cItemCAnt,cMoedaAnt,cTpSaldAnt)										
					#ENDIF
				EndIf			
				//Atualiza Flag de Saldos Compostos Item/C.Custo Credito			
				If (cItemCAnt != cItemCrd .Or. cCustoCAnt != cCustoCrd .Or.;
					lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5			
					cChave	:= cMoedaAnt+cTpSaldAnt+cItemCAnt+cCustoCAnt+DTOS(dData)
					FlgSldComp("CTV",cChave)				
				EndIf		
			EndIf
			
		EndIf		
	EndIf
EndIf

If lCLVL .And. lAtuSldCTI
	// Desgravacao dos Saldos da Classe de Valor
	If (cDebitoAnt != cDebito .Or. cCustoDAnt != cCustoDeb .Or.;
		cItemDAnt != cItemDeb .Or. cCLVLDAnt != cCLVLDeb .Or.;
		lAltDeb .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5
		DSGravaCTI(cDebitoAnt,cCustoDAnt,cItemDAnt,cCLVLDAnt,"1",dData,cMoedaAnt,nValorAnt,cTpSaldAnt,lReproc,lAtSldBase,dDataLP,nOpc)
		
		//So ira atualizar o flag de saldos compostos se nao existir nenhum dos pontos de entrada de atualizacao de 
    	//saldos.
		If !lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI
			
			//Atualiza Flag de Saldos Compostos da Clsse de Valor Debito
			If (cCLVLDAnt != cCLVLDeb .Or. ;
	   		   lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5					
				cChave	:= "CTH"+cMoedaAnt+cTpSaldAnt+cCLVLDAnt+DTOS(dData)
				FlgSldComp("CTU",cChave)		
				#IFNDEF TOP
					AtuFlgCmp(dData,"CTH",cCLVLDAnt,cMoedaAnt,cTpSaldAnt)											
				#ENDIF
			EndIf
			
			//Atualiza Flag de Saldos Compostos CL.Valor/C.Custo Debito
			If (cCLVLDAnt != cCLVLDeb .Or. cCustoDAnt != cCustoDeb .Or.;
				lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5					
				cChave	:= cMoedaAnt+cTpSaldAnt+cCLVLDAnt+cCustoDAnt+DTOS(dData)
				FlgSldComp("CTW",cChave)				
			EndIf						
		
			//Atualiza Flag de Saldos Compostos CL.Valor/Item Debito
			If (cCLVLDAnt != cCLVLDeb .Or. cItemDAnt != cItemDeb .Or. ;
				lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5					
				cChave	:= cMoedaAnt+cTpSaldAnt+cItemDAnt+cCLVLDAnt+DTOS(dData)
				FlgSldComp("CTX",cChave)				
			EndIf										
		
			//Atualiza Flag de Saldos Compostos CL.Valor/Item/C.Custo Debito
			If (cCLVLDAnt != cCLVLDeb .Or. cItemDAnt != cItemDeb .Or. ;
				cCustoDAnt != cCustoDeb .Or. ;
				lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5					
				cChave	:= cMoedaAnt+cTpSaldAnt+cCLVLDAnt+cItemDAnt+cCustoDAnt+DTOS(dData)
				FlgSldComp("CTY",cChave)				
			EndIf									
		EndIf
	EndIf
	
	If (cCreditoAnt != cCredito .Or. cCustoCAnt != cCustoCrd .Or.;
		cItemCAnt != cItemCrd .Or.cCLVLCAnt != cCLVLCrd .Or.;
		lAltCrd .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5
		DSGravaCTI(cCreditoAnt,cCustoCAnt,cItemCAnt,cCLVLCAnt,"2",dData,cMoedaAnt,nValorAnt,cTpSaldAnt,lReproc,lAtSldBase,dDataLP,nOpc)
		
		//So ira atualizar o flag de saldos compostos se nao existir nenhum dos pontos de entrada de atualizacao de 
    	//saldos.
		If !lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI
		
			//Atualiza Flag de Saldos Compostos da Clsse de Valor Credito
			If (cCLVLCAnt != cCLVLCrd .Or. ;
				lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5				
				cChave	:= "CTH"+cMoedaAnt+cTpSaldAnt+cCLVLCAnt+DTOS(dData)
				FlgSldComp("CTU",cChave)  
				#IFNDEF TOP
					AtuFlgCmp(dData,"CTH",cCLVLCAnt,cMoedaAnt,cTpSaldAnt)													
				#ENDIF
			EndIf
			
			//Atualiza Flag de Saldos Compostos CL.Valor/C.Custo Credito
			If (cCLVLCAnt != cCLVLCrd .Or. cCustoCAnt != cCustoCrd .Or. ;            
				lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5						
				cChave	:= cMoedaAnt+cTpSaldAnt+cCLVLCAnt+cCustoCAnt+DTOS(dData)
				FlgSldComp("CTW",cChave)				
			EndIf								
		
			//Atualiza Flag de Saldos Compostos CL.Valor/Item Credito
			If (cCLVLCAnt != cCLVLCrd .Or. cItemCAnt != cItemCrd .Or. ;
				lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5								
				cChave	:= cMoedaAnt+cTpSaldAnt+cItemCAnt+cCLVLCAnt+DTOS(dData)
				FlgSldComp("CTX",cChave)				
			EndIf								
		
			//Atualiza Flag de Saldos Compostos CL.Valor/Item./C.Custo Credito
			If (cCLVLCAnt != cCLVLCrd .Or. cItemCAnt != cItemCrd .Or. ;
				cCustoCAnt != cCustoCrd .Or. ;
				lAltValor .Or. lAltTpSald .Or. lAltMoeda) .Or. nOpc == 5								
				cChave	:= cMoedaAnt+cTpSaldAnt+cCLVLCAnt+cItemCAnt+cCustoCAnt+DTOS(dData)
				FlgSldComp("CTY",cChave)				
			EndIf			
		EndIf
	EndIf
EndIf	

If nTotInf <> Nil .And. nOpc = 5
	CtbGrvlInf(dData,cLote,cSubLote,cDoc,cMoeda,nTotInf,nOpc)
Endif

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³CtbOQMudou ³ Autor ³ Pilar S. Albaladejo 			   ³ Data ³ 27/11/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Verifica o que foi alterado                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³CtbOQMudou(lAltDeb,lAltCrd,lAltValor,lAltTpSald,lAltMoeda,;		 	 ³±±
±±³			 ³		cTipo,cTipoAnt,nValor,nValorAnt,cTpSald,cTpSaldAnt,cMoeda,		 ³±±
±±³			 ³		cMoedaAnt,cOperacao)											 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³Nenhum                                                      			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												 			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Indica se foi feito alguma alteracao a debito				 ³±±
±±³			 ³ ExpL2 = Indica se foi feito alguma alteracao a credito				 ³±±
±±³			 ³ ExpL3 = Indica se foi feito alguma alteracao no valor				 ³±±
±±³			 ³ ExpL4 = Indica se foi feito alguma alteracao no tipo de saldo		 ³±±
±±³			 ³ ExpL5 = Indica se foi feito alguma alteracao na moeda				 ³±±
±±³			 ³ ExpC1 = Tipo do lancamento 											 ³±±
±±³			 ³ ExpC2 = Tipo do lancamento anterior									 ³±±
±±³			 ³ ExpN1 = Valor               											 ³±±
±±³			 ³ ExpN2 = Valor anterior         										 ³±±
±±³			 ³ ExpC3 = Tipo de Saldo           									 	 ³±±
±±³			 ³ ExpC4 = Tipo de Saldo anterior  									 	 ³±±
±±³			 ³ ExpC5 = Moeda                   										 ³±±
±±³			 ³ ExpC6 = Moeda anterior          										 ³±±
±±³			 ³ ExpC7 = Alteracao efetuada no tipo do lancamento						 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbOQMudou(lAltDeb,lAltCrd,lAltValor,lAltTpSald,lAltMoeda,;
					cTipo,cTipoAnt,nValor,nValorAnt,cTpSald,cTpSaldAnt,cMoeda,cMoedaAnt,;
					cOperacao)

// Verifica o que ira descalcular
// Anterior = Debito / Atual = Credito				-> Descalcula Debito
//																-> Recalcula Credito
If cTipoAnt == "1" .And. cTipo == "2"
	If cOperacao == "D"			// Desgrava
		lAltDeb := .T.
	Else
		lAltCrd := .T.				// Regrava
	EndIf				
EndIf
// Anterior = Debito / Atual = Partida Dobrada	-> Descalcula Debito
//																-> Recalcula Credito e Debito
If cTipoAnt == "1" .And. cTipo == "3"
	If cOperacao == "D"			// Desgrava
		lAltDeb := .T.	
	Else	 							// Regrava
		lAltDeb := .T.
		lAltCrd := .T.
	EndIf			
EndIf
// Anterior = Credito / Atual = Debito 			-> Descalcula Credito
//																-> Recalcula Debito
If cTipoAnt == "2" .And. cTipo == "1"
	If cOperacao == "D"			// Desgrava
		lAltCrd := .T.
	Else
		lAltDeb := .T.				// Regrava
	EndIf		
EndIf
// Anterior = Credito / Atual = Partida Dobrada -> Descalcula Credito
//																-> Recalcula Debito / Credito
If cTipoAnt == "2" .And. cTipo == "3"
	If cOperacao == "D"
		lAltCrd := .T.
	Else      
		lAltDeb := .T.
		lAltCrd := .T.
	EndIf	
EndIf
// Anterior = Partida Dobrada / Atual = Debito	-> Descalcula os dois
//															   -> Recalcula Debito
If cTipoAnt == "3" .And. cTipo == "1"
	If cOperacao == "D"
		lAltCrd := .T.
		lAltDeb := .T.
	Else
		lAltDeb := .T.
	EndIf		
EndIf
// Anterior = Partida Dobrada / Atual = Credito -> Descalcula os dois
//																-> Recalcula Credito
If cTipoAnt == "3" .And. cTipo == "2"
	If cOperacao == "D"
		lAltDeb := .T.
		lAltCrd := .T.
	Else
		lAltCrd := .T.
	EndIf	
EndIf
If nValorAnt != nValor
	lAltValor := .T.
EndIf
If cTpSaldAnt != cTpSald
	lAltTpSald:= .T.
EndIf
If cMoedaAnt != cMoeda
	lAltMoeda := .T.
EndIf

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³CtbGravSaldo³ Autor ³ Pilar S. Albaladejo 			³ Data ³ 27/11/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Gravacao de Saldos                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±					  
±±³Sintaxe	 ³CtbGravSaldo(cLote,cSubLote,cDoc,dData,cTipo,cMoeda,cDebito,cCredito,   ³±±
±±³       	 ³cCustoDeb,cCustoCrd,cItemDeb,cItemCrd,cClVlDeb,cClVlCrd,nValor,cTpSald, ³±±
±±³       	 ³nOpc,cDebitoAnt,cCreditoAnt,cCustoDAnt,cCustoCAnt,cItemDAnt,cItemCAnt,  ³±±
±±³       	 ³cCLVLDAnt,cCLVLCant,nValorAnt,cTipoant,cTpSaldAnt,cMoedaAnt,lCusto,	  ³±±
±±³       	 ³lItem,lClVl,nTotInf)                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³Nenhum                                                      			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												 			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Lote                             				 			  ³±±
±±³			 ³ ExpC2 = SubLote     													  ³±±
±±³			 ³ ExpC3 = Documento   													  ³±±
±±³			 ³ ExpD1 = Data        													  ³±±
±±³			 ³ ExpC4 = Tipo do lancamento											  ³±±
±±³			 ³ ExpC5 = Moeda              											  ³±±
±±³			 ³ ExpC6 = Conta debito        											  ³±±
±±³			 ³ ExpC7 = Conta credito       											  ³±±
±±³			 ³ ExpC8 = Centro de custo debito										  ³±±
±±³			 ³ ExpC9 = Centro de custo credito										  ³±±
±±³			 ³ ExpC10= Item Debito             										  ³±±
±±³			 ³ ExpC11= Item Credito            										  ³±±
±±³			 ³ ExpC12= Classe de Valor Debito  										  ³±±
±±³			 ³ ExpC13= Classe de Valor Credito 										  ³±±
±±³			 ³ ExpN1 = Valor														  ³±±
±±³			 ³ ExpC14= Tipo de Saldo           										  ³±±
±±³			 ³ ExpN2 = Numero da Opcao escolhida					   				  ³±±
±±³			 ³ ExpC15= Conta debito anterior										  ³±±
±±³			 ³ ExpC16= Conta credito anterior										  ³±±
±±³			 ³ ExpC17= Centro de custo debito anterior								  ³±±
±±³			 ³ ExpC18= Centro de custo credito	anterior							  ³±±
±±³			 ³ ExpC19= Item Debito anterior    										  ³±±
±±³			 ³ ExpC20= Item Credito anterior   										  ³±±
±±³			 ³ ExpC21= Classe de Valor Debito anterior								  ³±±
±±³			 ³ ExpC22= Classe de Valor Credito anterior								  ³±±
±±³			 ³ ExpN3 = Valor anterior												  ³±±
±±³			 ³ ExpC22= Tipo de lancamento anterior									  ³±±
±±³			 ³ ExpC23= Tipo de Saldo anterior  										  ³±±
±±³			 ³ ExpC24= Moeda Anterior          										  ³±±
±±³			 ³ ExpL1 = Indica se atualiza centro de custo							  ³±±
±±³			 ³ ExpL2 = Indica se atualiza item               						  ³±±
±±³			 ³ ExpL3 = Indica se atualiza classe de valor							  ³±±
±±³			 ³ ExpN4 = Valor Total informado              							  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbGravSaldo(cLote,cSubLote,cDoc,dData,cTipo,cMoeda,cDebito,;
					  cCredito,cCustoDeb,cCustoCrd,cItemDeb,cItemCrd,;
					  cClVlDeb,cClVlCrd,nValor,cTpSald,nOpc,cDebitoAnt,;
					  cCreditoAnt,cCustoDAnt,cCustoCAnt,cItemDAnt,;
					  cItemCAnt,cCLVLDAnt,cCLVLCAnt,nValorAnt,;
					  cTipoAnt,cTpSaldAnt,cMoedaAnt,lCusto,lItem,lClVL,nTotInf,;
					  lAtSldBase,lReproc,dDataLP,lGrvCT7,lGrvCT3,lGrvCT4,lGrvCTI,;
					  lAtuSldCT7,lAtuSldCT3,lAtuSldCT4,lAtuSldCTI)

Local lAltDeb		:= .F.
Local lAltCrd		:= .F.
Local lAltValor  	:= .F.
Local lAltTpSald	:= .F.
Local lAltMoeda		:= .F.
Local lPartDob 		:= .F.
lReproc 		:= Iif(lReproc==Nil,.F.,lReproc)
lAtSldBase 		:= Iif(lAtSldBase==Nil,.T.,lAtSldBase) 
dDataLP			:= Iif(dDataLP==Nil,CTOD("  /  /  "),dDataLP)

DEFAULT lGrvCT7	:= .F.
DEFAULT lGrvCT3	:= .F.
DEFAULT lGrvCT4	:= .F.
DEFAULT lGrvCTI	:= .F.
DEFAULT lAtuSldCT7	:= .T.
DEFAULT lAtuSLdCT3	:= .T.
DEFAULT lAtuSldCT4	:= .T.
DEFAULT lAtuSldCTI	:= .T.

// Verifica o que ira Recalcular - comparando variaveis que irão afetar a gravação do
// saldo -> Tipo Lcto, Valor, Tipo do Saldo, Moeda do Lcto. Se não houve alteração
// NÃO PODERÁ REGRAVAR!!!!!
If nOpc == 4
	CtbOQMudou(@lAltDeb,@lAltCrd,@lAltValor,@lAltTpSald,@lAltMoeda,;
					cTipo,cTipoAnt,nValor,nValorAnt,cTpSald,cTpSaldAnt,cMoeda,;
					cMoedaAnt,"G")
EndIf

// Grava Saldos DEVEDORES
If cTipo == "1" .Or. cTipo == "3"
	// Saldos de Lote
	If (nOpc == 4 .And. (lAltDeb .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda)) .Or. nOpc == 6
		If cTipo == "3"    
			lPartDob := .T.
		Endif
		GravaCT6(cLote,cSubLote,"1",dData,cMoeda,nValor,cTpSald,lPartDob)
		
		// Saldos de Documento
		GravaCTC(cLote,cSubLote,cDoc,"1",dData,cMoeda,nValor,cTpSald,lPartDob)
	EndIF	   

	If lAtSldBase		
		If cTpSald != D_PRELAN		// Pre-Lancamento nao controla saldos
			// Saldos de Conta
			If lAtuSldCT7
				If (nOpc == 4 .And. (cDebitoAnt != cDebito .Or. lAltDeb .Or. lAltValor .Or.;
					lAltTpSald .Or. lAltMoeda)) .Or. (nOpc == 3 .Or. nOpc == 6)
					GravaCT7(cDebito,"1",dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,,dDataLP)
				EndIf
			EndIf
			// Saldos de Centro de Custo
			If lCusto .And. lAtuSldCT3
				If (nOpc == 4 .And. (cDebitoAnt != cDebito .Or. cCustoDAnt != cCustoDeb .Or.;
					lAltDeb .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda)) .Or.;
					(nOpc == 3 .Or. nOpc == 6)
					GravaCT3(cDebito,cCustoDeb,"1",dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,,dDataLP)
    				//So ira atualizar o flag de saldos compostos se nao existir nenhum dos pontos de entrada de atualizacao de 
    				//saldos.
					If !lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI
						//Atualiza Flag de Saldos Compostos							
						AtuFlgCmp(dData,"CTT",cCustoDeb,cMoeda,cTpSald)
					Endif
				EndIf
			EndIf	
			// Saldos de Itens Contabeis
			If lItem .And. lAtuSldCT4
				If (nOpc == 4 .And. (cDebitoAnt != cDebito .Or. cCustoDAnt != cCustoDeb .Or.;
					cItemDAnt != cItemDeb .Or. ;
					lAltDeb .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda)) .Or.;
					(nOpc == 3 .Or. nOpc == 6)
					GravaCT4(cDebito,cCustoDeb,cItemDeb,"1",dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,,dDataLP)
    				//So ira atualizar o flag de saldos compostos se nao existir nenhum dos pontos de entrada de atualizacao de 
    				//saldos.
					If !lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI					
						//Atualiza Flag de Saldos Compostos			
						AtuFlgCmp(dData,"CTD",cItemDeb,cMoeda,cTpSald)					
					EndIf
				EndIf
			EndIf	
			// Saldos Classe de Valor
			If lClvl .And. lAtuSldCTI
				If (nOpc == 4 .And. (cDebitoAnt != cDebito .Or. cCustoDAnt != cCustoDeb .Or.;
					cItemDAnt != cItemDeb .Or. cCLVLDAnt != cCLVLDeb .Or.;
					lAltDeb .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda)) .Or.;
					(nOpc == 3 .Or. nOpc == 6)
					GravaCTI(cDebito,cCustoDeb,cItemDeb,cCLVLDeb,"1",dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,,dDataLP)
    				//So ira atualizar o flag de saldos compostos se nao existir nenhum dos pontos de entrada de atualizacao de 
    				//saldos.
					If !lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI					
						//Atualiza Flag de Saldos Compostos		
						AtuFlgCmp(dData,"CTH",cCLVLDeb,cMoeda,cTpSald)					
					EndIf
				EndIf
			EndIf		
		EndIf   
	Endif    
EndIf                     

// Grava Saldos CREDORES
If cTipo == "2" .Or. cTipo == "3"
	// Saldos de Lote
	If (nOpc == 4 .And. (lAltCrd .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda)) .Or. nOpc == 6

		If cTipo == "3" 
			lPartDob := .T.
		Endif

		GravaCT6(cLote,cSubLote,"2",dData,cMoeda,nValor,cTpSald,lPartDob)			

		// Saldos de Documento
		GravaCTC(cLote,cSubLote,cDoc,"2",dData,cMoeda,nValor,cTpSald,lPartDob)
	EndIf	

	If lAtSldBase			
		If cTpSald != D_PRELAN		// Pre-Lancamento nao controla saldos
			// Saldos de Conta       
			If lAtuSldCT7
				If (nOpc == 4 .And. (cCreditoAnt != cCredito .Or. lAltCrd .Or. lAltValor .Or.;
					lAltTpSald .Or. lAltMoeda)) .Or. (nOpc == 3 .Or. nOpc == 6)
					GravaCT7(cCredito,"2",dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,,dDataLP)
				EndIf
			EndIf
			// Saldos de Centro de Custo
			If lCusto .And. lAtuSldCT3
				If (nOpc == 4 .And. (cCreditoAnt != cCredito .Or. cCustoCAnt != cCustoCrd .Or.;
					lAltCrd .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda)) .Or. ;
					(nOpc == 3 .Or. nOpc == 6)
					GravaCT3(cCredito,cCustoCrd,"2",dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,,dDataLP)
    				//So ira atualizar o flag de saldos compostos se nao existir nenhum dos pontos de entrada de atualizacao de 
    				//saldos.
					If !lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI					
						//Atualiza Flag de Saldos Compostos		
						AtuFlgCmp(dData,"CTT",cCustoCrd,cMoeda,cTpSald)					
					EndIf
				EndIf
			EndIf
			// Saldos de Item Contabil
			If lItem .And. lAtuSldCT4
				If (nOpc == 4 .And. (cCreditoAnt != cCredito .Or. cCustoCAnt != cCustoCrd .Or.;
					cItemCAnt != cItemCrd .Or.;
					lAltCrd .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda)) .Or.;
					(nOpc == 3 .Or. nOpc == 6)
					GravaCT4(cCredito,cCustoCrd,cItemCrd,"2",dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,,dDataLP)
    				//So ira atualizar o flag de saldos compostos se nao existir nenhum dos pontos de entrada de atualizacao de 
    				//saldos.
					If !lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI					
						//Atualiza Flag de Saldos Compostos		
						AtuFlgCmp(dData,"CTD",cItemCrd,cMoeda,cTpSald)					
					EndIf
				EndIf
			EndIf
			// Saldos de Classe de Valor
			If lCLVL .And. lAtuSldCTI
				If (nOpc == 4 .And. (cCreditoAnt != cCredito .Or. cCustoCAnt != cCustoCrd .Or.;
					cItemCAnt != cItemCrd .Or.cCLVLCAnt != cCLVLCrd .Or.;
					lAltCrd .Or. lAltValor .Or. lAltTpSald .Or. lAltMoeda)) .Or.;
					(nOpc == 3 .Or. nOpc == 6)
					GravaCTI(cCredito,cCustoCrd,cItemCrd,cCLVLCrd,"2",dData,cMoeda,nValor,cTpSald,lReproc,lAtSldBase,,dDataLP)
    				//So ira atualizar o flag de saldos compostos se nao existir nenhum dos pontos de entrada de atualizacao de 
    				//saldos.
					If !lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI					
						//Atualiza Flag de Saldos Compostos		
						AtuFlgCmp(dData,"CTH",cCLVLCrd,cMoeda,cTpSald)					
					EndIf
				EndIf
			EndIf                             
		EndIf                                 
	EndIf               
EndIf

If nTotInf <> Nil
	CtbGrvlInf(dData,cLote,cSubLote,cDoc,cMoeda,nTotInf,nOpc)
Endif

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³CTBGrava  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava dados da MSGETDB para CT2 - CTBA102 / CTBA105        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CTBGrava(nOpc,dDataLanc,cLote,cSubLote,cDoc,lAglut,cSequenc,³±±
±±³          ³lCusto,lItem,lCLVL,nTotInf,cProg)                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Opcao do Menu (Inclusao)                           ³±±
±±³          ³ ExpD1 = Data do Lancamento                                 ³±±
±±³          ³ ExpC1 = Numero do Lote                                     ³±±
±±³          ³ ExpC2 = Numero do documento                                ³±±
±±³          ³ ExpL1 = Aglutina?                                          ³±±
±±³          ³ ExpC3 = Sequenciador                                       ³±±
±±³          ³ ExpL2 = Grava C.custo?                                     ³±±
±±³          ³ ExpL3 = Grava Item?                                        ³±±
±±³          ³ ExpL4 = Grava Classe de valor?                             ³±±
±±³          ³ ExpN2 = Valor Tota Informado                               ³±±
±±³          ³ ExpC4 = Nome do programa que chamou a funcao               ³±±
±±³          ³ ExpC5 = Indica o tipo de gravacao do pre-lancamento        ³±±
±±³          ³ dReproc = Parametro que indica que lancamentos nao atualiza³±±
±±³          ³           saldos e apos gravacao executa reprocessamento   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CTBGrava(nOpc,dDatalanc,cLote,cSubLote,cDoc,lAglut,cSequenc,lCusto,;
				  lItem,lCLVL,nTotInf,cProg,cPreLcto,dReproc,cEmpOri,cFilOri)

Local nCont
Local cSeqLan	:= "000"
Local nSeqHis	:= 1
Local nValor	:= 0
Local nValorAnt := 0
Local nOpcAlt	:= nOpc   
Local nContMoeda	:= 0
//Verifica se os saldos basicos serao atualizados no momento da gravacao do lancamento
//contabil ou se sera gravado via rotina de atualizacao de saldos compostos(CTBA360).
Local lAtSldBase	:= Iif(GetMv("MV_ATUSAL")== "S",.T.,.F.)
//A variavel lReproc, sera utilizada na gravacao de saldos. Caso nao seja para atualizar
//os saldos no momento da grav. dos lanc. contab., ira atualizar o saldo somente da DATA. 
//Analogo ao Reprocessamento.
Local lReproc		:= Iif(lAtSldBase,.F.,.T.)
Local nMoedas		:= __nQuantas
Local cSeqLan01		:= ""													//// _SEQLAN (Sequencia de Lanc) do registro deletado
Local cSeqHis01		:= ""													//// _SEQHIS (Sequencia de Hist) do registro deletado
Local cTpLan01		:= ""													//// _DC (Tipo do Lancamento) do registro deletado
Local cMoedaDel		:= Replicate("2",nMoedas)								//// PARA CONTROLAR SE TODAS AS MOEDAS FORAM DELETADOS
Local __Ct105Sld	// Ponto de entrada que indica se atualiza saldos
Local cAliasAnt		:= ""
Local nRecnoAnt		:= 0
Local nRecnoTMP		:= 0             
Local nOrderAnt		:= 0
Local nOrderTMP		:= 0
Local lInclui		:= .T.
Local lOutrMoeda       
Local aTravas := {}  
Local lCtbGrv := IIf(ExistBlock("CTBGRV"),.T.,.F.)
Local lFirstLn := .T.
Local lGrvCT7		:= IIf(ExistBlock("GRVCT7"),.T.,.F.)
Local lGrvCT3		:= IIf(ExistBlock("GRVCT3"),.T.,.F.)
Local lGrvCT4		:= IIf(ExistBlock("GRVCT4"),.T.,.F.)
Local lGrvCTI		:= IIf(ExistBlock("GRVCTI"),.T.,.F.)
Local lAtuSldCT7	:= .T.
Local lAtuSldCT3	:= .T.
Local lAtuSldCT4	:= .T.
Local lAtuSldCTI	:= .T.
Local lAltTpSld		:= .F.
Local lPodeGrv		:= .F.			/// INDICA SE PODE PROCEDER COM A GRAVAÇÃO / NÃO (TRATAMENTO NA MULTLOCK)
Local lPartDob		:= .F.
Local cTpSldAnt		:= ""
Local cChave		:= ""
Local CTF_LOCK		:= CTF->(Recno())
Local cCTFLINHA		:= ""
Local lPriVez		:=.T.
DEFAULT cProg := FunName()

//Caso exista algum ponto de entrada de atualizacao de saldos, verificar se deve ou nao atualizar os saldos.
If lGrvCT7
	lAtuSldCT7	:= ExecBlock("GRVCT7",.F.,.F.)
Endif

If lGrvCT3
	lAtuSldCT3	:= ExecBlock("GRVCT3",.F.,.F.)
Endif

If lGrvCT4
	lAtuSldCT4	:= ExecBlock("GRVCT4",.F.,.F.)
Endif

If lGrvCTI
	lAtuSldCTI	:= ExecBlock("GRVCTI",.F.,.F.)
Endif

///////////////////////////////////////////////////////////////////////////////////
nIndCT2 := CT2->(IndexOrd())
nRecCT2 := CT2->(Recno())
				           
If nOpc == 3 .or. nOpc == 6			//// inclusao ou estorno
	dbSelectArea("CT2")
	dbSetOrder(1)
	cFilCT2 := xFilial("CT2")
	If MsSeek(cFilCT2+DtoS(dDataLanc)+cLote+cSubLote+cDoc)
		CtbDestrava(dDataLanc,cLote,cSubLote,cDoc,@CTF_LOCK)			
		Do While !ProxDoc(dDataLanc,cLote,cSubLote,@cDoc,@CTF_LOCK)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Caso o N§ do Doc estourou, incrementa o lote         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cLote := SOMA1(cLote)
			DbSelectArea("SX5")
			MsSeek(xFilial("SX5")+"09"+If(cModulo=="CTB","CON",cModulo))
			RecLock("SX5")
			SX5->X5_DESCRI := Substr(cLote,3,4)
			MsUnlock()
		Enddo
	Endif				
	CT2->(dbSetOrder(nIndCT2))
	CT2->(dbGoTo(nRecCT2))
Endif
///////////////////////////////////////////////////////////////////////////////////

dbSelectArea("TMP") 
dbgotop()
While !Eof()                                             

	//Se a linha estiver deletada e nao foi incluido nada.
	If (TMP->CT2_RECNO = 0 .And. TMP->CT2_FLAG) 
		dbSelectArea("TMP")
		DbDelete()
		dbSkip()
		Loop		
	EndIf
	//Chamar a multlock	
	aTravas := {}
	IF !Empty(TMP->CT2_DEBITO)
	   AADD(aTravas,TMP->CT2_DEBITO)
	Endif
	IF !Empty(TMP->CT2_CREDIT)
	   AADD(aTravas,TMP->CT2_CREDIT)
	Endif

    /// NÃO CHAMA A MULTLOCK SE EXISTIREM OS P.ENTRADA GRVCT7,GRVCT3,GRVCT4,CTVCTI e TODOS ESTIVEREM RETORNANDO .F. (PARA NÃO ATUALIZAR O SALDO)
    If (lGrvCT7 .and. lGrvCT3 .and. lGrvCT4 .and. lGrvCTI) .and. (!lAtuSldCT7 .and. !lAtuSldCT3 .and. !lAtuSldCT4 .and. !lAtuSldCTI)
	   	lPodeGrv := .T.
    Else
		//Chamar a multlock	
	   	IF MultLock("CT1",aTravas,1)    
			lPodeGrv := .T.
		Else
			lPodeGrv := .F.
		Endif
	Endif
    
    If lPodeGrv 
		BEGIN TRANSACTION //Transacao linha a linha
		LanceiCtb	:= .F.							// Inicializado com Falso
		If cPreLcto # Nil .And. cPreLcto # "N"
			TMP->CT2_TPSALD := "9"
		Endif
		If TMP->CT2_FLAG
			nOpcAlt := 5
			If nOpc != 3								// Alteracao / Exclusao
				dbSelectArea("CT2")
				dbSetOrder(1)
				MsGoto(TMP->CT2_RECNO)		// Posiciono no RECNO ja gravado 
			EndIf	
		Else	
			dbSelectArea("CT2")
			dbSetOrder(1)
			If TMP->CT2_RECNO = 0 // Se o recno estiver zerado eh uma nova linha
				nOpcAlt := 3 
			Else	
				MsGoto(TMP->CT2_RECNO)		// Posiciono no RECNO ja gravado 
				nOpcAlt := nOpc
			EndIf	
		EndIf	
	
		If ! cProg $ 'CTBA101,CTBA102'
			If __Ct105CT2 = Nil
				__Ct105CT2 := ExistBlock("CT105CT2")
			Endif

			If __Ct105CT2 .And. __Ct105Sld = Nil
				__Ct105Sld := ExistBlock("CT105SLD")
			Endif
			
			If __Ct105CT2 .And. __Ct105Sld
			 	If ! ExecBlock("CT105SLD")
					nMoedas := 0
					lAltSldBase := .F.
				Else
					nMoedas := __nQuantas
					lAltSldBase := GetMv("MV_ATUSAL")== "S"
				Endif
			Endif
		Endif
	
		nRecnoTMP	:= TMP->(Recno())

		// Verificacao para identificar se grava na moeda 01 com Valor 0.00

		lOutrMoeda   := .F.
		For nContMoeda 	:= 2 To nMoedas
			If !TMP->CT2_FLAG
				lOutrMoeda := 	&("TMP->CT2_VALR"+StrZero(nContMoeda,2)) > 0 .Or.;
									lOutrMoeda
			Endif
		Next
		
		//Se for alteracao, verificar se o tipo de saldo da linha de lancamento foi alterado.
		If nOpc == 4 .And. TMP->CT2_TPSALD <> CT2->CT2_TPSALD
			lAltTpSld	:= .T.
			cTpSldAnt	:= CT2->CT2_TPSALD
		Else
			cTpSldAnt	:= TMP->CT2_TPSALD
		EndIf			
	
		///////////////////////////////////
		/// ZERA VARIAVEIS DA DELECAO DC=4
		///////////////////////////////////
		cSeqLan01		:= TMP->CT2_SEQLAN										//// _SEQLAN (Sequencia de Lanc) do registro deletado
		cSeqHis01		:= TMP->CT2_SEQHIS										//// _SEQHIS (Sequencia de Hist) do registro deletado
		cTpLan01		:= TMP->CT2_DC											//// _DC (Tipo do Lancamento) do registro deletado
		cMoedaDel		:= Replicate("2",nMoedas)								//// PARA CONTROLAR SE TODAS AS MOEDAS FORAM DELETADOS
	   
		For nContMoeda := 1 To nMoedas
			cMoeda 	:= StrZero(nContMoeda,2)
			If !TMP->CT2_FLAG						////// SE NAO ESTIVER DELETADO NO TMP
				If cMoeda == '01'
					nValor	:= TMP->CT2_VALOR
					//Se estiver na empresa consolidadora, ira considerar os campos CT2_EMPORI e CT2_FILORI
					//da moeda 01. Caso inclua algum registro novo em outra moeda, ira gravar com o mesmo
					//conteudo da moeda 01. 			
					If !Empty(TMP->CT2_EMPORI) .And. !Empty(TMP->CT2_FILORI)							
						cEmpOri	:= TMP->CT2_EMPORI                            	
						cFilOri	:= TMP->CT2_FILORI
					EndIf
				Else
					nValor	:= &("TMP->CT2_VALR"+cMoeda)   								
				EndIf
			Else								// Quando a linha for deletada -> garantir valor 0!!
				nValor 	:= 0
			EndIf				
			
			If cMoeda='01'                          
				nValorAnt:= CT2->CT2_VALOR
			Else                   
				//Se for historico complementar, so gravar na moeda 01
				If TMP->CT2_DC == '4' 			//// SE O REGISTRO NO TMP FOR CONTINUACAO DE HISTORICO
					dbSelectArea("TMP")
					dbSkip()
					Exit						//// SAI DO FOR DE MOEDAS POIS NAO HA VALOR PARA GRAVAR
				EndIf			             

				cAliasAnt	:= Alias()
				nOrderTMP	:= IndexOrd()
				nRecnoAnt	:= Recno() 	
				
				dbSelectArea("CT2")
				dbSetOrder(1)           
				If lAltTpSld
					cChave	:= xFilial()+dtos(dDataLanc)+cLote+cSubLote+cDoc+TMP->CT2_LINHA+cTpSldAnt+cEmpOri+cFilOri+cMoeda	
				Else
					cChave	:= xFilial()+dtos(dDataLanc)+cLote+cSubLote+cDoc+TMP->CT2_LINHA+TMP->CT2_TPSALD+cEmpOri+cFilOri+cMoeda	
				EndIf    
				
				If MsSeek(cChave)						//// LOCALIZA O REGISTRO DO VALOR NA MOEDA CORRESPONDENTE (02,03,04,ETC)
					nValorAnt := CT2->CT2_VALOR
				Else
					nValorAnt := 0
				EndIf                    
				dbSelectArea(cAliasAnt)
				dbSetOrder(nOrderTMP)
				dbGoto(nRecnoAnt)
			EndIf
			nOpcAlt	:= nOpc
			
			If (nOpc == 4 .Or. nOpc == 5) .And. dReproc = Nil .AND. TMP->CT2_RECNO <> 0 
				//// SE FOR ALTERACAO/EXCLUSAO E NAO FOR REPROCESSAMENTO E O REGISTRO JA EXISTIA NO CT2
				//// RETIRA O VALOR DAS TABELAS DE SALDOS
					CtbDsGrava(	cLote,cSubLote,cDoc,dDataLanc,TMP->CT2_DC,;
								cMoeda,TMP->CT2_DEBITO,TMP->CT2_CREDIT,;
								TMP->CT2_CCD,TMP->CT2_CCC,TMP->CT2_ITEMD,TMP->CT2_ITEMC,;
								TMP->CT2_CLVLDB,TMP->CT2_CLVLCR,nValor,TMP->CT2_TPSALD,;
								nOpcAlt,CT2->CT2_DEBITO,CT2->CT2_CREDIT,CT2->CT2_CCD,CT2->CT2_CCC,;
								CT2->CT2_ITEMD,CT2->CT2_ITEMC,CT2->CT2_CLVLDB,CT2->CT2_CLVLCR,;
								nValorAnt,CT2->CT2_DC,CT2->CT2_TPSALD,cMoeda,;
								lCusto,lItem,lClVL,,lReproc,lAtSldBase,CT2->CT2_DTLP,lGrvCT7,lGrvCT3,;
								lGrvCT4,lGrvCTI,lAtuSldCT7,lAtuSldCT3,lAtuSldCT4,lAtuSldCTI)
			EndIf	
			// Gravacao dos Saldos de Entidades
			If (nOpc == 3 .Or. nOpc == 4) .And. dReproc = Nil     
				/// SE FOR INCLUSAO/ALTERACAO E NAO FOR REPROCESSAMENTO
				/// GRAVA O VALOR NAS TABELAS DE SALDOS
				CtbGravSaldo(cLote,cSubLote,cDoc,dDataLanc,TMP->CT2_DC,;
							cMoeda,TMP->CT2_DEBITO,TMP->CT2_CREDIT,;
							TMP->CT2_CCD,TMP->CT2_CCC,TMP->CT2_ITEMD,TMP->CT2_ITEMC,;
							TMP->CT2_CLVLDB,TMP->CT2_CLVLCR,nValor,TMP->CT2_TPSALD,;
							nOpcAlt,CT2->CT2_DEBITO,CT2->CT2_CREDIT,CT2->CT2_CCD,CT2->CT2_CCC,;
							CT2->CT2_ITEMD,CT2->CT2_ITEMC,CT2->CT2_CLVLDB,CT2->CT2_CLVLCR,;
							nValorAnt,CT2->CT2_DC,CT2->CT2_TPSALD,cMoeda,;
							lCusto,lItem,lClVL,,lAtSldBase,lReproc,TMP->CT2_DTLP,lGrvCT7,lGrvCT3,;
							lGrvCT4,lGrvCTI,lAtuSldCT7,lAtuSldCT3,lAtuSldCT4,lAtuSldCTI)                          
			EndIf                                          

			//Se for alteracao, e estiver zerando o valor nas outras moedas, deleta o registro do lancamento existente.		
			If nOpc	== 4 .and. nValor = 0 .And. nValorAnt	<> 0
				dbSelectArea("CT2")
				dbSetOrder(1)       
				If lAltTpSld
 					cChave	:= xFilial()+dtos(dDataLanc)+cLote+cSubLote+cDoc+TMP->CT2_LINHA+cTpSldAnt+TMP->CT2_EMPORI+TMP->CT2_FILORI+cMoeda      						
				Else
					cChave	:= xFilial()+dtos(dDataLanc)+cLote+cSubLote+cDoc+TMP->CT2_LINHA+TMP->CT2_TPSALD+TMP->CT2_EMPORI+TMP->CT2_FILORI+cMoeda
				EndIf    
					
				cMoedaDel	:= Left(cMoedaDel,nContMoeda-1)+"1"+Right(cMoedaDel,ABS(Len(cMoedaDel)-(nContMoeda)))
					
				If MsSeek(cChave)								//// SE ENCONTROU O REGISTRO NA MOEDA INDICADA (FOR)
					cEmpOri		:= TMP->CT2_EMPORI
					cFilOri		:= TMP->CT2_FILORI				
					cSeqLan01	:= CT2->CT2_SEQLAN				
					cSeqHis01	:= CT2->CT2_SEQHIS
					cTpLan01	:= CT2->CT2_DC				

					Reclock("CT2", .f., .t. )				
					dbDelete()
					MsUnlock()
				Endif
					      	         
				If cTpLan01 <> "4" .and. cMoeda = StrZero(nMoedas,2) //Se esta for a a ultima moeda. //// SO DELETA AS CONTINUACOES SE ERA REGISTRO DE LANCAMENTO (123)
					If At("2",cMoedaDel) <= 0
						dbSelectArea("CT2")
						nOrderAnt	:= IndexOrd()
						nRecnoAnt	:= Recno()
						dbSetOrder(10)
						If MsSeek(xFilial("CT2")+DTOS(dDatalanc)+cLote+cSubLote+cDoc+cSeqLan01,.F.)
							While !Eof() .And. xFilial("CT2") == CT2->CT2_FILIAL .And. cLote == CT2->CT2_LOTE ;
									.And. cSubLote == CT2->CT2_SBLOTE .And. cDoc == CT2->CT2_DOC .And. cSeqLan01 == CT2->CT2_SEQLAN 
   	 	       	
   	    	   					If cEmpOri == CT2->CT2_EMPORI .And. cFilOri == CT2->CT2_FILORI	.and. ;	
									CT2->CT2_DC == "4" .AND. CT2->CT2_SEQHIS > cSeqHis01 	//// DELETA SOMENTE AS CONT.HIST. MAIORES 
		               	
		   							RecLock( "CT2", .f., .t. )								//// E DA MESMA EMPRESA/FILIAL (CASO CONSOLIDADA)
									CT2->( DbDelete() )
									MsUnlock()	 
								Endif
								
								dbSelectarea("TMP")
								dbSetOrder(2)
								If MsSeek(CT2->CT2_LINHA)
									TMP->CT2_FLAG	:= .T.						
								EndIf
								dbSetOrder(0)
										
								dbSelectArea("CT2")                                          
								dbSkip()
							EndDo			
						Endif
			 			dbSetOrder(nOrderAnt)		//// RESTAURA ORDEM DO CT2
						dbGoto(nRecnoAnt)			//// E POSICAO DO CT2
						dbSelectArea("TMP")				
					Endif
				EndIf
			EndIf
            
			// Se nao for moeda 01 grava somente se for lancamento (123) ou 
			// Se for Moeda 01 com valor zerado e tiver valores em outras moedas 
			// e se for inclusao ou alteracao (e a linha nao estiver deletada).	
			If TMP->CT2_DC <> '4' .And. nValor <= 0 ;
				.And. ((nOpc == 4 .And. !TMP->CT2_FLAG) .Or. nOpc = 3) ;
				.And. (cMoeda <> "01" .Or. (cMoeda = "01" .And. ! lOutrMoeda))
				Loop
			EndIf				
		
			If !TMP->CT2_FLAG								/// SE NAO ESTIVER DELETADO
				If nOpc <> 5								// Inclusao / Alteracao (diferente de exclusao)
					If cPaisLoc == 'CHI' .and. lFirstLn   
						lFirstLn := .F.
						If ! Empty( TMP->CT2_LP)
							cLanP := TMP->CT2_LP
						Else 
							cLanP := CTBSubToPad( cSubLote)
						EndIf               
						// checa concorrencia da numeracao correlativa cSeqCorr antes de gravar
						cSeqCorr := CTBSqNaoEx(cSeqCorr, cLanP,nOpc,dDataLanc)
					EndIf

					dbSelectArea("CT2")
					dbSetOrder(1)					
					If lAltTpSld
 						cChave	:= xFilial()+dtos(dDataLanc)+cLote+cSubLote+cDoc+TMP->CT2_LINHA+cTpSldAnt+TMP->CT2_EMPORI+TMP->CT2_FILORI+cMoeda
					Else
						cChave	:= xFilial()+dtos(dDataLanc)+cLote+cSubLote+cDoc+TMP->CT2_LINHA+TMP->CT2_TPSALD+TMP->CT2_EMPORI+TMP->CT2_FILORI+cMoeda
					EndIf    
					
					If 	!MsSeek(cChave)  
						lInclui := .T.
//						If TMP->CT2_RECNO = 0 //LINHA ESTA EM BRANCO
					Else
						lInclui := .F.				                
					EndIf									 
					If lInclui
						RecLock( "CT2", lInclui )
						CT2->CT2_FILIAL		:= xFilial()
						CT2->CT2_DATA		:= dDataLanc	
						CT2->CT2_LOTE		:= cLote
						CT2->CT2_SBLOTE		:= cSubLote
						CT2->CT2_DOC		:= cDoc
						CT2->CT2_FILORI		:= cFilOri
						CT2->CT2_EMPORI		:= cEmpOri
						CT2->CT2_LP			:= TMP->CT2_LP
						CT2->CT2_SEQUEN		:= cSequenc
						CT2->CT2_ROTINA		:= cProg
						CT2->CT2_ORIGEM		:= TMP->CT2_ORIGEM
						CT2->CT2_AGLUT		:= Iif(lAglut,"1","2")
						CT2->CT2_MOEDLC		:= cMoeda
						CT2->CT2_DTCV3		:= TMP->CT2_DTCV3
					Else
						RecLock( "CT2", lInclui )
					Endif
					For nCont := 1 To Len(aHeader)
						If (aHeader[nCont][10] != "V" )      
							// Verifica se o campo existe na estrutura do CT2
							If FieldPos(aHeader[nCont][2]) != 0
								FieldPut(FieldPos(aHeader[nCont][2]),;
								TMP->(FieldGet(FieldPos(aHeader[nCont][2]))))
							EndIf	
						EndIf
					Next nCont
					
					If nOpc == 4 .And. !lInclui .And. lAltTpSld					
						CT2->CT2_TPSALD	:= TMP->CT2_TPSALD					
					EndIf                                       
					
					// Gravacao dados complementares
					If Empty(CT2->CT2_SEQUEN)				// Lancamento manual
						CT2->CT2_MANUAL	:= "1" 
						// Agora grava a sequencia para tornar possivel a verificacao do
						// drill down.
						CT2->CT2_SEQUEN	:= cSequenc
					Else
						CT2->CT2_MANUAL	:= "2"
						CT2->CT2_KEY	:= TMP->CT2_KEY
					Endif				      
					//Tratamento somente para a moeda 01
	   	        	If cMoeda = '01'
						If cProg == 'CTBA101'
							If CT2->CT2_DC <> "4"
								cSeqLan := Soma1(cSeqLan)
								CT2->CT2_SEQHIS	:= "001"
								CT2->CT2_SEQLAN	:= cSeqLan
								nSeqHis	:= 1
							ElseIf CT2->CT2_DC == "4"
								nSeqHis++
								CT2->CT2_SEQLAN	:= cSeqLan
		   						CT2->CT2_SEQHIS	:= StrZero(nSeqHis,3)
							EndIf
						Else         //Se for CTBA105/CTBA102          
							//Os campos TMP->CT2_SEQLAN e TMP->CT2_SEQHIS estarao em branco qdo for incluido
							//linhas na GETDB do CTBA105.  						                               
							If CT2->CT2_LINHA == '001'
								cSeqLan	:= "001"
								nSeqHis	:= 1
								CT2->CT2_SEQLAN := cSeqLan
								CT2->CT2_SEQHIS := StrZero(nSeqHis,3)
							ElseIf CT2->CT2_DC <> "4" .And. CT2->CT2_LINHA != '001'
								CT2->CT2_SEQHIS	:= "001"
								nSeqHis := 1
								If !Empty(TMP->CT2_SEQLAN)
									CT2->CT2_SEQLAN	:= TMP->CT2_SEQLAN
									cSeqLan 		:= CT2->CT2_SEQLAN
								Else 
									cSeqLan := Soma1(cSeqLan)
									CT2->CT2_SEQLAN := cSeqLan
								Endif
							ElseIf CT2->CT2_DC == "4" .And. CT2->CT2_LINHA != '001'
								If Empty(TMP->CT2_SEQLAN)             
									CT2->CT2_SEQLAN	:= cSeqLan
								Else
									CT2->CT2_SEQLAN	:= TMP->CT2_SEQLAN    
									cSeqLan 		:= CT2->CT2_SEQLAN
								Endif
								If Empty(TMP->CT2_SEQHIS)  
									nSeqHis++
									CT2->CT2_SEQHIS	:= StrZero(nSeqHis,3) 
								Else                   
									CT2->CT2_SEQHIS	:= TMP->CT2_SEQHIS
									nSeqHis 		:= Val(CT2->CT2_SEQHIS)
								Endif
							Endif				
						EndIf
						CT2->CT2_CRCONV	:= Subs(TMP->CT2_CONVER,1,1)						
					Else
						CT2->CT2_CRCONV	:= Subs(TMP->CT2_CONVER,nContMoeda,1)											
    	   	           	CT2->CT2_SEQLAN	:= cSeqLan01
        	       	   	CT2->CT2_SEQHIS	:= cSeqHis01
						CT2->CT2_VALOR	:= &("TMP->CT2_VALR"+cMoeda)               	   	
					Endif
    	
					If cPaisLoc == 'CHI'    // grava variavel cSeqCorr
						If ! Empty( TMP->CT2_LP)
							cLanP := TMP->CT2_LP
						Else 
							cLanP := CTBSubToPad( cSubLote)
						EndIf
						If lPriVez
							cSeqCorr:= CTBSQNaoEx( cSeqCorr, cLanP,nOpc,dDataLanc)  // Verifica se o correlativo esta duplicado
							lPriVez:=.F.
						EndIf	
						CT2->CT2_SEGOFI := CTBSQGrv( cLanP ) 
						FreeUsedCode()  //libera codigos de correlativos reservados pela MayIUseCode()
					EndIf

 					If CT2_DC <> "4"		// Se nao for Continuacao de historico			
						If lAtSldBase	//Se for para atualizar saldo basico, preenche o flag. 
							CT2->CT2_SLBASE := "S"                                            
						Else
							CT2->CT2_SLBASE := "N"                                            			
						EndIf
					Endif
                     	
					If ! cProg $ 'CTBA101,CTBA102'
						If __Ct105CT2
							ExecBlock("CT105CT2", .F., .F.,;
									 { 	__nQuantas, dDatalanc,cLote,cSubLote,cDoc,;
									 	lCusto,lItem,lCLVL,nTotInf,lAtSldBase,lReproc })
						Endif
					Endif    
					
					If lCtbGrv
						ExecBlock("CTBGRV",.f.,.f.,{nOpc,cProg})
					EndIf
					
			
					MsUnlock()                     
					If cMoeda ='01'
						cSeqLan01	:= CT2->CT2_SEQLAN
						cSeqHis01	:= CT2->CT2_SEQHIS
					EndIf      
					                       
					#IFNDEF TOP															
						cAliasAnt	:= Alias()					
						nRecnoAnt	:= Recno() 	
						//Chama rotina para atualizar os flags de saldos a partir da data 
						//para frente.           		
						If (!lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI) .And.!lAtSldBase .And. dReproc = Nil // Se nao atualiza saldo basico, preenche o flag como nao atualizado
						// Se nao atualiza saldo basico, preenche o flag como nao atualizado
						AtuFlgCT2(CT2->CT2_FILIAL,CT2->CT2_DATA,;
									CT2->CT2_DEBITO + "/" + CT2->CT2_CREDIT, ;
									CT2->CT2_CCD 	+ "/" + CT2->CT2_CCC,; 
									CT2->CT2_ITEMD 	+ "/" + CT2->CT2_ITEMC,;
									CT2->CT2_CLVLDB + "/" + CT2->CT2_CLVLCR,;
									CT2->CT2_TPSALD)
						EndIf           	
			
						dbSelectArea(cAliasAnt)	 
						dbGoto(nRecnoAnt)			
					#ENDIF

				//Se for inclusão de lançamentos contabeis, ira gravar os saldos de lote e documento depois da gravacao do CT2
				//devido a integridade referencial. O CT2 eh o pai do CT6 e CTC 				
				If nOpc == 3	             	                			
					If TMP->CT2_DC == "3"    
						lPartDob := .T.
					Endif
					
					If TMP->CT2_DC == "1" .Or. TMP->CT2_DC == "3"
						GravaCT6(cLote,cSubLote,"1",dDataLanc,cMoeda,nValor,TMP->CT2_TPSALD,lPartDob)
		
						// Saldos de Documento
						GravaCTC(cLote,cSubLote,cDoc,"1",dDataLanc,cMoeda,nValor,TMP->CT2_TPSALD,lPartDob)
					EndIf		
					
                    If TMP->CT2_DC == "2" .Or. TMP->CT2_DC == "3"
						GravaCT6(cLote,cSubLote,"2",dDataLanc,cMoeda,nValor,TMP->CT2_TPSALD,lPartDob)			

						// Saldos de Documento
						GravaCTC(cLote,cSubLote,cDoc,"2",dDataLanc,cMoeda,nValor,TMP->CT2_TPSALD,lPartDob)
					EndIf
				EndIf			                
			ElseIf TMP->CT2_RECNO > 0 			// Se for Exclusao de lancamento e o registro existe no CT2                     							
				If nOpc == 5			// Exclusao de lancamento                     			
						CT2->(MsGoto(TMP->CT2_RECNO))
						//Chama rotina para atualizar os flags de saldos a partir da data 
						//para frente.           		                              
						dbSelectArea("CT2")                                          
						#IFNDEF TOP
							cAliasAnt	:= Alias()					
							nRecnoAnt	:= Recno() 	
					
							If (!lGrvCT7 .And. !lGrvCT3 .And. !lGrvCT4 .And. !lGrvCTI) .And. !lAtSldBase .And. dReproc = Nil  // Se nao atualiza saldo basico, preenche o flag como nao atualizado
						// Se nao atualiza saldo basico, preenche o flag como nao atualizado
						AtuFlgCT2(CT2->CT2_FILIAL,CT2->CT2_DATA,;
									CT2->CT2_DEBITO + "/" + CT2->CT2_CREDIT,;
									CT2->CT2_CCD 	+ "/" + CT2->CT2_CCC,; 
									CT2->CT2_ITEMD 	+ "/" + CT2->CT2_ITEMC,;
									CT2->CT2_CLVLDB + "/" + CT2->CT2_CLVLCR,;
									CT2->CT2_TPSALD)
							EndIf
    		       		    dbSelectArea(cAliasAnt)
							dbGoto(nRecnoAnt)   
						#ENDIF
						dbSelectArea("CT2")             
						dbSetOrder(1)
						If MsSeek(xFilial()+dtos(dDataLanc)+cLote+cSubLote+cDoc+TMP->CT2_LINHA+TMP->CT2_TPSALD+TMP->CT2_EMPORI+TMP->CT2_FILORI+cMoeda)
							RecLock( "CT2", .f., .t. )		 							
							CT2->( DbDelete() )
							MsUnlock()
						EndIf
					Endif                  			
					If cMoeda = '01'	
						cAliasAnt := Alias()
						dbSelectAREA("CTF")                    
						MsSeek(xFilial("CTF")+Dtos(dDataLanc)+cLote+cSubLote+cDoc)
					CTF_LOCK := CTF->(Recno())
						CtbDestrava(dDataLanc,cLote,cSubLote,cDoc,@CTF_LOCK)			
						dbSelectArea(cAliasAnt)	 					
					EndIf
		   		EndIf  

				dbSelectArea( "TMP" )
				If cMoeda = StrZero(nMoedas,2)//Se tiver gravado a ultima moeda.			
					TMP->CT2_FLAG	:= .T.
					dbSkip()
				EndIf
				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				//// BLOCO PARA TRATAMENTO DOS REGISTROS DELETADOS NO TMP->CT2_FLAG == .T.
				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			ElseIf TMP->CT2_RECNO > 0			//// SE A LINHA ESTIVER MARCADA COMO DELETADA E O REGISTRO JA EXISTIA NO CT2
				cMoedaDel	:= Left(cMoedaDel,nContMoeda-1)+"1"+Right(cMoedaDel,ABS(Len(cMoedaDel)-(nContMoeda)))
				
				dbSelectArea("CT2")             
				dbSetOrder(1)
				nOrderAnt	:= IndexOrd()
				nRecnoAnt	:= Recno()
				If MsSeek(xFilial()+dtos(dDataLanc)+cLote+cSubLote+cDoc+TMP->CT2_LINHA+TMP->CT2_TPSALD+TMP->CT2_EMPORI+TMP->CT2_FILORI+cMoeda)
					cSeqLan01	:= CT2->CT2_SEQLAN				
					cSeqHis01	:= CT2->CT2_SEQHIS
					cTpLan01	:= CT2->CT2_DC				
					RecLock( "CT2", .f., .t. )				//// DELETA A LINHA INDICADA NO TMP
					CT2->( DbDelete() )
					MsUnlock()
				Else
					dbSetOrder(nOrderAnt)
					dbGoto(nRecnoAnt)				
				EndIf                 
                    
				If cTpLan01 <> "4" .and. cMoeda = StrZero(nMoedas,2) //Se esta for a a ultima moeda. //// SO DELETA AS CONTINUACOES SE ERA REGISTRO DE LANCAMENTO (123)
					If At("2",cMoedaDel) <= 0
						dbSelectArea("CT2")
						nOrderAnt	:= IndexOrd()
						nRecnoAnt	:= Recno()
						dbSetOrder(10)
						If MsSeek(xFilial("CT2")+DTOS(dDatalanc)+cLote+cSubLote+cDoc+cSeqLan01,.F.)
							While !Eof() .And. xFilial("CT2") == CT2->CT2_FILIAL .And. cLote == CT2->CT2_LOTE ;	
								.And. cSubLote == CT2->CT2_SBLOTE .And. cDoc == CT2->CT2_DOC .And. cSeqLan01 == CT2->CT2_SEQLAN 

								If cEmpOri == CT2->CT2_EMPORI .And. cFilOri == CT2->CT2_FILORI	.and. ;	
									CT2->CT2_DC == "4" .AND. CT2->CT2_SEQHIS > cSeqHis01 	//// DELETA SOMENTE AS CONT.HIST. MAIORES 
	
									RecLock( "CT2", .f., .t. )								//// E DA MESMA EMPRESA/FILIAL (CASO CONSOLIDADA)
									CT2->( DbDelete() )
									MsUnlock()	 
								Endif
							
								dbSelectarea("TMP")
								dbSetOrder(2)
								If MsSeek(CT2->CT2_LINHA)
									TMP->CT2_FLAG	:= .T.						
								EndIf
								dbSetOrder(0)
									
								dbSelectArea("CT2")
								dbSkip()
							EndDo			
						Endif

	 					dbSetOrder(nOrderAnt)		//// RESTAURA ORDEM DO CT2
						dbGoto(nRecnoAnt)			//// E POSICAO DO CT2
						dbSelectArea("TMP")				
					Endif
				Endif
			EndIf
			LanceiCtb := .T. 				// Flag indicativo de que contabilizou
		Next	
		END TRANSACTION     
                                       
		dbSelectArea("TMP")
		dbGoto(nRecnoTMP)
		dbSkip()
		lAltTpSld	:= .F.
		//Alimenta as variaveis cEmpori e cFilori com a empresa/filial corrente. Se o proximo lancamento
		//for historico complementar, devera manter o empori/filori da empresa/filial origem. 
		If TMP->CT2_DC <> '4'
			cEmpOri	:= cEmpAnt  
			cFilOri	:= cFilAnt
		EndIf
	Endif
Enddo

If cPaisLoc = "CHI"
	FreeUsedCode()  //libera codigos de correlativos reservados pela MayIUseCode()
EndIf

// Grava numero da ultima linha no arquivo de controle (CTF)
If !Empty(cCTFLINHA)
	dbSelectAREA("CTF")                    
	If MsSeek(xFilial("CTF")+Dtos(dDataLanc)+cLote+cSubLote+cDoc)
 		RecLock("CTF",.F.)
	Else
		RecLock("CTF",.T.)
		Replace CTF_FILIAL 	With xFilial("CTF")
		Replace CTF_LOTE	With cLote
		Replace CTF_SBLOTE	With cSubLote
		Replace CTF_DOC		With cDoc
		Replace CTF_DATA	With dDataLanc
	EndIf		
	Replace CTF_LINHA With cCTFLINHA
	CTF->(MsUnlock())
EndIf
			
// Gravo o valor informado no final pois eh em relacao ao documento
If nTotInf <> Nil .And. nTotInf > 0
	CtbGrvlInf(dDataLanc,cLote,cSubLote,cDoc,"01",nTotInf,nOpc)
Endif

//Temporario, enquanto a GETDB nao verifica se o registro estah deletado ou nao. 
dbSelectArea("TMP")
Pack

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CtbGrvlInf ³ Autor ³ Simone Sato           ³ Data ³14.02.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava Valor Informado no  CT6_INF					          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbGrvlInf(dData,cLote,cSubLote,cMoeda,nTotInf,nOpc)		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ CTB		                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³dData    = Data                                             ³±±
±±³          ³cLote    = Numero do Lote                                   ³±±
±±³          ³cSubLote = Numero do SubLote                                ³±±
±±³          ³cDoc     = Numero do Documento                              ³±±
±±³          ³cMoeda   = Codigo da Moeda                                  ³±±
±±³          ³nTotInf  = Valor Total Informado para o documento           ³±±
±±³          ³nOpc     = Opcao atual em execucao                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbGrVlInf(dData,cLote,cSubLote,cDoc,cMoeda,nTotInf,nOpc)

Local aSaveArea	:= GetArea(), nDimLot := 0

// Saldo por Documento

dbSelectArea('CTC')
dbSetOrder(1)
If MsSeek(xFilial()+dtos(dData)+cLote+cSubLote+cDoc+cMoeda)

// No caso de exclusao, caso ainda tenha valores digitados nao manipula o valor   
// Tratamento necessario pois a exclusao do CTBA101 e por linha nao deletando o documento

	If nOpc = 5 .And. CTC->CTC_DIG > 0
		Return .T.
	Endif
	
	RecLock( "CTC", .f. )
	If nOpc # 5		// Caso positivo altere para o valor recebido
		nDimLot 	 := CTC->CTC_INF
		CTC->CTC_INF := nTotInf
	Else			// Caso contrario eh exclusao ou seja zero o documento
		CTC->CTC_INF := 0.00
	Endif
	MsUnlock()	
Endif

// Saldo por Lote

dbSelectArea('CT6')
dbSetOrder(1)
If MsSeek(xFilial()+dtos(dData)+cLote+cSubLote+cMoeda) .And. CTC->(Found())
	RecLock( "CT6", .f. )
	If nOpc # 5		// Caso positivo altere para o valor recebido
		CT6->CT6_INF -= nDimLot
		CT6->CT6_INF += nTotInf
	Else
		CT6->CT6_INF -= nTotInf
	Endif
	MsUnlock()	
Endif

RestArea(aSaveArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ValCtaSup ³ Autor ³ Simone Mie Sato       ³ Data ³ 18.04.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida Conta Superior na inclusao da conta contabil.       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³VaCtaSup(cConta)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. / .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta contabil Superior Digitada                   ³±±
±±³Parametros³ ExpC1 = Conta contabil que esta sendo cadastrada           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValCtaSup(cConta,cCtaAtu)

Local aSaveArea:= GetArea()
Local lRet		:= .T.

DEFAULT cCtaAtu := ""
dbSelectArea("CT1")
dbSetOrder(1)

If !Empty(cConta)
	DO CASE
	CASE cCtaAtu == cConta					//A conta atual (_CONTA) deve ser diferente da superior
		Help(" ",1,"ENTPAIGUAL")
		lRet := .F.	
	CASE !MsSeek(xFilial()+cConta)          //A conta digitada (CTASUP) deve existir no Plano de Contas. 
		Help("  ", 1, "NOCADCTASU")
		lRet := .F.
	CASE CT1->CT1_CLASSE != "1"				//A conta superior deve ser sintetica. 
		Help(" ",1,"NOCLASSESI")
		lRet := .F.
	ENDCASE
EndIf

RestArea(aSaveArea)

Return lRet            

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ValEntSup ³ Autor ³ Wagner Mobile Costa   ³ Data ³ 01.04.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida Conta Superior na inclusao da conta contabil.       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ValEntSup(cCodEnt, cEntidade)                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. / .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Endidade contabil Superior Digitada                ³±±
±±³          ³ ExpC2 = Entidade para validacao (CTT/CTD/CTH)              ³±±
±±³Parametros³ ExpC3 = Entidade contabil que esta sendo cadastrada        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValEntSup(cCodEnt, cEntidade, cCodAtu)

Local aSaveArea	:= GetArea()
Local lRet		:= .T.

Default cEntidade := Alias()
Default cCodAtu   := ""

dbSelectArea(cEntidade)
dbSetOrder(1)

If !Empty(cCodEnt)
	DO CASE
	CASE cCodAtu == cCodEnt					//A entidade cadastrada deve ser diferente da superior (_xxSUP) 
		Help(" ",1,"ENTPAIGUAL")
		lRet := .F.	
	CASE !MsSeek(xFilial()+cCodEnt)          //A Entidade deve existir 
		Help("  ", 1, "NOCADENTSU")
		lRet := .F.
	CASE &(cEntidade + "_CLASSE") != "1"	//A entidade superior deve ser sintetica. 
		Help(" ",1,"NOENTCLASI")
		lRet := .F.
	ENDCASE
EndIf

RestArea(aSaveArea)

Return lRet            

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³CTBCBOX   ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 22.04.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta Combo Box para exibir na tela                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbCbox(cCampo)                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Array com combo box                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Campo que tera o Combo Box anexado                 ³±±
±±³          ³ ExpC2 = String contendo item a nao ser apresentado "56"    ³±±
±±³          ³ ExpN1 = Tamanho a ser verificado a cada item da string     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbCbox(cCampo,cForaCombo,nLenGrava)

Local aArray1	:= {}
Local aArray2	:= {}
Local aSaveArea	:= GetArea()

Local cVar

Local nCont		:= 0

DEFAULT cForaCombo := ""
DEFAULT nLenGrava  := 1

dbSelectArea("SX3")
dbSetOrder(2)
MsSeek(cCampo)

cVar 	:= X3CBox()

If Empty(cVar)
	Return aArray2
Endif

aArray1	:= RetSx3Box(cVar,,,1)    

For nCont := 1 To Len(aArray1)
	If cForaCombo <> "" .And. Left(aArray1[nCont][1], nLenGrava) $ cForaCombo
		Loop
	Endif
	AADD(aArray2,aArray1[nCont][1])
Next nCont	

RestArea(aSaveArea)

Return aArray2

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CT102DEL  ³ Autor ³ Simone Mie Sato       ³ Data ³ 16.04.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Atualiza totais no rodape, quando deleta linha da MSGETDB.  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Ct102Del(nOpc)                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ CTBA102                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Numero da Opcao                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Ct102Del(nOpc)
LOCAL nValLcto            
Local nMvSoma	  :=Getmv("MV_SOMA") //Determina se o lancam. tipo 3 ira ser somado 1 ou 2 vezes
Local cCondicao		:= ""
Local cSeqLan	:= "001"
Local cSeqHis	:= "001"
Local nRecTMP	:= TMP->(Recno())

//// TRATAMENTO NUMERACAO DO SEQLAN/SEQHIS CASO O CT2_DC NÃO SEJA PREENCHIDO E A LINHA SEJA DELETADA
If Empty(TMP->CT2_DC)
	TMP->CT2_DC := "4"								//// PREENCHE POR DEFAULT COM TIPO 4 (CONT. HISTORICO)
	//Gravacao do TMP->CT2_SEQLAN
	dbSelectArea("TMP")                                                                		
	nRecTMP	:= Recno()
	dbSkip(-1) 			//Procuro pela sequencia, para poder calcular a proxima. 
	If !Bof()
		cSeqLan	:= TMP->CT2_SEQLAN
		cSeqHis	:= StrZero((Val(TMP->CT2_SEQHIS)+1),3)				
	Else 
		cSeqLan 			:= '001'
		cSeqHis 			:= '001'
	Endif			            

	dbGoto(nRecTMP)
		
	TMP->CT2_SEQLAN		:= cSeqLan
	TMP->CT2_SEQHIS		:= cSeqHis
EndIf

//Se chamar do CTBA105, tem alguns programas que nao inicializam a variavel 
//INCLUI ou ALTERA. 

If Empty(nOpc) .Or. nOpc == Nil 
	cCondicao := INCLUI .Or. ALTERA
Else
	cCondicao := (nOpc == 4 .Or. nOpc == 3)
Endif

If cCondicao
	nValLcto:=TMP->CT2_VALOR
	
	IF nValLcto = 0 .and. TMP->CT2_DC$"123".and.SubStr(TMP->CT2_CONVER,1,1)=="1"
		Return(.T.)
	End

	IF TMP->CT2_DC $ "13"
		If TMP->CT2_FLAG == .F.
			aTotRdpe[1][2] -=  nValLcto                            
			aTotRdpe[2][2] -=  nValLcto			
		Else                 
			aTotRdpe[1][2] +=  nValLcto
			aTotRdpe[2][2] +=  nValLcto						
		Endif
	EndIf

	IF TMP->CT2_DC $ "23"
		If TMP->CT2_FLAG == .F.                               
			aTotRdpe[1][3] -=  nValLcto
			aTotRdpe[2][3] -=  nValLcto						
		Else                  
			aTotRdpe[1][3] +=  nValLcto
			aTotRdpe[2][3] +=  nValLcto						
		Endif
	EndIf
		
	IF TMP->CT2_DC $ "3"
		If TMP->CT2_FLAG == .F.
			aTotRdpe[1][1] -=IIF(nMvSoma==1,nValLcto,nValLcto*2)
			aTotRdpe[2][1] -=IIF(nMvSoma==1,nValLcto,nValLcto*2)
		Else                                              
			aTotRdpe[1][1]+=IIF(nMvSoma==1,nValLcto,nValLcto*2) 
			aTotRdpe[2][1]+=IIF(nMvSoma==1,nValLcto,nValLcto*2)			
		Endif                   		
	Else                        
		If TMP->CT2_FLAG == .F.
			aTotRdpe[1][1] -=nValLcto                                      
			aTotRdpe[2][1] -=nValLcto                                      
		Else
			aTotRdpe[1][1] +=nValLcto		                                
			aTotRdpe[2][1] +=nValLcto                                      
		Endif
	Endif

EndIf

ct102ImpT()

Return(.t.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CTB102Exibe³ Autor ³ Simone Mie Sato       ³ Data ³ 09.02.01³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Efetua calculos dos totalizadores                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CTB102Exibe(nvalLcto,nValorAnt,cTipo,cTipAnt,nMvSoma)       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. 				                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ CTBA102/CTBA105                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Valor do lancamento                                ³±±
±±³          ³ ExpN2 = Valor anterior do lancamento                       ³±±
±±³          ³ ExpC1 = Tipo do lancamento                                 ³±±
±±³          ³ ExpC2 = Tipo anterior do lancamento                        ³±±
±±³          ³ ExpN3 = Conteudo do parametro MV_SOMA                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CTB102Exibe(nValLcto,nValorAnt,cTipo,cTipoAnt,nMvSoma)

Local aSaveArea := GetArea()

If cTipo == cTipoAnt						// Nao Houve alteracao do tipo do lancamento
	IF cTipo $ "13"
		aTotRdPe[1][2]	+= nValLcto - nValorAnt
		aTotRdpe[2][2] += nValLcto - nValorAnt
	End
	IF cTipo $ "23"
		aTotRdPe[1][3] += nValLcto - nValorAnt
		aTotRdPe[2][3]	+= nValLcto - nValorAnt
	End
	IF cTipo $ "3"
		aTotRdPe[1][1] -= IIF(nMvSoma==1,nValorAnt,nValorAnt*2)
		aTotRdPe[2][1] -= IIF(nMvSoma==1,nValorAnt,nValorAnt*2)		
	Else
		aTotRdPe[1][1] -= nValorAnt
		aTotRdPe[2][1] -= nValorAnt		
	End
	IF cTipo $ "3"
		aTotRdPe[1][1] += IIF(nMvSoma==1,nValLcto,nValLcto*2)
		aTotRdPe[2][1] += IIF(nMvSoma==1,nValLcto,nValLcto*2)
	Else
		aTotRdPe[1][1] += nValLcto
		aTotRdPe[2][1] += nValLcto
	End
Else
	If cTipoAnt == "2" .And. cTipo == "1"  		// C -> D
		aTotRdPe[1][3] -= nValLcto
		aTotRdPe[1][2]	+= nValLcto                     
		aTotRdPe[2][3] -= nValLcto
		aTotRdPe[2][2]	+= nValLcto
	ElseIf cTipoAnt == "3" .And. cTipo == "1" 	// X -> D
		aTotRdPe[1][3]	-= nValLcto
		aTotRdPe[2][3]	-= nValLcto
		aTotRdPe[1][1] -= Iif(nMvSoma == 2, nValLcto, 0)
	ElseIf cTipoAnt == "1" .And. cTipo == "2" 	// D -> C
		aTotRdPe[1][2] -= nValLcto
		aTotRdPe[1][3] += nValLcto                     
		aTotRdPe[2][2] -= nValLcto
		aTotRdPe[2][3] += nValLcto		
	ElseIf cTipoAnt == "3" .And. cTipo == "2" 	// X -> C
		aTotRdPe[1][2] -= nValLcto
		aTotRdPe[2][2] -= nValLcto		
		aTotRdPe[1][1] -=  Iif(nMvSoma == 2, nValLcto, 0)
	ElseIf cTipoAnt == "1"	.And. cTipo == "3"	// D -> X
		aTotRdPe[1][3] += nValLcto
		aTotRdPe[2][3] += nValLcto
		aTotRdPe[1][1] += Iif(nMvSoma == 2,nValLcto,0)						
	ElseIf cTipoAnt == "2" .And. cTipo == "3" 	// C -> X
		aTotRdPe[1][2] += nValLcto
		aTotRdPe[2][2] += nValLcto
		aTotRdPe[1][1] += Iif(nMvSoma == 2,nValLcto,0)						
	ElseIf cTipoAnt $ "1" .And. cTipo == "4"	
		aTotRdPe[1][2]	-= nValLcto
		aTotRdPe[2][2]	-= nValLcto
		aTotRdPe[1][1] -= Iif(nMvSoma == 2, nValLcto, 0)
	ElseIf cTipoAnt $ "2" .And. cTipo == "4"			
		aTotRdPe[1][3]	-= nValLcto
		aTotRdPe[2][3]	-= nValLcto
		aTotRdPe[1][1] -= Iif(nMvSoma == 2, nValLcto, 0)
	ElseIf cTipoAnt $ "3" .And. cTipo == "4"				
		aTotRdPe[1][2]	-= nValLcto
		aTotRdPe[2][2]	-= nValLcto	
		aTotRdPe[1][3]	-= nValLcto
		aTotRdPe[2][3]	-= nValLcto
		aTotRdPe[1][1] -= Iif(nMvSoma == 2, nValLcto, 0)			
	EndIf			
	
EndIf	

// Refresh da tela de rodape
Ct102ImpT()

RestArea(aSaveArea)

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CT102ImpT  ³ Autor ³ Simone Mie Sato       ³ Data ³ 09.02.01³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Efetua calculos dos totalizadores                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CT102ImpT                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ CTBA102/CTBA105                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Ct102ImpT()

If Type("oDig") # "U" 
	oDig:Refresh()
Endif
If Type("oDeb") # "U" 
	oDeb:Refresh()
Endif
If Type("oCred") # "U" 
	oCred:Refresh()
EndIf	

Return("")

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³CtCGCCabec³ Autor ³ Simone Mie Sato       ³ Data ³ 05/02/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³Monta Cabecalho do relatorio                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe   ³CtCGCCabec(lItem,lCusto,lCLVL,Cabec1,Cabec2,dDataFim,Titulo ³±±
±±³           ³lAnalitico,cTipo,Tamanho)                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³ SIGACTB                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ExpL1 = Indica se imprime item							   ³±±
±±³           ³ExpL2 = Indica se imprime c.custo						   ³±±
±±³           ³ExpL3 = Indica se imprime classe de valor				   ³±±
±±³           ³ExpC1 = Conteudo da cabec1               				   ³±±
±±³           ³ExpC2 = Conteudo da cabec2               				   ³±±
±±³           ³ExpD1 = Data final do relatorio          				   ³±±
±±³           ³ExpC3 = Titulo                           				   ³±±
±±³           ³ExpL4 = Indica se imprime analitico      				   ³±±
±±³           ³ExpC4 = Tipo                             				   ³±±
±±³           ³ExpN1 = Tamanho                          				   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtCGCCabec(lItem,lCusto,lCLVL,Cabec1,Cabec2,dDataFim,Titulo,lAnalitico,cTipo,Tamanho)

DEFAULT Tamanho := "G"
SX3->(DbSetOrder(2))
SX3->(MsSeek("A1_CGC",.t.))
If cTipo == '1'
	Tamanho := Iif(((lItem .Or. lCusto .Or. lCLVL) .And. lAnalitico),"G",Tamanho)
	nTam    := Iif(lItem .Or. lCusto .Or. lCLVL .or. Tamanho == "G", 218, 130)
ElseIf cTipo == '2'
	nTam    := Iif(Tamanho == 'G', 218, 130)
Endif

If SM0->(Eof())
	SM0->(MsSeek(cEmpAnt+cFilAnt,.T.))
Endif

aCabec := {	"__LOGOEMP__",;
			Left(Padc(AllTrim(SM0->M0_NOMECOM),nTam),nTam-Len(RptFolha+" "+ TRANSFORM(m_pag,'999999')+ "  "))+;
			RptFolha+" "+ TRANSFORM(m_pag,'999999')+ "  ",;
			Left(Padc(Transform(Alltrim(SM0->M0_CGC),alltrim(SX3->X3_PICTURE)),nTam),nTam-Len(RptDtRef+" "+DTOC(dDataBase)))+RptDtRef+" "+DTOC(dDataFim),;
			Pad("SIGA /"+NomeProg+"/v."+cVersao + Padc(Trim(Titulo),nTam-(Len("SIGA /"+NomeProg+"/v."+cVersao))-If(__SetCentury(),19,17)),nTam),;
			RptHora+" "+time() + PadL(RptEmiss+ " " + Dtoc(dDataBase),nTam-Len(RptHora+" "+time()))}

If cTipo == '1' //Se for Razao			  
	Cabec(Titulo,Cabec1,cabec2,nomeprog,tamanho,Iif(lItem .Or. lCusto .Or. lCLVL .or. aReturn[4]==1,GetMv("MV_COMP"),;
			GetMv("MV_NORM")), aCabec )
ElseIf cTipo == '2' //Se for Balancete
	cabec(Titulo,Cabec1,cabec2,nomeprog,tamanho,Iif(aReturn[4]==1,GetMv("MV_COMP"),;
		GetMv("MV_NORM")), aCabec )
Endif
		
Return
               

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³CtbCabec  ³ Autor ³ Simone Mie Sato       ³ Data ³ 24.07.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Cabecalho Especifico do SIGACTB.           				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbCabec()	 											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³nLin        												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 = Titulo										  	  ³±±
±±³          ³ExpC2 = Cabec1										  	  ³±±
±±³          ³ExpC1 = Cabec2										  	  ³±±
±±³          ³ExpC1 = Nome do Programa								  	  ³±±
±±³          ³ExpN1 = Tamanho										  	  ³±±
±±³          ³ExpN2 = Caracter										  	  ³±±
±±³          ³ExpA1 = Texto Padrao									  	  ³±±
±±³          ³ExpL1 = Se Imprime as perguntas ou nao				  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION CtbCabec(cTitulo,cCabec1,cCabec2,cNomPrg,nTamanho,nChar,aCustomText,lPerg)

Local cAlias,nLargura,nLin:=0, aDriver := ReadDriver(),nCont:= 0, cVar,uVar,cPicture
Local lWin := .f.
Local nRow, nCol
Default aCustomText := Nil // Parâmetro que se passado suprime o texto padrao desta função por outro customizado

#DEFINE INIFIELD    Chr(27)+Chr(02)+Chr(01)
#DEFINE FIMFIELD    Chr(27)+Chr(02)+Chr(02)
#DEFINE INIPARAM    Chr(27)+Chr(04)+Chr(01)
#DEFINE FIMPARAM    Chr(27)+Chr(04)+Chr(02)

lPerg := If(GetMv("MV_IMPSX1") == "S" ,.T.,.F.)

cNomPrg := Alltrim(cNomPrg)

Private cSuf:=""

If TYPE("__DRIVER") == "C"
	If "DEFAULT"$__DRIVER
		lWin := .t.
	EndIf
EndIf

nLargura:=132

IF aReturn[5] == 1   // imprime em disco
   lWin := .f.    // Se eh disco , nao eh windows
Endif

nRow := PRow()
nCol := PCol()

If aReturn[5] <> 2 // Se nao for via Windows manda os caracteres para setar a impressora
	If nChar == NIL .and. !lWin .and. __cInternet == Nil
		@ 0,0 PSAY &(If(nTamanho=="P",aDriver[1],If(nTamanho=="G",aDriver[5],(If(aReturn[4]=1,aDriver[3],aDriver[4])))))		
	ElseIf !lWin .and. __cInternet == Nil
		If nChar == 15
			@ 0,0 PSAY &(If(nTamanho=="P",aDriver[1],If(nTamanho=="G",aDriver[5],(If(aReturn[4]=1,aDriver[3],aDriver[4])))))
		Else
			@ 0,0 PSAY &(If(nTamanho=="P",aDriver[2],If(nTamanho=="G",aDriver[6],aDriver[4])))
		EndIf
	EndIf
EndIF
If GetMV("MV_CANSALT",,.T.) // Saltar uma página na impressão
	If GetMv("MV_SALTPAG",,"S") != "N"
		Setprc(nRow,nCol)
	EndIf	
Endif

// Impressão da lista de parametros quando solicitada
If lPerg .and. Substr(cAcesso,101,1) == "S"
	// Imprime o cabecalho padrao
	nLin := SendCabec(lWin, nLargura, cNomPrg, RptParam+" - "+Alltrim(cTitulo), "", "", .F.)
	cAlias := Alias()
	DbSelectArea("SX1")
	MsSeek(cPerg)
	@ nLin+=2, 5 PSAY INIPARAM
	While !EOF() .AND. X1_GRUPO = cPerg
		cVar := "MV_PAR"+StrZero(Val(X1_ORDEM),2,0)
		@(nLin+=2),5 PSAY INIFIELD+RptPerg+" "+ X1_ORDEM + " : "+ AllTrim(X1Pergunt())+FIMFIELD
		If X1_GSC == "C"
			xStr:=StrZero(&cVar,2)
			If ( &(cVar)==1 )
				@ nLin,Pcol()+3 PSAY INIFIELD+X1Def01()+FIMFIELD
			ElseIf ( &(cVar)==2 )
				@ nLin,Pcol()+3 PSAY INIFIELD+X1Def02()+FIMFIELD
			ElseIf ( &(cVar)==3 )
				@ nLin,Pcol()+3 PSAY INIFIELD+X1Def03()+FIMFIELD
			ElseIf ( &(cVar)==4 )
				@ nLin,Pcol()+3 PSAY INIFIELD+X1Def04()+FIMFIELD
			ElseIf ( &(cVar)==5 )
				@ nLin,Pcol()+3 PSAY INIFIELD+X1Def05()+FIMFIELD
			Else					
				@ nLin,Pcol()+3 PSAY INIFIELD+''+FIMFIELD
			EndIf
		Else
			uVar := &(cVar)
			If ValType(uVar) == "N"
				cPicture:= "@E "+Replicate("9",X1_TAMANHO-X1_DECIMAL-1)
				If( X1_DECIMAL>0 )
					cPicture+="."+Replicate("9",X1_DECIMAL)
				Else
					cPicture+="9"
				EndIf
				@nLin,Pcol()+3 PSAY INIFIELD+Transform(Alltrim(Str(uVar)),cPicture)+FIMFIELD
			Elseif ValType(uVar) == "D"
				@nLin,Pcol()+3 PSAY INIFIELD+DTOC(uVar)+FIMFIELD
			Else
				@nLin,Pcol()+3 PSAY INIFIELD+uVar+FIMFIELD
			EndIf
		EndIf
		DbSkip()
	Enddo
	cFiltro := Iif (!Empty(aReturn[7]),MontDescr("CT2",aReturn[7]),"")
	nCont := 1
	If !Empty(cFiltro)
		nLin+=2
		@ nLin,5  PSAY  INIFIELD+ STR0004 + Substr(cFiltro,nCont,nLargura-19)+FIMFIELD  // "Filtro      : "
		While Len(AllTrim(Substr(cFiltro,nCont))) > (nLargura-19)
			nCont += nLargura - 19
			nLin+=1
			@ nLin,19	PSAY	INIFIELD+Substr(cFiltro,nCont,nLargura-19)+FIMFIELD
		Enddo
		nLin++
	EndIf
	nLin++
	@ nLin ,00  PSAY __PrtFatLine()+FIMPARAM
	DbSelectArea(cAlias)
EndIf
	
@ 00,00 PSAY __PrtFatLine()
@ 01,00 PSAY __PrtLogo()
@ 01,00 PSAY __PrtCenter(aCustomText[1])		 
@ 01,00 PSAY __PrtRight(aCustomText[2])	 
@ 02,00 PSAY __PrtCenter(aCustomText[3])	 
@ 02,00 PSAY __PrtRight(aCustomText[4])	 
@ 03,00 PSAY __PrtLeft(aCustomText[5])	 
@ 03,00 PSAY __PrtCenter(aCustomText[6])		 
@ 04,00 PSAY __PrtLeft(aCustomText[7])		 
@ 04,00 PSAY __PrtRight(aCustomText[8])		 
@ 05,00 PSAY __PrtFatLine()

If LEN(Trim(cCabec1)) != 0
	@ 06,00  PSAY cCabec1
EndIf     
nLin :=07 
If LEN(Trim(cCabec2)) != 0
	@ nLin,00  PSAY cCabec2
	@ nLin+1,00  PSAY __PrtThinLine()
	nLin :=09 	
Else
	@ nLin,00  PSAY  __PrtThinLine()
	nLin := 08
EndIf

m_pag++
If Subs(__cLogSiga,4,1) == "S"
	__LogPages()
EndIf

Return nLin

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CtbAmarra  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 04.07.01³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se as amarracoes sao permitidas                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbAmarra(Cta,cc,Item,Clvlr,Posiciona?)					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T./.F.                                   				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta                                              ³±±
±±³          ³ ExpC2 = Centro de Custo                                    ³±±
±±³          ³ ExpC3 = Item                                               ³±±
±±³          ³ ExpC4 = Classe de Valor                                    ³±±
±±³          ³ ExpL1 = Indica se deve posicionar ou nao                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbAmarra(cConta,cCusto,cItem,cCLVL,lPosiciona,lHelp)

Local lRet		:= .T.
Local lTem		:= .F.
Local aArea 	:= GetArea()
Local cCodigo	:= ""
Local nPos		:= 0
DEFAULT lHelp	:= .T.

If lPosiciona
	CtbPosic(cConta,cCusto,cItem,cClvl)
EndIf

/*********************************************************
//
//	Neste sentido eh considerado REGRA
//	--------------------------------------------->>>>>
//
//  	NIVEL 1				NIVEL 2		NIVEL 3
//  	+---------------+	+-------+	+--------+
//  	|               |	|		|	|      	 |
//		CONTA  			C.CUSTO		ITEM	CLASSE VALOR
//
//	Neste sentido eh considerado CONTRA-REGRA
//	<<<<<---------------------------------------------
//
//**********************************************************/

// Validacao do Plano de Contas
If !Empty(cConta)
	// NIVEL 1 => CONTA -> CCUSTO
	If (!Empty(CT1->CT1_RGNV1) .And. (! Empty(cCusto) .And. !Empty(CTT->CTT_CRGNV1)))
		If AT("/",CTT->CTT_CRGNV1) > 0 //Se tiver mais de um codigo de amarracao
			cCodigo := CTT->CTT_CRGNV1
			While !Empty(cCodigo)
				nPos	:= AT("/",cCodigo)	 
				If nPos > 0  		
					If (Alltrim(Subs(cCodigo,1,nPos-1)) $ Alltrim(CT1->CT1_RGNV1))
						lTem := .T.
						Exit
					EndIf
					cCodigo := Subs(cCodigo,nPos+1,Len(CTT->CTT_CRGNV1)) 				
				Else
					If (Alltrim(cCodigo) $ Alltrim(CT1->CT1_RGNV1))				
						lTem := .T.
					EndIf          
					Exit					
				EndIf
			End		
			If !lTem
				If lHelp
					Help(" ",1,"NOAMARRA01")
				EndIf
				lRet	:= .F.
			EndIf
		Else //Se tiver somente um codigo no campo CTT_CRGNV1				
			If !(Alltrim(CTT->CTT_CRGNV1) $ Alltrim(CT1->CT1_RGNV1))
				If lHelp
					Help(" ",1,"NOAMARRA01")
				EndIf
				lRet := .F.
			EndIF
		EndIf
    EndIf
    
	// NIVEL 2 => CONTA -> ITEM
	If lRet                               
		lTem   		:= .F. 
		cCodigo		:= ""
		If (!Empty(CT1->CT1_RGNV2) .And. (! Empty(cItem) .And. !Empty(CTD->CTD_CRGNV1)))
			If AT("/",CTD->CTD_CRGNV1) > 0 //Se tiver mais de um codigo de amarracao		
				cCodigo := CTD->CTD_CRGNV1			
				While !Empty(cCodigo)
					nPos	:= AT("/",cCodigo)	 
					If nPos > 0  		
						If (Alltrim(Subs(cCodigo,1,nPos-1)) $ Alltrim(CT1->CT1_RGNV2))
							lTem := .T.
							Exit
						EndIf
						cCodigo := Subs(cCodigo,nPos+1,Len(CTD->CTD_CRGNV1)) 				
					Else
						If (Alltrim(cCodigo) $ Alltrim(CT1->CT1_RGNV2))				
							lTem := .T.
						EndIf          
						Exit					
					EndIf
				End		
				If !lTem
					If lHelp
						Help(" ",1,"NOAMARRA02")
					EndIf
					lRet	:= .F.
				EndIf
			Else								
				If !(Alltrim(CTD->CTD_CRGNV1) $ Alltrim(CT1->CT1_RGNV2))			
					If lHelp
						Help(" ",1,"NOAMARRA02")
					EndIf
					lRet := .F.
				EndIF					
		    EndIf
		EndIf
	EndIf

	// NIVEL 3 => CONTA -> CLASSE VALOR
	If lRet
		lTem   		:= .F. 
		cCodigo		:= ""
		If (!Empty(CT1->CT1_RGNV3) .And. (! Empty(cClVl) .And. !Empty(CTH->CTH_CRGNV1)))
			If AT("/",CTH->CTH_CRGNV1) > 0 //Se tiver mais de um codigo de amarracao		
				cCodigo := CTH->CTH_CRGNV1			
				While !Empty(cCodigo)
					nPos	:= AT("/",cCodigo)	 
					If nPos > 0  		
						If (Alltrim(Subs(cCodigo,1,nPos-1)) $ Alltrim(CT1->CT1_RGNV3))
							lTem := .T.
							Exit
						EndIf
						cCodigo := Subs(cCodigo,nPos+1,Len(CTH->CTH_CRGNV1)) 				
					Else
						If (Alltrim(cCodigo) $ Alltrim(CT1->CT1_RGNV3))				
							lTem := .T.
						EndIf          
						Exit					
					EndIf
				End		
				If !lTem
					If lHelp
						Help(" ",1,"NOAMARRA03")
					EndIf
					lRet	:= .F.
				EndIf
			Else								
				If !(Alltrim(CTH->CTH_CRGNV1) $ Alltrim(CT1->CT1_RGNV3))
					If lHelp
						Help(" ",1,"NOAMARRA03")
					EndIf
					lRet := .F.
				EndIF
		    EndIf		
	    EndIf
	EndIf	    
EndIf

// Validacao do Centro de Custo
If !Empty(cCusto) .And. lRet
	// NIVEL 2 => CCUSTO -> ITEM
	If lRet
		lTem	:= .F.
		cCodigo	:= ""
		If (!Empty(CTT->CTT_RGNV2) .And. (! Empty(cItem) .And. !Empty(CTD->CTD_CRGNV2)))
			If AT("/",CTD->CTD_CRGNV2) > 0 //Se tiver mais de um codigo de amarracao		
				cCodigo := CTD->CTD_CRGNV2			
				While !Empty(cCodigo)
					nPos	:= AT("/",cCodigo)	 
					If nPos > 0  		
						If (Alltrim(Subs(cCodigo,1,nPos-1)) $ Alltrim(CTT->CTT_RGNV2))
							lTem := .T.
							Exit
						EndIf
						cCodigo := Subs(cCodigo,nPos+1,Len(CTD->CTD_CRGNV2)) 				
					Else
						If (Alltrim(cCodigo) $ Alltrim(CTT->CTT_RGNV2))				
							lTem := .T.
						EndIf          
						Exit					
					EndIf
				End		
				If !lTem
					If lHelp
						Help(" ",1,"NOAMARRA04")
					EndIf
					lRet	:= .F.
				EndIf
			Else								
				If !(Alltrim(CTD->CTD_CRGNV2) $ Alltrim(CTT->CTT_RGNV2))
					If lHelp
						Help(" ",1,"NOAMARRA04")
					EndIf
					lRet := .F.
				EndIF
		    EndIf
		  EndIf
	EndIf	    
	// NIVEL 3 => CCUSTO -> CLASSE VALOR
	If lRet
		lTem	:= .F.
		cCodigo	:= ""                      
		If (!Empty(CTT->CTT_RGNV3) .And. (! Empty(cClVl) .And. !Empty(CTH->CTH_CRGNV2)))		
			If AT("/",CTH->CTH_CRGNV2) > 0 //Se tiver mais de um codigo de amarracao		
				cCodigo := CTH->CTH_CRGNV2			
				While !Empty(cCodigo)
					nPos	:= AT("/",cCodigo)	 
					If nPos > 0  		
						If (Alltrim(Subs(cCodigo,1,nPos-1)) $ Alltrim(CTT->CTT_RGNV3))
							lTem := .T.
							Exit
						EndIf
						cCodigo := Subs(cCodigo,nPos+1,Len(CTH->CTH_CRGNV2)) 				
					Else
						If (Alltrim(cCodigo) $ Alltrim(CTT->CTT_RGNV3))				
							lTem := .T.
						EndIf          
						Exit					
					EndIf
				End		
				If !lTem
					If lHelp
						Help(" ",1,"NOAMARRA05")
					EndIf
					lRet	:= .F.
				EndIf
			Else								
				If !(Alltrim(CTH->CTH_CRGNV2) $ Alltrim(CTT->CTT_RGNV3))
					If lHelp
						Help(" ",1,"NOAMARRA05")
					EndIf
					lRet := .F.
				EndIF
		    EndIf
		EndIf	    
	EndIf
EndIf

// Validacao do Item Contabil
If !Empty(cItem) .And. lRet
	// NIVEL 3 => ITEM -> CLASSE VALOR
	If lRet
		lTem 		:= .F.
		cCodigo     := ""

		If (!Empty(CTD->CTD_RGNV3) .And. (! Empty(cClVl) .And. !Empty(CTH->CTH_CRGNV3)))
			If AT("/",CTH->CTH_CRGNV3) > 0 //Se tiver mais de um codigo de amarracao		
				cCodigo := CTH->CTH_CRGNV3			
				While !Empty(cCodigo)
					nPos	:= AT("/",cCodigo)	 
					If nPos > 0  		
						If (Alltrim(Subs(cCodigo,1,nPos-1)) $ Alltrim(CTD->CTD_RGNV3))
							lTem := .T.
							Exit
						EndIf
						cCodigo := Subs(cCodigo,nPos+1,Len(CTH->CTH_CRGNV3)) 				
					Else
						If (Alltrim(cCodigo) $ Alltrim(CTD->CTD_RGNV3))				
							lTem := .T.
						EndIf          
						Exit					
					EndIf
				End		
				If !lTem
					If lHelp
						Help(" ",1,"NOAMARRA06")
					EndIf
					lRet	:= .F.
				EndIf
			Else																
				If !(Alltrim(CTH->CTH_CRGNV3) $ Alltrim(CTD->CTD_RGNV3))		
					If lHelp
						Help(" ",1,"NOAMARRA06")
					EndIf
					lRet := .F.
				EndIF
		    EndIf
		EndIf
	EndIf	    
EndIf
		
RestArea(aArea)
Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CtbPosic   ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 04.07.01³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Posiciona nos registros de cadastros                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbPosic(Cta,cc,Item,Clvlr)                        		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T./.F.                                   				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta                                              ³±±
±±³          ³ ExpC2 = Centro de Custo                                    ³±±
±±³          ³ ExpC3 = Item                                               ³±±
±±³          ³ ExpC4 = Classe de Valor                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbPosic(cConta,cCusto,cItem,cCLVL)

// Plano de Contas
If cConta <> Nil //.And. ! Empty(cConta)
	dbSelectArea("CT1")
	dbSetOrder(1)
	MsSeek(xFilial("CT1")+cConta)
Endif

If cCusto <> Nil //.And. ! Empty(cCusto)
	// Centro de Custo
	dbSelectArea("CTT")
	dbSetOrder(1)
	MsSeek(xFilial("CTT")+cCusto)
Endif	
// Item Contabil
If cItem <> Nil //.And. ! Empty(cItem)
	dbSelectArea("CTD")
	dbSetOrder(1)
	MsSeek(xFilial("CTD")+cItem)
Endif
// Classe de Valor
If cCLVL <> Nil	 //.And. ! Empty(cClVl)
	dbSelectArea("CTH")
	dbSetOrder(1)
	MsSeek(xFilial("CTH")+cCLVL)
Endif

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CtbObrig   ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 04.07.01³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se as amarracoes sao permitidas                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbObrig(Cta,cc,Item,Clvlr,Posiciona?)					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T./.F.                                   				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta                                              ³±±
±±³          ³ ExpC2 = Centro de Custo                                    ³±±
±±³          ³ ExpC3 = Item                                               ³±±
±±³          ³ ExpC4 = Classe de Valor                                    ³±±
±±³          ³ ExpL1 = Indica se deve posicionar ou nao                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbObrig(cConta,cCusto,cItem,cClvl,lPosiciona,cTipo,lHelp)

Local aSaveAREA := GetArea()
Local cEntidade	:= ""
Local cSayCusto	:= CtbSayApro("CTT")
Local cSayItem	:= CtbSayApro("CTD")
Local cSayClVL	:= CtbSayApro("CTH")
Local lRet		:= .T.
DEFAULT lHelp	:= .T.

If lPosiciona
	CtbPosic(cConta,cCusto,cItem,cClvl)
EndIF	

If cTipo != Nil
	If cTipo == "1"
		cDC := STR0020
	Else
		cDc :=STR0021
	EndIf
Else
	cDc := " "
EndIf			

// Testar Validacao de CT1_CCOBRG / CT1_ITOBRG / CT1_CLOBRG
If lRet
	cEntidade := STR0016
	If CT1->CT1_CCOBRG == "1" .And. Empty(cCusto)
		cEntidade += cSayCusto + cDC
		If lHelp
			Help(" ",1,"ENTIDOBRIG",,cEntidade,3,1)
		EndIf
		lRet := .F.
	EndIf
	If lRet
		If CT1->CT1_ITOBRG == "1" .And. Empty(cItem)
			cEntidade += cSayItem + cDC
			If lHelp
				Help(" ",1,"ENTIDOBRIG",,cEntidade,3,1)
			EndIf
			lRet := .F.
		EndIf
	EndIf
	If lRet
		If CT1->CT1_CLOBRG == "1" .And. Empty(cClVL)
			cEntidade += cSayCLVL + cDc
			If lHelp
				Help(" ",1,"ENTIDOBRIG",,cEntidade,3,1)
			EndIf
			lRet := .F.
		EndIf
	EndIf
EndIf                 

// Testar Validacao de CTT_ITOBRG / CTT_CLOBRG
If lRet                            
	cEntidade := STR0016
	If CTT->CTT_ITOBRG == "1" .And. Empty(cItem)
		cEntidade	+= cSayItem + cDC
		If lHelp
			Help(" ",1,"ENTIDOBRIG",,cEntidade,3,1)
		EndIf
		lRet := .F.
	EndIf          
	If lRet            
		If CTT->CTT_CLOBRG == "1" .And. Empty(cClVl)
			cEntidade	+= 	cSayClVl + cDC
			If lHelp
				Help(" ",1,"ENTIDOBRIG",,cEntidade,3,1)
			EndIf
			lRet := .F.
		EndIf	
	EndIf
EndIf

// Testar Validacao de CTD_CLOBRG
If lRet                 
	cEntidade := STR0016
	If CTD->CTD_CLOBRG == "1" .And. Empty(cClVl)
		cEntidade	+= 	cSayClVl + cDC
		If lHelp
			Help(" ",1,"ENTIDOBRIG",,cEntidade,3,1)
		EndIf
		lRet := .F.
	EndIf	
EndIf


// Testar Validacao de CT1_ACCUSTO / CT1_ACITEM / CT1_ACCLVL
// Se nao aceita entidade e entidade preenchida -> Help!!
If lRet
	cEntidade := STR0019
	If CT1->CT1_ACCUST == "2" .And. !Empty(cCusto)
		cEntidade += cSayCusto + cDC
		If lHelp
			Help(" ",1,"NAOACENTID",,cEntidade,3,1)
		EndIf
		lRet := .F.
	EndIf
	If lRet
		If CT1->CT1_ACITEM == "2" .And. !Empty(cItem)
			cEntidade += cSayItem + cDC
			If lHelp			
				Help(" ",1,"NAOACENTID",,cEntidade,3,1)
			EndIf
			lRet := .F.
		EndIf
	EndIf
	If lRet
		If CT1->CT1_ACCLVL == "2" .And. !Empty(cClVL)
			cEntidade += cSayCLVL + cDC
			If lHelp
				Help(" ",1,"NAOACENTID",,cEntidade,3,1)
			EndIf
			lRet := .F.
		EndIf
	EndIf
EndIf

// Testar Validacao de CTT_ACITEM / CTT_ACCLVL
If lRet
//	cEntidade	:= STR0067
	cEntidade	:= "O centro de custo nao permite lancamento com a entidade "
	If CTT->CTT_ACITEM == "2" .And. !Empty(cItem)
		cEntidade += cSayItem + cDC
		If lHelp
			Help(" ",1,"NCCACENTID",,cEntidade,3,1)
		EndIf
		lRet := .F.
	EndIf
	
	If lRet
		If CTT->CTT_ACCLVL == "2" .And. !Empty(cClVl)	
			cEntidade += cSayClVl + cDC
			If lHelp
				Help(" ",1,"NCCACENTID",,cEntidade,3,1)
			EndIF
			lRet := .F.
		EndIf	
	EndIf
EndIf
         
// Testar Validacao de CTD_ACCLVL
If lRet
//	cEntidade	:= STR0068
	cEntidade	:= "O item nao permite lancamento com a entidade "
	If CTD->CTD_ACCLVL == "2" .And. !Empty(cClVl)
		cEntidade += cSayClVl + cDC
		If lHelp
			Help(" ",1,"NITACENTID",,cEntidade,3,1)
		EndIf
		lRet := .F.
	EndIf
EndIf              

RestAREA(aSaveArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ CtbRodape³ Autor ³ Simone Mie Sato       ³ Data ³ 27.06.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Rodape dos relatorios do SIGACTB	                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbRodape(ExpO1,ExpN1, ExpN2)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpO1 = Objeto oPrint                                      ³±±
±±³          ³ ExpN1 = Contador de paginas                                ³±±
±±³          ³ ExpN2 = Contador de linhas                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Capabili                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function CtbRodape(oPrint,lin)

Local cStartPath		:= GetSrvProfString("Startpath","")

lin+=80
oPrint:Line( lin,230,lin,3200 )   	// horizontal
oPrint:SayBitmap(lin+10,230,cStartPath+"\lgrl"+cEmpAnt+".bmp",300,070) // Tem que estar abaixo do RootPath
oPrint:Say(lin+50,2800,RptEnd + " " + TIME(),oFont10 )
oPrint:Line(lin+100,230,lin+100,3200 )   	// horizontal

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ CtbCbcPad³ Autor ³ Simone Mie Sato       ³ Data ³ 27.06.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Cabecalho Padrao dos relatorios graficos.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbCbcpad(ExpO1,ExpN1,ExpC1)                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGACTB                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpO1 = Objeto oPrint                                      ³±±
±±³          ³ ExpN1 = Contador de paginas                                ³±±
±±³          ³ ExpC1 = Titulo                                             ³±±
±±³          ³ ExpC2 = Cabecalho Especifico                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CtbCbcPad(oPrint,i,titulo,cCabEsp)		
    
Local cStartPath		:= GetSrvProfString("Startpath","")
Local cSM0CGC			:= ""
Local cPicCGC			:= ""
Local aArea				:= {}
Local nIndSX3			:= 1
Local nRecSX3			:= 1
DEFAULT cCabEsp			:= ""

If Empty(cCabEsp)
	aArea := GetArea()
	dbSelectArea("SX3")
	nIndSX3 := IndexOrd()
	nRecSX3	:= Recno()
	DbSetOrder(2)                       
	If MsSeek("A1_CGC")
		cSM0CGC := AllTrim(X3Titulo())
		cPicCGC	:= alltrim(SX3->X3_PICTURE)
	ElseIf MsSeek("A2_CGC")
		cSM0CGC := AllTrim(X3Titulo())
		cPicCGC	:= alltrim(SX3->X3_PICTURE)
	Else
		cSM0CGC := If(Len(ALLTRIM(SM0->M0_CGC))>11,"C.N.P.J.:","C.P.F.:")
		cPicCGC	:= If(Len(ALLTRIM(SM0->M0_CGC))>11,"@R 99.999.999/9999-99","@R 999.999.999-99")
	Endif
	cSM0CGC := cSM0CGC+" "+Transform(Alltrim(SM0->M0_CGC),cPicCGC)
	cCabEsp	:= ALLTRIM(SM0->M0_NOMECOM)
Endif

oPrint:StartPage() 		// Inicia uma nova pagina
oPrint:Box(075,180,250,3150 ) //
oPrint:SayBitmap(078,200,cStartPath+"\lgrl"+cEmpAnt+".bmp",300,070) // Tem que estar abaixo do RootPath
oPrint:Say(085,2850,RptFolha + TRANSFORM(m_pag,'999999'),oFont08 )
oPrint:Say(090,(2850 - (Len(cCabEsp) * 16)) / 2,cCabEsp,oFont14 )
oPrint:Say(140,(2850 - (Len(cSM0CGC) * 08))/2,cSM0CGC,oFont08 )
oPrint:Say(140,200,"SIGA/"+nomeprog+"/v."+cVersao,oFont08)
oPrint:Say(140,2850,RptDtRef+dtoc(mv_par01),oFont08)        
oPrint:Say(185,(2850 - (Len(Titulo) * 16))/2,titulo,oFont14 )
oPrint:Say(185,200,RptHora +time(),oFont08)
oPrint:Say(185,2850,RptEmiss+DTOC(dDataBase),oFont08)                  

dbSelectArea("SX3")
dbSetOrder(nIndSX3)
dbGoTo(nRecSX3)

RestArea(aArea)

Return Nil
               
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ CtbCbcDem³ Autor ³ Wagner Mobile Costa   ³ Data ³ 14.10.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Cabecalho Padrao para relatorios de demonstrativo           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbCbcDem(ExpO1,ExpN1,ExpC1)                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGACTB                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpO1 = Objeto oPrint                                      ³±±
±±³          ³ ExpC1 = Cabecalho Especifico                               ³±±
±±³          ³ ExpL1 = Portrait ou LandScape                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CtbCbcDem(oPrint,titulo,lLandScape)

Local aEmpresa 			:= { "", "" }
Local nTamLin			:= 3120
Local nFont14			:= 28, nFont10 := 20
Local cCGCTxt 			:= ""
Local cEmiss			:= OemToAnsi(STR0022) + DtoC( dDataBase)
Local cStartPath		:= GetSrvProfString("Startpath","")

DEFAULT lLandScape := .T.
If Type("m_pag") !="N"
	m_pag := 1
EndIf	

If ! lLandScape
	nTamLin := 2350
Endif

SX3->(DbSetOrder(2))
SX3->(MsSeek("A1_CGC",.t.))
cCGCTxt := X3Titulo()

aEmpresa[1] := AllTrim(SM0->M0_NOMECOM)
aEmpresa[2] := Trim(cCGCTxt)+" "  + Transform(Alltrim(SM0->M0_CGC),alltrim(SX3->X3_PICTURE))

oPrint:StartPage() 		// Inicia uma nova pagina
oPrint:Box(075,150,250,nTamLin )
oPrint:SayBitmap(078,200,cStartPath+"\lgrl"+cEmpAnt+".bmp",316,78) // Tem que estar abaixo do RootPath

oPrint:Say(085,(nTamLin - (Len(aEmpresa[1]) * nFont14)) / 2,aEmpresa[1],oCouNew14 )
oPrint:Say(145,(nTamLin - (Len(aEmpresa[2]) * nFont10)) / 2,aEmpresa[2],oCouNew10 )
oPrint:Say(185,(nTamLin - (Len(Titulo) * nFont14)) / 2,titulo,oCouNew14 )
oPrint:Say(085,(nTamLin - (14 * nFont10))-40,RptFolha + TRANSFORM(m_pag,'999999'),oCouNew10 )
oPrint:Say(145,(nTamLin - (Len(cEmiss) * nFont10))-40, cEmiss,oCouNew10 )
m_pag++

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³IMPCTBSX1 ³ Autor ³ Simone Mie Sato       ³ Data ³ 08.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Imprime folha de Parametros. (Especifico p/ Rel. Graficos)  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³IMPCTBSX1()  		  		   			 					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGACTB                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpO1 = Objeto oPrint                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ImpCTBSX1(oPrint)

Local li := 245                  
Local cConteudo := ""

dbSelectArea("SX1")
dbSetOrder(1)
MsSeek(cPerg+'01')

oPrint:Line( li,180,li,3150 )   	// horizontal                          			

li := 300

While !Eof() .And. SX1->X1_GRUPO == cPerg

	If SX1->X1_GSC == "G"
		cConteudo := SX1->X1_CNT01
	ElseIf SX1->X1_GSC == "C"	                            
		If __LANGUAGE == "PORTUGUESE"			
			cConteudo := &("SX1->X1_DEF"+STRZERO(SX1->X1_PRESEL,2))
		ElseIf __LANGUAGE == "SPANISH"			
			cConteudo := &("SX1->X1_DEFSPA"+Str(SX1->X1_PRESEL,1))		
		ElseIf __LANGUAGE == "ENGLISH"		
			cConteudo := &("SX1->X1_DEFENG"+Str(SX1->X1_PRESEL,1))
		Endif	                                              
	Endif                
	
	oPrint:Say(li,250,OemToAnsi(STR0005) + SX1->X1_ORDEM + ": ",oFont10)
	If __LANGUAGE == "PORTUGUESE"	
		oPrint:Say(li,530,SX1->X1_PERGUNT,oFont10)
	ElseIf __LANGUAGE == "SPANISH"
		oPrint:Say(li,530,SX1->X1_PERSPA,oFont10)	
	ElseIf __LANGUAGE == "ENGLISH"
		oPrint:Say(li,530,SX1->X1_PERENG,oFont10)	
	Endif            	
	oPrint:Say(li,1400,cConteudo,oFont10)		
	dbSKip()                       
	li += 80
End

oPrint:Line( li+80,180,li+80,3150 )   	// horizontal                          			

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ValidaLP  ³ Autor ³ Simone Mie Sato       ³ Data ³ 23.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida Lancamento Padrao                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ValidaLP(cLP)                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T./.F.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Cod. Lancamento Padrao                             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValidaLP(cLP)

Local aSaveArea := GetArea()
Local lRet		:= .T.

IF !Empty(cLP)
	dbSelectArea("CT5")
	dbSetOrder(1)
	If !MsSeek(xFilial()+cLP)
		lRet := .F.
		Help(" ",1,"NOCODLP")
	EndIf
EndIF

RestArea(aSaveArea)

Return(lRet)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CtbCtsM      ³ Autor ³ Wagner Mobile Costa	³ Data ³ 25/10/01 ³±± 
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao para uso em consulta SXB para  apresentar registros  do ³±± 
±±³          ³ plano gerencial atual                                          ³±± 
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Ctba160                                                        ³±± 
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function CtbCtsM(lFilial)

DEFAULT lFilial := .T.

Return If(lFilial, xFilial("CTS"), "") + cCts_CodPla

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CtbGrapPrint³ Autor ³ Wagner Mobile Costa ³ Data ³ 08-11-2001 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao de impressao de grafico usando TMsPrinter              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³SIGACTB                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CtbGrafPrint(oGraphic,cProcesso,aTexto,aTabela, lLandScape, aPosCol, aPosGrh)

DEFAULT lLandScape := .T.

Private cBmpName

Processa({ || 	Ctr500Cfg(cProcesso, "CtbEnvPrint", cProcesso, .T., oGraphic, aTexto, aTabela, aPosCol, aPosGrh),;
				STR0009 }) //"Montando a impressao do grafico. Aguarde ..."

If oGraphic # Nil .and. cBmpName # Nil .And. File("\" + cBmpName) 
	Ferase("\" + cBmpName)
EndIf

Return .T.		
		
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CtbEnvPrint ³ Autor ³ Wagner Mobile Costa ³ Data ³ 08-11-2001 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta a impressao do Objeto TMsPrinter                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³SIGACTB                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CtbEnvPrint(oPrint,i,titulo,cProcesso,lLandScape,oGraphic,aTexto,aTabela,;
					 aPosCol,aPosGrh)

Local nx, x
Local lBmp 			:= !( oGraphic == NIL )

Local lin 			:= 2811
Local lFirstPage	:= .T.               
Local nTraco		:= 0
Local nMaxLin		:= If(lLandScape, 3120 - 1, 2350 - 1)

DEFAULT aPosCol	:= { 360, 1300, 2100 }
DEFAULT aPosGrh	:= { 360, 2100, 1700 }
DEFAULT aTexto  := {}
Default aTabela := {}

ProcRegua(Len(aTabela))

If lBmp
	cBmpName := CriaTrab(,.F.)+".BMP"
	oGraphic:SaveToBMP( cBmpName, "\" )
	IncProc()
Endif

For nx := 2 to Len(aTabela)

	IncProc()
	
	If lin > 2810		
		If !lFirstPage
			oPrint:Line( ntraco,150,ntraco,nMaxLin )   	// horizontal                          			
		EndIf	
		i++                                                
		oPrint:EndPage() 	 				// Finaliza a pagina
		CtbCbcDem(oPrint,titulo,lLandScape)	// Funcao que monta o cabecalho de Demonstrativos
		Lin := 250

		If Len(aTabela) > 1
			oPrint:Line( lin,150,lin+50, 150 )   		// vertical
			For x := 1 to Len(aTexto)
				oPrint:Say(Lin,aPosCol[1],aTexto[x],oCouNew08N)
				If x > 1
					lin +=47
				Endif
			Next

			oPrint:Line( lin, nMaxLin,lin+50,nMaxLin)		// Separador vertical 
			oPrint:Line( lin + 35, 150,lin+35,nMaxLin)	// Separador Horizontal
			lin +=47

			oPrint:Line( lin,150,lin+50, 150 )   		// vertical
			For x := 1 to Len(aTabela[1])
				oPrint:Say(Lin,aPosCol[x],aTabela[1,x],oCouNew08N)
			Next

			oPrint:Line( lin, nMaxLin,lin+50,nMaxLin)		// Separador vertical 
			oPrint:Line( lin + 35, 150,lin+35,nMaxLin)	// Separador Horizontal
			lin +=47
		EndIf

		lFirstPage := .F.		
	End

	oPrint:Line( lin,150,lin+50, 150 )   		// vertical

	For x := 1 to Len(aTabela[nx])
		oPrint:Say(Lin,aPosCol[x],aTabela[nx,x],oFont08)
	Next

	oPrint:Line( lin, nMaxLin,lin+50,nMaxLin)		// Separador vertical 

	lin +=47

	nTraco := lin + 1
Next

If (lin + aPosGrh[3] + 77) > 2810
	If !lFirstPage
		oPrint:Line( ntraco,150,ntraco,nMaxLin )   	// horizontal                          			
	EndIf	
	i++                                                
	oPrint:EndPage() 	 				// Finaliza a pagina
	CtbCbcDem(oPrint,titulo,lLandScape)	// Funcao que monta o cabecalho de Demonstrativos
	Lin := 250
Endif

oPrint:SayBitmap(lin+60,aPosGrh[1], "\" + cBmpName, aPosGrh[2], aPosGrh[3])
oPrint:Line(lin,150,lin + aPosGrh[3] + 77,150)                         			
oPrint:Line(lin,nMaxLin,lin + aPosGrh[3] + 77, nMaxLin)   	// Vertical

lin += (aPosGrh[3] + 77)

oPrint:Line(lin,150,lin,nMaxLin)   	// Horizontal

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³GrafSavBmp  ºAutor³Claudio D. de Souza º Data ³  30/08/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Salvar o grafico em BMP                                    º±±
±±º          ³ Parametro: oGrafic -> Objeto grafico                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Administrativo                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GrafSavBmp( oGraphic )

Local cBmpName, cTmp
Local cWhereToSave := "\" // Somente gravar abaixo do rootpath do servidor
Local cRaizServer // Onde sera criado o arquivo da imagem

cBmpName := cGetFile(STR0010 + FunName() + ".BMP", STR0011 ) //"Arquivos BMP | "###"Selecione arquivo .BMP"

If Empty(cBmpName)
	Return
Endif

If Rat("\", cBmpName) > 0
	cWhereToSave 	:= Subs(cBmpName, 1, Rat("\", cBmpName))
	cBmpName	    := Subs(cBmpName, Rat("\", cBmpName) + 1)
Endif

If At(":", cWhereToSave) > 0
	cTmp := CriaTrab(, .F.) + ".BMP"
	cRaizServer := If(issrvunix(), "/", "\")
	If oGraphic:SaveToBMP( cTmp , cRaizServer )
		__CopyFile(cRaizServer + cTmp, cWhereToSave + cBmpName)
		Ferase(cRaizServer + cTmp)
		MsgInfo(STR0012+cBmpName+STR0013) //"Arquivo: "###" gerado com sucesso"
	Else
		ApMsgAlert(STR0014) //"Nao foi possivel gerar o arquivo bitmap do grafico"
	Endif
Else
	If oGraphic:SaveToBMP( cBmpName , cWhereToSave )
		MsgInfo(STR0012+cBmpName+STR0013) //"Arquivo: "###" gerado com sucesso"
	Else
		ApMsgAlert(STR0014) //"Nao foi possivel gerar o arquivo bitmap do grafico"
	Endif
Endif

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ ConsDadGraf ³ Autor ³ Wagner Mobile Costa   ³ Data ³ 10.11.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta Browse de consulta sobre array utilizado para graficos  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ConsDadGraf(aDados)
Local aTit := {}, aLenCol := {}, nLenTot := 0
Local oView, oDlg, aView := {}, nView        
Local nX	:= 0

For nx := 1 to Len(aDados[1])
	Aadd(aTit, aDados[1][nX])
	If Len(aDados[1][nX]) > Len(aDados[2][nX])
		Aadd(aLenCol, GetTextWidth(0,Replicate("B", Len(aDados[2][nX]))))
	Else
		Aadd(aLenCol, GetTextWidth(0,Replicate("B", Len(aDados[1][nX]))))
	Endif		
	nLenTot += aLenCol[Len(aLenCol)]
Next

nLenTot := (370*nLenTot)/130

DEFINE MSDIALOG oDlg FROM 0,0 TO 285,Min(nLenTot,oMainWnd:nRight-oMainWnd:nLeft - 10)  PIXEL TITLE STR0015 //"Consulta dados do grafico"

oView	:= TWBrowse():New( 1,1,	((oDlg:nRight - oDlg:nLeft) / 2) - 5,;
		 									 (oDlg:nBottom / 2) - 15,,;
			aTit,aLenCol,oDlg,,,,,,,,,,,,.F.,,.T.,,.F.,,,)

For nView := 2 To Len(aDados)
	Aadd(aView, aDados[nView])
Next

oView:SetArray(aView)
oView:bLine := { || aView[oView:nAT]}

ACTIVATE MSDIALOG oDlg CENTER

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtQualSaldo³ Autor ³ Wagner Mobile Costa   ³ Data ³ 19.03.2002		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Checa qual registro deve ser considerado como saldo atual  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtQualSaldo(lImpAntLP, lNaoAchei, cAlias)                     	    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCtb                                                   			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Imprime posicao anterior L/P                      		    ³±±
±±³          ³ ExpL2 = Variavel que indica se a data encontrada nao for exata	    ³±±
±±³          ³ ExpB1 = Bloco de codigo de checagem se foi encontrado     		    ³±±
±±³          ³ ExpC1 = Alias para checagem                               		    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function CtQualSaldo(lImpAntLP, lNaoAchei, bCondicao, cAlias)

DEFAULT cAlias := Alias()

// Procuro sempre o primeiro registro, caso encontro um registro de zeramento
// e quero a posicao anterior de lucros e perdas, volto 	

If Eval(bCondicao) .And. &(cAlias + "_LP") = "S" .And. ! lImpAntLP
	DbSkip()
	If !Eval(bCondicao) .Or. ! &(cAlias + "_LP") = "Z"
		DbSkip(-1)
	Endif
ElseIf Eval(bCondicao) .And. &(cAlias + "_LP") = "Z" .And. lImpAntLP
	DbSkip(-1)
ElseIf (! Eval(bCondicao) .Or. Eof())
	DbSkip(-1)
	If lImpAntLP .And. &(cAlias + "_LP") = "Z"
		DbSkip(-1)
	Endif
	lNaoAchei := .T.
Endif
	
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbDescMoeda³ Autor ³ Wagner Mobile Costa  ³ Data ³ 28.04.2002		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se a descricao do campo retornado esta em branco     		³±±
±±³          ³ E em caso afirmativo retorna a descricao da primeira moeda 			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbDescMoeda(cCpoDescricao)                                   	    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCtb                                                   			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Campo para retorno da descricao (Macro-Substituicao)    		³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function CtbDescMoeda(cCpoDescricao)

Local cDescricao

If Empty((cDescricao := &(cCpoDescricao)))
	Return &(Subs(cCpoDescricao, 1, Len(cCpoDescricao) - 2) + "01")
Else
	Return cDescricao
Endif

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbStatus   ³ Autor ³ Simone Mie Sato      ³ Data ³ 18.06.2002		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se existe algum calendario encerrado no periodo solicitado	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbStatus(cCpoDescricao)                                   	  		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCtb                                                   			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Campo para retorno da descricao (Macro-Substituicao)    		³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function CtbStatus(cMoeda,dDataIni,dDataFim,lAll)

Local aSaveArea	:= GetArea()
Local aPeriodos	:= {}
Local lRet		:= .T.       
Local nPeriodos	:= 0

DEFAULT lAll	:= .T.		
If Month(dDataIni) = Month(dDataFim) .And. Year(dDataIni) = Year(dDataFim)
	aPeriodos	:= CtbPeriodos(cMoeda,dDataIni,dDataFim,.F.,.F.) 
Else                                                              
	If lAll	//Se eh para verificar o calendario inteiro
		aPeriodos	:= CtbPeriodos(cMoeda,dDataIni,dDataFim,.T.,.F.) 
	Else	//Se nao eh para verificar somente a linha do calendario solicitado. 
		aPeriodos	:= CtbPeriodos(cMoeda,dDataIni,dDataFim,.F.,.F.) 	
	EndIf
EndIf

If !Empty(aPeriodos)
	For nPeriodos := 1 to len(aPeriodos)
		If aPeriodos[nPeriodos][4] <> '1'			
			Help(" ",1,"CTGDTCOMP")		
			lRet	:= .F.
			Exit
		EndIf
	Next
EndIf
                                                   
RestArea(aSaveArea)

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbTitSaldo ³ Autor ³ Wagner Mobile Costa  ³ Data ³ 10.07.2002		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao de retorno do tipo de saldo para apresentacao nos balancetes	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbTitSaldo(cTpSald)                                         	  	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCtb                                                   			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cTpSald = Tipo de saldo selecionado                            		³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function CtbTitSaldo(cTpSald)

Local cTitulo := ""

If cTpSald = "0" .Or. cTpSald > "1"			
	cTitulo += " (" + Tabela("SL", cTpSald, .F.) + ")"
Endif

Return cTitulo

**************************************
* FUNCOES A SEREM USADAS TB NAS PLANILHAS
**************************************
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³SaldoConta ³ Autor ³ Wagner Xavier         ³ Data ³ 09.02.01³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Devolve saldos do CT7 - Planilha                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aSaldos(nQualSaldo)                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Planilha                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cConta     = Codigo da Conta                               ³±±
±±³          ³ dData      = Data                                          ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SaldoConta(cConta,dData,cMoeda,cTpSald,nQualSaldo)

Local aSaveArea	:= GetArea()
Local aSaldos	:= {}

cConta		:= Left(AllTrim(cConta) + Space(Len(CT7->CT7_CONTA)), Len(CT7->CT7_CONTA))
cTpSald 	:= Iif(cTpSald==Nil,"1",cTpSald)
nQualSaldo	:= Iif(nQualSaldo==Nil,1,nQualSaldo)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aSaldos := SaldoCt7(cConta,dData,cMoeda,cTpSald,"CTBXFUN")

RestArea(aSaveArea)

Return aSaldos[nQualSaldo]

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³SaldoCCus  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 13.07.01³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Devolve saldos do CT3 - Planilha                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aSaldos[nQualSaldo]										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Planilha                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cConta     = Codigo da Conta                               ³±±
±±³          ³ cCusto     = Centro de Custo                               ³±±
±±³          ³ dData      = Data                                          ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SaldoCCus(cConta,cCusto,dData,cMoeda,cTpSald,nQualSaldo)

Local aSaveArea	:= GetArea()
Local aSaldos	:= {0,0,0,0,0,0,0,0}
Local lTodoCT1	:= .F.
Local lTodoCTT	:= .F.

DEFAULT cConta := ""
DEFAULT cCusto := ""
nQualSaldo	:= If(nQualSaldo = Nil, 1, nQualSaldo)
cTpSald 	:= Iif(cTpSald==Nil,"1",cTpSald)

// Devolve valor somente do Centro de Custo (Soma todas as contas)
If !Empty(cCusto)
	lTodoCT1	:= !Empty(cConta) .and. UPPER(cConta) == Replicate("Z",Len(cConta)) 
	lTodoCTT	:= !Empty(cCusto) .and. UPPER(cCusto) == Replicate("Z",Len(cCusto))
	If Empty(cConta)
		cCusto	:= PadR(cCusto,Len(CTU->CTU_CODIGO))			
		aSaldos := SaldoCTU("CTT",cCusto,dData,cMoeda,cTpSald)
	ElseIf lTodoCT1 .or. lTodoCTT
		/// Saldo de uma ou todas entidades de acordo com os parâmetros ZZZZ
		If lTodoCT1
			cContaIni := ""
			cContaFim := Replicate("Z",Len(CTI->CTI_CONTA))
		Else
			cContaIni	:= PadR(cConta,Len(CTI->CTI_CONTA))					
			cContaFim	:= cContaIni
		Endif
		If lTodoCTT
			cCustoIni	:= ""
			cCustoFim	:= Replicate("Z",Len(CTI->CTI_CUSTO))
		Else
			cCustoIni	:= PadR(cCusto,Len(CTI->CTI_CUSTO))									
			cCustoFim	:= cCustoIni
		Endif
		aSaldos := SaldTotCT3(cCustoIni,cCustoFim,cContaIni,cContaFim,dData,cMoeda,cTpSald)
	Else
	// Devolve valor do Centro de Custo + Conta                     
		cConta	:= PadR(cConta,Len(CT3->CT3_CONTA))				
		cCusto	:= PadR(cCusto,Len(CT3->CT3_CUSTO))				
		aSaldos := SaldoCT3(cConta,cCusto,dData,cMoeda,cTpSald)
	EndiF	
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aSaveArea)

Return aSaldos[nQualSaldo]

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³SaldoItem  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 13.07.01³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Devolve saldos do CT4 - Planilha                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aSaldos[nQualSaldo]										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Planilha                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cConta     = Codigo da Conta                               ³±±
±±³          ³ cCusto     = Centro de Custo                               ³±±
±±³          ³ cItem      = Item                                          ³±±
±±³          ³ dData      = Data                                          ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SaldoItem(cConta,cCusto,cItem,dData,cMoeda,cTpSald,nQualSaldo)

Local aSaveArea	:= GetArea()
Local aSaldos	:= {0,0,0,0,0,0,0,0}
Local lTodoCT1	:= .F.
Local lTodoCTT	:= .F.
Local lTodoCTD	:= .F.
 
DEFAULT cConta := ""
DEFAULT cCusto := ""
DEFAULT cItem  := ""
cTpSald 	:= Iif(cTpSald==Nil,"1",cTpSald)
nQualSaldo	:= Iif(nQualSaldo==Nil,1,nQualSaldo)

If !Empty(cItem)
	lTodoCT1	:= !Empty(cConta) .and. UPPER(cConta) == Replicate("Z",Len(cConta)) 
	lTodoCTT	:= !Empty(cCusto) .and. UPPER(cCusto) == Replicate("Z",Len(cCusto))
	lTodoCTD	:= !Empty(cItem) .and. UPPER(cItem) == Replicate("Z",Len(cItem))
	// Saldo do Item (Soma todas as contas e centros de custo)
	If Empty(cConta) .And. Empty(cCusto)
		cItem	:= PadR(cItem,Len(CTU->CTU_CODIGO))					
		aSaldos := SaldoCTU("CTD",cItem,dData,cMoeda,cTpSald)
	// Saldo do Item+Centro de Custo (soma todas as contas)
	ElseIf Empty(cConta) .And. !Empty(cCusto)
		cCusto	:= PadR(cCusto,Len(CTV->CTV_CUSTO))					
		cItem	:= PadR(cItem,Len(CTV->CTV_ITEM))					
		#IFDEF TOP
			aSaldos := SldTop2Ent("CTV","CTD",cItem,cCusto,dData,dData,Val(cMoeda),cTpsald)
		#ELSE
			aSaldos := SldCmpEnt(cItem,cCusto,dData,cMoeda,cTpSald,1,"CTD","CTV","","",.F.,)			
		#ENDIF
	ElseIf lTodoCT1 .or. lTodoCTT .or. lTodoCTD
		/// Saldo de uma ou todas entidades de acordo com os parâmetros ZZZZ
		If lTodoCT1
			cContaIni := ""
			cContaFim := Replicate("Z",Len(CTI->CTI_CONTA))
		Else
			cContaIni	:= PadR(cConta,Len(CTI->CTI_CONTA))					
			cContaFim	:= cContaIni
		Endif
		If lTodoCTT
			cCustoIni	:= ""
			cCustoFim	:= Replicate("Z",Len(CTI->CTI_CUSTO))
		Else
			cCustoIni	:= PadR(cCusto,Len(CTI->CTI_CUSTO))									
			cCustoFim	:= cCustoIni
		Endif
		If lTodoCTD
			cItemIni	:= ""
 			cItemFim	:= Replicate("Z",Len(CTI->CTI_ITEM))
		Else
			cItemIni	:= PadR(cItem,Len(CTI->CTI_ITEM))					
			cItemFim	:= cItemIni
		Endif
		aSaldos := SaldTotCT4(cItemIni,cItemFim,cCustoIni,cCustoFim,cContaIni,cContaFim,dData,cMoeda,cTpSald)
		
	ElseIf !Empty(cConta)
		cConta	:= PadR(cConta,Len(CT4->CT4_CONTA))					
		cCusto	:= PadR(cCusto,Len(CT4->CT4_CUSTO))				
		cItem	:= PadR(cItem,Len(CT4->CT4_ITEM))										
		aSaldos := SaldoCt4(cConta,cCusto,cItem,dData,cMoeda,cTpSald)
	EndIf	
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

RestArea(aSaveArea)

Return aSaldos[nQualSaldo]

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³SaldoClass ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 13.07.01³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Devolve saldos do CTI - Planilha                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aSaldos[nQualSaldo]										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Planilha                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cConta     = Codigo da Conta                               ³±±
±±³          ³ cCusto     = Centro de Custo                               ³±±
±±³          ³ cItem      = Item                                          ³±±
±±³          ³ cClVl      = Classe de Valor                               ³±±
±±³          ³ dData      = Data                                          ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SaldoClass(cConta,cCusto,cItem,cCLVL,dData,cMoeda,cTpSald,nQualSaldo)

Local aSaveArea	:= GetArea()
Local aSaldos	:= {}
Local lTodoCT1	:= .F.
Local lTodoCTT	:= .F.
Local lTodoCTD	:= .F.
Local lTodoCTH	:= .F.

DEFAULT cConta := ""
DEFAULT cCusto := ""
DEFAULT cItem  := ""
DEFAULT cCLVL  := ""

cTpSald 	:= Iif(cTpSald==Nil,"1",cTpSald)
nQualSaldo	:= Iif(nQualSaldo==Nil,1,nQualSaldo)

If !Empty(cClVl)
	lTodoCT1	:= !Empty(cConta) .and. UPPER(cConta) == Replicate("Z",Len(cConta)) 
	lTodoCTT	:= !Empty(cCusto) .and. UPPER(cCusto) == Replicate("Z",Len(cCusto))
	lTodoCTD	:= !Empty(cItem) .and. UPPER(cItem) == Replicate("Z",Len(cItem))
	lTodoCTH	:= !Empty(cClVl) .and. UPPER(cCLVL) == Replicate("Z",Len(cCLVL))
	// Saldo da Classe de Valor (Soma todas as contas, centros de custo e item)
	If Empty(cConta) .And. Empty(cCusto) .And. Empty(cItem)
		cClVl	:= PadR(cClVl,Len(CTU->CTU_CODIGO))			
		aSaldos := SaldoCTU("CTH",cCLVL,dData,cMoeda,cTpSald)
	// Saldo da Classe de Valor + Item (soma todas as Contas e Centros de Custo)
	ElseIf Empty(cConta) .And. Empty(cCusto) .And. !Empty(cItem)
		cItem	:= PadR(cItem,Len(CTX->CTX_ITEM))					
		cClVl	:= PadR(cClVl,Len(CTX->CTX_CLVL))								
		#IFDEF TOP
			aSaldos := SldTop2Ent("CTX","CTH",cCLVL,cItem,dData,dData,Val(cMoeda),cTpsald)
		#ELSE
			aSaldos := SldCmpEnt(cCLVL,cItem,dData,cMoeda,cTpSald,1,"CTH","CTX","","",.F.,)			
		#ENDIF                           
	// Saldo da Classe de Valor + Centro de Custo (soma todas as contas e itens)
	ElseIf Empty(cConta) .And. !Empty(cCusto) .And. Empty(cItem)
		cItem	:= PadR(cItem,Len(CTX->CTX_ITEM))					
		cClVl	:= PadR(cClVl,Len(CTX->CTX_CLVL))									
		#IFDEF TOP
			aSaldos := SldTop2Ent("CTX","CTH",cCLVL,cItem,dData,dData,Val(cMoeda),cTpsald)
		#ELSE
			aSaldos := SldCmpEnt(cCLVL,cItem,dData,cMoeda,cTpSald,1,"CTH","CTX","","",.F.,)			
		#ENDIF
	ElseIf lTodoCT1 .or. lTodoCTT .or. lTodoCTD .or. lTodoCTH
		/// Saldo de uma ou todas entidades de acordo com os parâmetros ZZZZ
		If lTodoCT1
			cContaIni := ""
			cContaFim := Replicate("Z",Len(CTI->CTI_CONTA))
		Else
			cContaIni	:= PadR(cConta,Len(CTI->CTI_CONTA))					
			cContaFim	:= cContaIni
		Endif
		If lTodoCTT
			cCustoIni	:= ""
			cCustoFim	:= Replicate("Z",Len(CTI->CTI_CUSTO))
		Else
			cCustoIni	:= PadR(cCusto,Len(CTI->CTI_CUSTO))									
			cCustoFim	:= cCustoIni
		Endif
		If lTodoCTD
			cItemIni	:= ""
 			cItemFim	:= Replicate("Z",Len(CTI->CTI_ITEM))
		Else
			cItemIni	:= PadR(cItem,Len(CTI->CTI_ITEM))					
			cItemFim	:= cItemIni
		Endif
		If lTodoCTH
			cClVlIni	:= ""
			cClVlFim	:= Replicate("Z",Len(CTI->CTI_CLVL))
		Else
			cClVlIni	:= PadR(cClVl,Len(CTI->CTI_CLVL))
			cClVlFim	:= cClVlIni
		Endif			
		aSaldos := SaldTotCTI(cClVlIni,cClVlFim,cItemIni,cItemFim,cCustoIni,cCustoFim,cContaIni,cContaFim,dData,cMoeda,cTpSald)

	// Saldo da Classe de Valor+Item+Centro de Custo+Conta
	ElseIf !Empty(cConta) .And. !Empty(cCusto) .And. !Empty(cItem)
		cConta	:= PadR(cConta,Len(CTI->CTI_CONTA))					
		cCusto	:= PadR(cCusto,Len(CTI->CTI_CUSTO))									
		cItem	:= PadR(cItem,Len(CTI->CTI_ITEM))					
		cClVl	:= PadR(cClVl,Len(CTI->CTI_CLVL))									
		aSaldos := SaldoCtI(cConta,cCusto,cItem,cCLVL,dData,cMoeda,cTpSald)
	EndIf	
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

RestArea(aSaveArea)

Return aSaldos[nQualSaldo]

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MovConta   ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 04.07.01³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Devolve Movimentos do SIGACTB                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aMovimento[nQualSaldo]									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Planilha                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cConta     = Codigo da Conta                               ³±±
±±³          ³ dDataIni   = Data Inicial                                  ³±±
±±³          ³ dDataFim   = Data Final                                    ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MovConta(cConta,dDataIni,dDataFim,cMoeda,cTpSald,nQualSaldo)

Local aMovimento:= {}
Local nDebito
Local nCredito

cConta		:= Left(AllTrim(cConta) + Space(Len(CT7->CT7_CONTA)), Len(CT7->CT7_CONTA))
cTpSald		:= Iif(cTpSald==Nil,"1",cTpSald)
nQualSaldo	:= Iif(nQualSaldo==Nil,1,nQualSaldo)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                           ³
//³ [1] Movimento Devedor 	                            ³
//³ [2] Movimento Credor		                         ³
//³ [3] Movimento do Mes		                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aSaldoIni 	:= SaldoCt7(cConta,dDataIni,cMoeda,cTpSald,"CTBXFUN")
aSaldoFim	:= SaldoCT7(cConta,dDataFim,cMoeda,cTpSald,"CTBXFUN")

nDebito		:= aSaldoFim[4] - aSaldoIni[7]
nCredito	:= aSaldoFim[5] - aSaldoIni[8]

aMovimento := {nDebito,nCredito,nCredito-nDebito}

Return aMovimento[nQualSaldo]

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MovCusto   ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 04.07.01³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Devolve Movimentos do SIGACTB - CT3 - Planilha              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aMovimento[nQualSaldo]									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Planilha                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cConta     = Codigo da Conta                               ³±±
±±³          ³ cCusto     = Codigo do Centro de Custo                     ³±±
±±³          ³ dDataIni   = Data Inicial                                  ³±±
±±³          ³ dDataFim   = Data Final                                    ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MovCusto(cConta,cCusto,dDataIni,dDataFim,cMoeda,cTpSald,nQualSaldo)

Local aSaldoIni	:= {}
Local aSaldoFim	:= {}
Local aMovimento:= {}
Local nDebito
Local nCredito
Local lTodoCT1	:= .F.
Local lTodoCTT	:= .F.

DEFAULT cConta := ""
DEFAULT cCusto := ""

cTpSald		:= Iif(cTpSald==Nil,"1",cTpSald)
nQualSaldo	:= Iif(nQualSaldo==Nil,1,nQualSaldo)

// Devolve valor somente do Centro de Custo (Soma todas as contas)
If !Empty(cCusto)
	lTodoCT1	:= !Empty(cConta) .and. UPPER(cConta) == Replicate("Z",Len(cConta)) 
	lTodoCTT	:= !Empty(cCusto) .and. UPPER(cCusto) == Replicate("Z",Len(cCusto))
	If Empty(cConta)
		cCusto	  := PadR(cCusto,Len(CTU->CTU_CODIGO))					
		aSaldoIni := SaldoCTU("CTT",cCusto,dDataIni,cMoeda,cTpSald)
		aSaldoFim := SaldoCTU("CTT",cCusto,dDataFim,cMoeda,cTpSald)		
	ElseIf lTodoCT1 .or. lTodoCTT
		/// Saldo de uma ou todas entidades de acordo com os parâmetros ZZZZ
		If lTodoCT1
			cContaIni := ""
			cContaFim := Replicate("Z",Len(CTI->CTI_CONTA))
		Else
			cContaIni	:= PadR(cConta,Len(CTI->CTI_CONTA))					
			cContaFim	:= cContaIni
		Endif
		If lTodoCTT
			cCustoIni	:= ""
			cCustoFim	:= Replicate("Z",Len(CTI->CTI_CUSTO))
		Else
			cCustoIni	:= PadR(cCusto,Len(CTI->CTI_CUSTO))									
			cCustoFim	:= cCustoIni
		Endif
		aSaldoIni := SaldTotCT3(cCustoIni,cCustoFim,cContaIni,cContaFim,dDataIni,cMoeda,cTpSald)
		aSaldoFim := SaldTotCT3(cCustoIni,cCustoFim,cContaIni,cContaFim,dDataFim,cMoeda,cTpSald)
	Else                                                                    
		cConta	  := PadR(cConta,Len(CT3->CT3_CONTA))							
		cCusto	  := PadR(cCusto,Len(CT3->CT3_CUSTO))						
	// Devolve valor do Centro de Custo + Conta
		aSaldoIni 	:= SaldoCt3(cConta,cCusto,dDataIni,cMoeda,cTpSald)
		aSaldoFim	:= SaldoCT3(cConta,cCusto,dDataFim,cMoeda,cTpSald)
	EndiF	
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                          ³
//³ [1] Movimento Devedor 	                           ³
//³ [2] Movimento Credor		                        ³
//³ [3] Movimento do Mes		                        ³
//³ [4] Saldo Final                                	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nDebito		:= aSaldoFim[4] - aSaldoIni[7]
nCredito	:= aSaldoFim[5] - aSaldoIni[8]

aMovimento 	:= {nDebito,nCredito,nCredito-nDebito,aSaldoFim[1]}

Return aMovimento[nQualSaldo]

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MovItem    ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 04.07.01³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Devolve Movimentos do SIGACTB - CT4 - Planilha              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aMovimento[nQualSaldo]									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Planilha                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cConta     = Codigo da Conta                               ³±±
±±³          ³ cCusto     = Codigo do Centro de Custo                     ³±±
±±³          ³ cItem      = Codigo do Item                                ³±±
±±³          ³ dDataIni   = Data Inicial                                  ³±±
±±³          ³ dDataFim   = Data Final                                    ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MovItem(cConta,cCusto,cItem,dDataIni,dDataFim,cMoeda,cTpSald,nQualSaldo)

Local aMovimento:= {0,0,0,0,0,0}
Local aSaldoIni	:= {0,0,0,0,0,0}
Local aSaldoFim	:= {0,0,0,0,0,0}
Local nDebito
Local nCredito
Local lTodoCT1	:= .F.
Local lTodoCTT	:= .F.
Local lTodoCTD	:= .F.
DEFAULT cConta := ""
DEFAULT cCusto := ""
DEFAULT cItem  := ""

cTpSald		:= Iif(cTpSald==Nil,"1",cTpSald)
nQualSaldo	:= Iif(nQualSaldo==Nil,1,nQualSaldo)

If !Empty(cItem)
	lTodoCT1	:= !Empty(cConta) .and. UPPER(cConta) == Replicate("Z",Len(cConta)) 
	lTodoCTT	:= !Empty(cCusto) .and. UPPER(cCusto) == Replicate("Z",Len(cCusto))
	lTodoCTD	:= !Empty(cItem) .and. UPPER(cItem) == Replicate("Z",Len(cItem))
	// Saldo do Item (Soma todas as contas e centros de custo)
	If Empty(cConta) .And. Empty(cCusto)
		cItem		:= PadR(cItem,Len(CTU->CTU_CODIGO))	
		aSaldoIni := SaldoCTU("CTD",cItem,dDataIni,cMoeda,cTpSald)
		aSaldoFim := SaldoCTU("CTD",cItem,dDataFim,cMoeda,cTpSald)		
	// Saldo do Item+Centro de Custo (soma todas as contas)
	ElseIf Empty(cConta) .And. !Empty(cCusto)
		cItem		:= PadR(cItem,Len(CTV->CTV_ITEM))		
		cCusto		:= PadR(cCusto,Len(CTV->CTV_CUSTO))		
		#IFDEF TOP
			aSaldoIni := SldTop2Ent("CTV","CTD",cItem,cCusto,dDataIni,dDataIni,Val(cMoeda),cTpsald)
			aSaldoFim := SldTop2Ent("CTV","CTD",cItem,cCusto,dDataFim,dDataFim,Val(cMoeda),cTpsald)
		#ELSE
			aSaldoIni := SldCmpEnt(cItem,cCusto,dDataIni,cMoeda,cTpSald,1,"CTD","CTV","","",.F.,)			
			aSaldoFim := SldCmpEnt(cItem,cCusto,dDataFim,cMoeda,cTpSald,1,"CTD","CTV","","",.F.,)			
		#ENDIF
	ElseIf lTodoCT1 .or. lTodoCTT .or. lTodoCTD
		/// Saldo de uma ou todas entidades de acordo com os parâmetros ZZZZ
		If lTodoCT1
			cContaIni := ""
			cContaFim := Replicate("Z",Len(CTI->CTI_CONTA))
		Else
			cContaIni	:= PadR(cConta,Len(CTI->CTI_CONTA))					
			cContaFim	:= cContaIni
		Endif
		If lTodoCTT
			cCustoIni	:= ""
			cCustoFim	:= Replicate("Z",Len(CTI->CTI_CUSTO))
		Else
			cCustoIni	:= PadR(cCusto,Len(CTI->CTI_CUSTO))									
			cCustoFim	:= cCustoIni
		Endif
		If lTodoCTD
			cItemIni	:= ""
 			cItemFim	:= Replicate("Z",Len(CTI->CTI_ITEM))
		Else
			cItemIni	:= PadR(cItem,Len(CTI->CTI_ITEM))					
			cItemFim	:= cItemIni
		Endif
		aSaldoIni := SaldTotCT4(cItemIni,cItemFim,cCustoIni,cCustoFim,cContaIni,cContaFim,dDataIni,cMoeda,cTpSald)
		aSaldoFim := SaldTotCT4(cItemIni,cItemFim,cCustoIni,cCustoFim,cContaIni,cContaFim,dDataFim,cMoeda,cTpSald)
	ElseIf !Empty(cConta)
		cItem		:= PadR(cItem,Len(CT4->CT4_ITEM))			
		cCusto		:= PadR(cCusto,Len(CT4->CT4_CUSTO))				
		cConta		:= PadR(cConta,Len(CT4->CT4_CONTA))				
		aSaldoIni 	:= SaldoCt4(cConta,cCusto,cItem,dDataIni,cMoeda,cTpSald)
		aSaldoFim	:= SaldoCT4(cConta,cCusto,cItem,dDataFim,cMoeda,cTpSald)
	EndIf	
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                          ³
//³ [1] Movimento Devedor 	                           ³
//³ [2] Movimento Credor		                        ³
//³ [3] Movimento do Mes		                        ³
//³ [4] Saldo Final                                	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nDebito		:= aSaldoFim[4] - aSaldoIni[7]
nCredito	:= aSaldoFim[5] - aSaldoIni[8]

aMovimento := {nDebito,nCredito,nCredito-nDebito,aSaldoFim[1]}

Return aMovimento[nQualSaldo]

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MovClass   ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 04.07.01³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Devolve Movimentos do SIGACTB - CTI - Planilha              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MovClass(Cta,cc,Item,Clvlr,DtIni,DtFim,Moeda,TpSaldo,MovD/C)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aMovimento[nQualSaldo]									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cConta     = Codigo da Conta                               ³±±
±±³          ³ cCusto     = Codigo do Centro de Custo                     ³±±
±±³          ³ cItem      = Codigo do Item                                ³±±
±±³          ³ cCLVL      = Codigo da Classe de Valor                     ³±±
±±³          ³ dDataIni   = Data Inicial                                  ³±±
±±³          ³ dDataFim   = Data Final                                    ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MovClass(cConta,cCusto,cItem,cCLVL,dDataIni,dDataFim,cMoeda,cTpSald,nQualSaldo)

Local aMovimento:= {}
Local nDebito
Local nCredito
Local nTamCta	:= Len(CriaVar("CT1_CONTA"))
Local nTamCC	:= Len(CriaVar("CTT_CUSTO"))
Local nTamItem	:= Len(CriaVar("CTD_ITEM"))
Local aSaldoIni := {0,0,0,0,0,0}
Local aSaldoFim := {0,0,0,0,0,0}
Local lTodoCT1	:= .F.
Local lTodoCTT	:= .F.
Local lTodoCTD	:= .F.
Local lTodoCTH	:= .F.

DEFAULT cConta := ""
DEFAULT cCusto := ""
DEFAULT cItem  := ""
DEFAULT cCLVL  := ""

cTpSald		:= Iif(cTpSald==Nil,"1",cTpSald)
nQualSaldo	:= Iif(nQualSaldo==Nil,1,nQualSaldo)

If !Empty(cClVl)
	lTodoCT1	:= !Empty(cConta) .and. UPPER(cConta) == Replicate("Z",Len(cConta)) 
	lTodoCTT	:= !Empty(cCusto) .and. UPPER(cCusto) == Replicate("Z",Len(cCusto))
	lTodoCTD	:= !Empty(cItem) .and. UPPER(cItem) == Replicate("Z",Len(cItem))
	lTodoCTH	:= !Empty(cClVl) .and. UPPER(cCLVL) == Replicate("Z",Len(cCLVL))
	// Saldo da Classe de Valor (Soma todas as contas, centros de custo e item)
	If Empty(cConta) .And. Empty(cCusto) .And. Empty(cItem)
		cClVl		:= PadR(cClVl,Len(CTU->CTU_CODIGO))			
		aSaldoIni := SaldoCTU("CTH",cCLVL,dDataIni,cMoeda,cTpSald)
		aSaldoFim := SaldoCTU("CTH",cCLVL,dDataFim,cMoeda,cTpSald)
	// Saldo da Classe de Valor + Item (soma todas as Contas e Centros de Custo)
	ElseIf Empty(cConta) .And. Empty(cCusto) .And. !Empty(cItem)
		cClVl		:= PadR(cClVl,Len(CTX->CTX_CLVL))				
		cItem		:= PadR(cItem,Len(CTX->CTX_ITEM))						
		#IFDEF TOP
			aSaldoIni := SldTop2Ent("CTX","CTH",cCLVL,cItem,dDataIni,dDataIni,Val(cMoeda),cTpsald)
			aSaldoFim := SldTop2Ent("CTX","CTH",cCLVL,cItem,dDataFim,dDataFim,Val(cMoeda),cTpsald)	
		#ELSE
			aSaldoIni := SldCmpEnt(cCLVL,cItem,dDataIni,cMoeda,cTpSald,1,"CTH","CTX","","",.F.,)			
			aSaldoFim := SldCmpEnt(cCLVL,cItem,dDataFim,cMoeda,cTpSald,1,"CTH","CTX","","",.F.,)			
		#ENDIF                           
	// Saldo da Classe de Valor + Centro de Custo (soma todas as contas e itens)
	ElseIf Empty(cConta) .And. !Empty(cCusto) .And. Empty(cItem)
		cClVl		:= PadR(cClVl,Len(CTX->CTX_CLVL))				
		cItem		:= PadR(cItem,Len(CTX->CTX_ITEM))							
		#IFDEF TOP
			aSaldoIni := SldTop2Ent("CTX","CTH",cCLVL,cItem,dDataIni,dDataIni,Val(cMoeda),cTpsald)
			aSaldoFim := SldTop2Ent("CTX","CTH",cCLVL,cItem,dDataFim,dDataFim,Val(cMoeda),cTpsald)			
		#ELSE
			aSaldoIni := SldCmpEnt(cCLVL,cItem,dDataIni,cMoeda,cTpSald,1,"CTH","CTX","","",.F.,)			
			aSaldoFim := SldCmpEnt(cCLVL,cItem,dDataFim,cMoeda,cTpSald,1,"CTH","CTX","","",.F.,)			
		#ENDIF
	ElseIf lTodoCT1 .or. lTodoCTT .or. lTodoCTD .or. lTodoCTH
		/// Saldo de uma ou todas entidades de acordo com os parâmetros ZZZZ
		If lTodoCT1
			cContaIni := ""
			cContaFim := Replicate("Z",Len(CTI->CTI_CONTA))
		Else
			cContaIni	:= PadR(cConta,Len(CTI->CTI_CONTA))					
			cContaFim	:= cContaIni
		Endif
		If lTodoCTT
			cCustoIni	:= ""
			cCustoFim	:= Replicate("Z",Len(CTI->CTI_CUSTO))
		Else
			cCustoIni	:= PadR(cCusto,Len(CTI->CTI_CUSTO))									
			cCustoFim	:= cCustoIni
		Endif
		If lTodoCTD
			cItemIni	:= ""
 			cItemFim	:= Replicate("Z",Len(CTI->CTI_ITEM))
		Else
			cItemIni	:= PadR(cItem,Len(CTI->CTI_ITEM))					
			cItemFim	:= cItemIni
		Endif
		If lTodoCTH
			cClVlIni	:= ""
			cClVlFim	:= Replicate("Z",Len(CTI->CTI_CLVL))
		Else
			cClVlIni	:= PadR(cClVl,Len(CTI->CTI_CLVL))
			cClVlFim	:= cClVlIni
		Endif			
		aSaldoIni := SaldTotCTI(cClVlIni,cClVlFim,cItemIni,cItemFim,cCustoIni,cCustoFim,cContaIni,cContaFim,dDataIni,cMoeda,cTpSald)
		aSaldoFim := SaldTotCTI(cClVlIni,cClVlFim,cItemIni,cItemFim,cCustoIni,cCustoFim,cContaIni,cContaFim,dDataFim,cMoeda,cTpSald)

	// Saldo da Classe de Valor+Item+Centro de Custo+Conta
	ElseIf !Empty(cConta) .And. !Empty(cCusto) .And. !Empty(cItem)
		cClVl		:= PadR(cClVl,Len(CTI->CTI_CLVL))				
		cItem		:= PadR(cItem,Len(CTI->CTI_ITEM))						
		cCusto		:= PadR(cCusto,Len(CTI->CTI_CUSTO))						
		cConta		:= PadR(cConta,Len(CTI->CTI_CONTA))								 	
		aSaldoIni := SaldoCtI(cConta,cCusto,cItem,cCLVL,dDataIni,cMoeda,cTpSald)
		aSaldoFim := SaldoCtI(cConta,cCusto,cItem,cCLVL,dDataFim,cMoeda,cTpSald)		
	ElseIf !Empty(cConta) .And. Empty(cCusto) .And. !Empty(cItem)
		cClVl		:= PadR(cClVl,Len(CTI->CTI_CLVL))					
		cItem		:= PadR(cItem,Len(CTI->CTI_ITEM))						
		cConta		:= PadR(cConta,Len(CTI->CTI_CONTA))								 	
		aSaldoIni 	:= SaldTotCTI(cClVl,cClVl,cItem,cItem,"",Repl("Z",nTamCC),cConta,cConta,dDataIni,cMoeda,cTpSald)
		aSaldoFim 	:= SaldTotCTI(cClVl,cClVl,cItem,cItem,"",Repl("Z",nTamCC),cConta,cConta,dDataFim,cMoeda,cTpSald)
	ElseIf !Empty(cConta) .And. !Empty(cCusto) .And. Empty(cItem)
		cClVl		:= PadR(cClVl,Len(CTI->CTI_CLVL))					
		cCusto		:= PadR(cCusto,Len(CTI->CTI_CUSTO))						
		cConta		:= PadR(cConta,Len(CTI->CTI_CONTA))								 	
		aSaldoIni 	:= SaldTotCTI(cClVl,cClVl,"",Repl("Z",nTamItem),cCusto,cCusto,cConta,cConta,dDataIni,cMoeda,cTpSald)
		aSaldoFim 	:= SaldTotCTI(cClVl,cClVl,"",Repl("Z",nTamItem),cCusto,cCusto,cConta,cConta,dDataFim,cMoeda,cTpSald)	
	ElseIf !Empty(cConta) .And. Empty(cCusto) .And. Empty(cItem)
		cClVl		:= PadR(cClVl,Len(CTI->CTI_CLVL))					
		cConta		:= PadR(cConta,Len(CTI->CTI_CONTA))								 	
		aSaldoIni 	:= SaldTotCTI(cClVl,cClVl,"",Repl("Z",nTamItem),"",Repl("Z",nTamCC),cConta,cConta,dDataIni,cMoeda,cTpSald)
		aSaldoFim 	:= SaldTotCTI(cClVl,cClVl,"",Repl("Z",nTamItem),"",Repl("Z",nTamCC),cConta,cConta,dDataFim,cMoeda,cTpSald)			
	ElseIf Empty(cConta) .And. !Empty(cCusto) .And. !Empty(cItem)
		cClVl		:= PadR(cClVl,Len(CTI->CTI_CLVL))					
		cCusto		:= PadR(cCusto,Len(CTI->CTI_CUSTO))								
		cItem		:= PadR(cItem,Len(CTI->CTI_ITEM))						
		aSaldoIni 	:= SaldTotCTI(cClVl,cClVl,cItem,cItem,cCusto,cCusto,"",Repl("Z",nTamCta),dDataIni,cMoeda,cTpSald)
		aSaldoFim 	:= SaldTotCTI(cClVl,cClVl,cItem,cItem,cCusto,cCusto,"",Repl("Z",nTamCta),dDataFim,cMoeda,cTpSald)			
	EndIf	
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                          ³
//³ [1] Movimento Devedor 	                           ³
//³ [2] Movimento Credor		                        ³
//³ [3] Movimento do Mes		                        ³
//³ [4] Saldo Final                                	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nDebito		:= aSaldoFim[4] - aSaldoIni[7]
nCredito	:= aSaldoFim[5] - aSaldoIni[8]

aMovimento := {nDebito,nCredito,nCredito-nDebito,aSaldoFim[1]}

Return aMovimento[nQualSaldo]

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ CtSmConta  ³ Autor ³ Wagner Mobile Costa ³ Data ³ 07.02.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Soma os saldos de um grupo aleatorio de contas			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cContas    = Codigo das Contas, separado por virgula e :   ³±±
±±³          ³ dData      = Data                                          ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Para uso na planilha. Obs:sem macro e so' com vars locais !³±±
±±³ Atencao  ³ Esta funcao faz chamadas a funcao CtbSmSaldo()			  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtSmConta( cContas, dData, cMoeda, cTpSald, nQualSaldo )

// Retorna o Saldo de um grupo de contas informadas em cContas separadas por ":" para 
// indicar um intervalo entre contas e separadas por "," para indicar novo intervalo
// para soma.

Local nLop	  := 0	 	// Variavel para uso no laco que varre cContas e arrays
Local aDeAte  := {}	// Armazenara' os grupos de contas "De/Ate'"
Local aContas := {}	// Armazenara' as contas indiviuais
Local cTempor := ""  	// Variavel auxiliar, transitoria e temporaria
Local nVolta  := 0	 	// Variavel auxiliar de retorno da funcao

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica passagem correta de parametros ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ValType( cContas ) # "C"
	// Avaliar se devemos criar um help para esta consistencia
	Return( 0 )
Endif

If ValType(cMoeda) # "C"
	cMoeda := StrZero(cMoeda, 2)
Endif

cTpSald 	:= Iif(cTpSald==Nil,"1",cTpSald)
If ValType(cTpSald) # "C"
	cTpSald := Str(cTpSald, 1)
Endif
nQualSaldo	:= Iif(nQualSaldo==Nil .Or. ValType(nQualSaldo) = "C",1,nQualSaldo)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Analisa a String que contem as contas   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cContas := AllTrim( cContas )
cTempor := ""
For nLop := 1 to Len( cContas )
	 cChar := Subst( cContas, nLop , 1)

	 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	 //³ Verifica a presenca de caracteres invalidos ³
	 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 If !cChar $ "0123456789,:"
		 // Avaliar se devemos criar um help para esta consistencia
		 Loop
	 Endif

	 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	 //³ Se encontrar o separador simples, faz a carga dos arrays	³
	 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 If CChar == ","
		 If ":" $ cTempor
			 Aadd( aDeAte , cTempor)
		 Else
			 If !Empty( cTempor )
				 Aadd( aContas , cTempor )
			 Endif
		 Endif
		 cTempor := ""
	 Else
		 cTempor += cChar
	 Endif

Next nLop

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica o fim, pois nao precisa haver "," no final !      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( cTempor )
	If ":" $ cTempor
		 Aadd( aDeAte , cTempor)
	Else
		 Aadd( aContas , cTempor )
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se houve identificacao de contas ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len( aDeAte ) == 0 .and. Len( aContas ) == 0
	Return( 0 )
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Laco das contas "De / Ate"       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nLop := 1 to Len( aDeAte )

	// Conta inicial
	cTempor := Subst( aDeAte[nLop], 1, At(":",aDeAte[nLop]) -1 )
	// Conta Final
	cChar   := Subst( aDeAte[nLop], At(":",aDeAte[nLop]) + 1 , Len(aDeAte[nLop] ) )

	nVolta += CtbSmSaldo(cTempor,cChar,dData,cMoeda,cTpSald,nQualSaldo,"CT1")

Next nLop

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Laco das contas isoladas   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nLop := 1 to Len( aContas )
	 nVolta += CtbSmSaldo(aContas[nLop],aContas[nLop],dData,cMoeda,cTpSald,nQualSaldo,"CT1")
Next Lop

Return nVolta

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ CtSmCusto  ³ Autor ³ Wagner Mobile Costa ³ Data ³ 07.02.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Soma os saldos de um grupo aleatorio de C.Custos 		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCustos    = Codigo dos C.Custo, separado por virgula e :  ³±±
±±³          ³ dData      = Data                                          ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Para uso na planilha. Obs:sem macro e so' com vars locais !³±±
±±³ Atencao  ³ Esta funcao faz chamadas a funcao CtbSmSaldo 			  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtSmCusto ( cCustos, dData, cMoeda, cTpSald, nQualSaldo )

// Retorna o Saldo de um grupo de C.Custo informados em cCustos separados por ":" para 
// indicar um intervalo entre C.Custo e separados por "," para indicar novo intervalo
// para soma.

Local nLop	  := 0	 	// Variavel para uso no laco que varre cCustos e arrays
Local aDeAte  := {}	// Armazenara' os grupos de C.Custo "De/Ate'"
Local aCustos := {}	// Armazenara' os C.Custo indiviuais
Local cTempor := ""  	// Variavel auxiliar, transitoria e temporaria
Local nVolta  := 0	 	// Variavel auxiliar de retorno da funcao

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica passagem correta de parametros ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ValType( cCustos ) # "C"
	// Avaliar se devemos criar um help para esta consistencia
	Return( 0 )
Endif

If ValType(cMoeda) # "C"
	cMoeda := StrZero(cMoeda, 2)
Endif

cTpSald 	:= Iif(cTpSald==Nil,"1",cTpSald)
If ValType(cTpSald) # "C"
	cTpSald := Str(cTpSald, 1)
Endif
nQualSaldo	:= Iif(nQualSaldo==Nil .Or. ValType(nQualSaldo) = "C",1,nQualSaldo)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Analisa a String que contem os C.Custo  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cCustos := AllTrim( cCustos )
cTempor := ""
For nLop := 1 to Len( cCustos )
	 cChar := Subst( cCustos, nLop , 1)

	 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	 //³ Verifica a presenca de caracteres invalidos ³
	 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 If !cChar $ "0123456789,:"
		 // Avaliar se devemos criar um help para esta consistencia
		 Loop
	 Endif

	 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	 //³ Se encontrar o separador simples, faz a carga dos arrays	³
	 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 If CChar == ","
		 If ":" $ cTempor
			 Aadd( aDeAte , cTempor)
		 Else
			 If !Empty( cTempor )
				 Aadd( aCustos , cTempor )
			 Endif
		 Endif
		 cTempor := ""
	 Else
		 cTempor += cChar
	 Endif

Next nLop

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica o fim, pois nao precisa haver "," no final !      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( cTempor )
	If ":" $ cTempor
		 Aadd( aDeAte , cTempor)
	Else
		 Aadd( aCustos , cTempor )
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se houve identificacao de custos ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len( aDeAte ) == 0 .and. Len( aCustos ) == 0
	Return( 0 )
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Laco dos C.Custo "De / Ate"      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nLop := 1 to Len( aDeAte )

	// C.Custo inicial
	cTempor := Subst( aDeAte[nLop], 1, At(":",aDeAte[nLop]) -1 )
	// C.Custo Final
	cChar   := Subst( aDeAte[nLop], At(":",aDeAte[nLop]) + 1 , Len(aDeAte[nLop] ) )

	nVolta += CtbSmSaldo(cTempor,cChar,dData,cMoeda,cTpSald,nQualSaldo,"CTT")

Next nLop

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Laco dos C.Custo isolados  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nLop := 1 to Len( aCustos )
	 nVolta += CtbSmSaldo(aCustos[nLop],aCustos[nLop],dData,cMoeda,cTpSald,nQualSaldo,"CTT")
Next Lop

Return nVolta

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ CtSmItem   ³ Autor ³ Wagner Mobile Costa ³ Data ³ 07.02.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Soma os saldos de um grupo aleatorio de Itens			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cItens     = Codigo dos Itens , separado por virgula e :   ³±±
±±³          ³ dData      = Data                                          ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Para uso na planilha. Obs:sem macro e so' com vars locais !³±±
±±³ Atencao  ³ Esta funcao faz chamadas a funcao CtbSmSaldo 			  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtSmItem ( cItens, dData, cMoeda, cTpSald, nQualSaldo )

// Retorna o Saldo de um grupo de Itens Contabeis informados em cItens separados 
// por ":" para indicar um intervalo entre Itens e separados por "," para indicar 
// novo intervalo para soma.

Local nLop	  := 0	 	// Variavel para uso no laco que varre cItens e arrays
Local aDeAte  := {}	// Armazenara' os grupos de Item "De/Ate'"
Local aItens  := {}	// Armazenara' os Itens indiviuais
Local cTempor := ""  	// Variavel auxiliar, transitoria e temporaria
Local nVolta  := 0	 	// Variavel auxiliar de retorno da funcao

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica passagem correta de parametros ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ValType( cItens ) # "C"
	// Avaliar se devemos criar um help para esta consistencia
	Return( 0 )
Endif

If ValType(cMoeda) # "C"
	cMoeda := StrZero(cMoeda, 2)
Endif

cTpSald 	:= Iif(cTpSald==Nil,"1",cTpSald)
If ValType(cTpSald) # "C"
	cTpSald := Str(cTpSald, 1)
Endif
nQualSaldo	:= Iif(nQualSaldo==Nil .Or. ValType(nQualSaldo) = "C",1,nQualSaldo)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Analisa a String que contem os Itens    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cItens := AllTrim( cItens )
cTempor := ""
For nLop := 1 to Len( cItens )
	 cChar := Subst( cItens, nLop , 1)

	 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	 //³ Verifica a presenca de caracteres invalidos ³
	 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 If !cChar $ "0123456789,:"
		 // Avaliar se devemos criar um help para esta consistencia
		 Loop
	 Endif

	 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	 //³ Se encontrar o separador simples, faz a carga dos arrays	³
	 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 If CChar == ","
		 If ":" $ cTempor
			 Aadd( aDeAte , cTempor)
		 Else
			 If !Empty( cTempor )
				 Aadd( aItens , cTempor )
			 Endif
		 Endif
		 cTempor := ""
	 Else
		 cTempor += cChar
	 Endif

Next nLop

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica o fim, pois nao precisa haver "," no final !      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( cTempor )
	If ":" $ cTempor
		 Aadd( aDeAte , cTempor)
	Else
		 Aadd( aItens , cTempor )
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se houve identificacao de Itens  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len( aDeAte ) == 0 .and. Len( aItens ) == 0
	Return( 0 )
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Laco dos Itens   "De / Ate"      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nLop := 1 to Len( aDeAte )

	// Item inicial
	cTempor := Subst( aDeAte[nLop], 1, At(":",aDeAte[nLop]) -1 )
	// Item Final
	cChar   := Subst( aDeAte[nLop], At(":",aDeAte[nLop]) + 1 , Len(aDeAte[nLop] ) )

	nVolta += CtbSmSaldo(cTempor,cChar,dData,cMoeda,cTpSald,nQualSaldo,"CTD")

Next nLop

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Laco dos itens  isolados   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nLop := 1 to Len( aItens )
	 nVolta += CtbSmSaldo(aItens[nLop],aItens[nLop],dData,cMoeda,cTpSald,nQualSaldo,"CTD")
Next Lop

Return nVolta

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ CtSmClVl   ³ Autor ³ Wagner Mobile Costa ³ Data ³ 07.02.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Soma os saldos de um grupo aleatorio de Cl. Valor		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cClVls     = Codigo das Cl.Vlr, separado por virgula e :   ³±±
±±³          ³ dData      = Data                                          ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Para uso na planilha. Obs:sem macro e so' com vars locais !³±±
±±³ Atencao  ³ Esta funcao faz chamadas a funcao CtbSmSaldo 			  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtSmClVl ( cClVls, dData, cMoeda, cTpSald, nQualSaldo )

// Retorna o Saldo de um grupo de Classe de Valor informados em cClVl separados 
// por ":" para indicar um intervalo entre Cl.Vlrs e separados por "," para indicar 
// novo intervalo para soma.

Local nLop	  := 0	 	// Variavel para uso no laco que varre Cl. Vlrs e arrays
Local aDeAte  := {}	// Armazenara' os grupos de Classe Vlr "De/Ate'"
Local aItens  := {}// Armazenara' as Cl. Vlrs indiviuais
Local cTempor := ""  	// Variavel auxiliar, transitoria e temporaria
Local nVolta  := 0	 	// Variavel auxiliar de retorno da funcao


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica passagem correta de parametros ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ValType( cClVls ) # "C"
	// Avaliar se devemos criar um help para esta consistencia
	Return( 0 )
Endif

If ValType(cMoeda) # "C"
	cMoeda := StrZero(cMoeda, 2)
Endif

cTpSald 	:= Iif(cTpSald==Nil,"1",cTpSald)
If ValType(cTpSald) # "C"
	cTpSald := Str(cTpSald, 1)
Endif
nQualSaldo	:= Iif(nQualSaldo==Nil .Or. ValType(nQualSaldo) = "C",1,nQualSaldo)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Analisa a String que contem Cl Vlrs     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cClVls := AllTrim( cClVls )
cTempor := ""
For nLop := 1 to Len( cClVls )
	 cChar := Subst( cClVls, nLop , 1)

	 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	 //³ Verifica a presenca de caracteres invalidos ³
	 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 If !cChar $ "0123456789,:"
		 // Avaliar se devemos criar um help para esta consistencia
		 Loop
	 Endif

	 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	 //³ Se encontrar o separador simples, faz a carga dos arrays	³
	 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 If CChar == ","
		 If ":" $ cTempor
			 Aadd( aDeAte , cTempor)
		 Else
			 If !Empty( cTempor )
				 Aadd( aItens , cTempor )
			 Endif
		 Endif
		 cTempor := ""
	 Else
		 cTempor += cChar
	 Endif

Next nLop

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica o fim, pois nao precisa haver "," no final !      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( cTempor )
	If ":" $ cTempor
		 Aadd( aDeAte , cTempor)
	Else
		 Aadd( aItens , cTempor )
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se houve identificacao da ClVl   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len( aDeAte ) == 0 .and. Len( aItens ) == 0
	Return( 0 )
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Laco das ClVl's   "De / Ate"     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nLop := 1 to Len( aDeAte )

	// ClVl inicial
	cTempor := Subst( aDeAte[nLop], 1, At(":",aDeAte[nLop]) -1 )
	// ClVl Final
	cChar   := Subst( aDeAte[nLop], At(":",aDeAte[nLop]) + 1 , Len(aDeAte[nLop] ) )

	nVolta += CtbSmSaldo(cTempor,cChar,dData,cMoeda,cTpSald,nQualSaldo,"CTH")

Next nLop

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Laco das ClVl's  isoladas  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nLop := 1 to Len( aItens )
	 nVolta += CtbSmSaldo(aItens[nLop],aItens[nLop],dData,cMoeda,cTpSald,nQualSaldo,"CTH")
Next Lop

Return nVolta


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CtbSmSaldo ³ Autor ³ Wagner Mobile Costa ³ Data ³ 07.02.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Devolve saldos de um periodo de contas CT7 - Planilha       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtSomaSaldo(cCodigoDe,cCodigoAte,Data,Moeda,Tipo de Saldo,Tipo³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aSaldos(nQualSaldo)                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCodigode  = Entidade Inicial                              ³±±
±±³          ³ cCodigoAte = Entidade Final                                ³±±
±±³          ³ dData      = Data                                          ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado                              ³±±
±±³          ³ cAlias     = Arquivo a ser tratado                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbSmSaldo(cCodigoDe,cCodigoAte,dData,cMoeda,cTpSald,nQualSaldo,cAlias)

Local aSaveArea	:= GetArea()
Local aSaldos	:= {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica passagem correta de parametros ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ValType( cCodigoDe ) # "C" .Or. ValType( cCodigoAte ) # "C" 
	// Avaliar se devemos criar um help para esta consistencia
	Return( 0 )
Endif
 
If ValType(cMoeda) # "C"
	cMoeda := StrZero(cMoeda, 2)
Endif

cTpSald 	:= Iif(cTpSald==Nil,"1",cTpSald)
If ValType(cTpSald) # "C"
	cTpSald := Str(cTpSald, 1)
Endif
If ValType(dData) = "C"
	dData := Ctod(dData)
Endif

nQualSaldo	:= Iif(nQualSaldo==Nil .Or. ValType(nQualSaldo) = "C",1,nQualSaldo)
cAlias 		:= Iif(cAlias==Nil,"CT1",cAlias)
  
If cAlias == "CT1"			// Plano de Contas
	dbSelectArea("CT7")
	dbSetOrder(2)
	MsSeek(xFilial() + cCodigoDe, .T.)
	cCodigoAte := PADR(cCodigoAte,LEN(CT7->CT7_CONTA))
	While !Eof() .And. CT7->CT7_FILIAL = xFilial("CT7") .And. CT7->CT7_CONTA <= cCodigoAte
		
		cCodAtu := CT7->CT7_CONTA
		
		While !CT7->(Eof()) .And. CT7->CT7_FILIAL = xFilial("CT7") .And. CT7->CT7_CONTA == cCodAtu .and. CT7->CT7_DATA < dData
			CT7->(dbSkip())
		Enddo
		
		If CT7->CT7_CONTA <> cCodAtu
			CT7->(dbSkip(-1))
		Endif
		
		If Len(aSaldos) = 0
			aSaldos := SaldoCt7(CT7->CT7_CONTA,dData,cMoeda,cTpSald,"CTBXFUN")
		Else
			aSaldos[nQualSaldo] += SaldoCt7(CT7->CT7_CONTA,dData,cMoeda,cTpSald,"CTBXFUN")[nQualSaldo]
		Endif

		While !CT7->(Eof()) .And. CT7->CT7_FILIAL = xFilial("CT7") .And. CT7->CT7_CONTA == cCodAtu
			CT7->(dbSkip())
		Enddo
	EndDo
ElseiF cAlias == "CTT"		// Centro de Custo
	dbSelectArea("CT3")
	dbSetOrder(4)
	MsSeek(xFilial() + cCodigoDe, .T.)
	cCodigoAte := PADR(cCodigoAte,LEN(CT3->CT3_CUSTO))
	While !Eof() .And.	CT3->CT3_FILIAL = xFilial("CT3") .And. CT3->CT3_CUSTO <= cCodigoAte
	
		cCodAtu := CT3->CT3_CUSTO
		
		While !CT3->(Eof()) .And. CT3->CT3_FILIAL = xFilial("CT3") .And. CT3->CT3_CUSTO == cCodAtu .and. CT3->CT3_DATA < dData
			CT3->(dbSkip())
		Enddo
		
		If CT3->CT3_CUSTO <> cCodAtu
			CT3->(dbSkip(-1))
		Endif	 		

		If Len(aSaldos) = 0
			aSaldos := SaldoCTU("CTT",CT3->CT3_CUSTO,dData,cMoeda,cTpSald)
		Else
			aSaldos[nQualSaldo] += SaldoCTU("CTT",CT3->CT3_CUSTO,dData,cMoeda,cTpSald)[nQualSaldo]
		Endif

		While !CT3->(Eof()) .And. CT3->CT3_FILIAL = xFilial("CT3") .And. CT3->CT3_CUSTO == cCodAtu
			CT3->(dbSkip())
		Enddo
	EndDo
ElseIf cAlias == "CTD"
	dbSelectArea("CT4")
	dbSetOrder(4)
	MsSeek(xFilial() + cCodigoDe, .T.)
	cCodigoAte := PADR(cCodigoAte,LEN(CT4->CT4_ITEM))
	While !Eof() .And.	CT4->CT4_FILIAL = xFilial("CT4") .And. CT4->CT4_ITEM <= cCodigoAte
		
		cCodAtu := CT4->CT4_ITEM
		
		While !CT4->(Eof()) .And. CT4->CT4_FILIAL = xFilial("CT4") .And. CT4->CT4_ITEM == cCodAtu .and. CT4->CT4_DATA < dData
			CT4->(dbSkip())
		Enddo
		
		If CT4->CT4_ITEM <> cCodAtu
			CT4->(dbSkip(-1))
		Endif	 		

		If Len(aSaldos) = 0
			aSaldos := SaldoCTU("CTD",CT4->CT4_ITEM,dData,cMoeda,cTpSald)
		Else
			aSaldos[nQualSaldo] += SaldoCTU("CTD",CT4->CT4_ITEM,dData,cMoeda,cTpSald)[nQualSaldo]
		Endif

		While !CT4->(Eof()) .And. CT4->CT4_FILIAL = xFilial("CT4") .And. CT4->CT4_ITEM == cCodAtu
			CT4->(dbSkip())
		Enddo
	EndDo
ElseIf cAlias == "CTH"
	dbSelectArea("CTI")
	dbSetOrder(4)
	MsSeek(xFilial() + cCodigoDe, .T.)
	cCodigoAte := PADR(cCodigoAte,LEN(CTI->CTI_CLVL))
	While !Eof() .And.	CTI->CTI_FILIAL = xFilial("CTI") .And. CTI->CTI_CLVL <= cCodigoAte
		
		cCodAtu := CTI->CTI_CLVL
		
		While !CTI->(Eof()) .And. CTI->CTI_FILIAL = xFilial("CTI") .And. CTI->CTI_CLVL == cCodAtu .and. CTI->CTI_DATA < dData
			CTI->(dbSkip())
		Enddo
		                                          
		If CTI->CTI_CLVL <> cCodAtu
			CTI->(dbSkip(-1))
		Endif
			 		
		If Len(aSaldos) = 0
			aSaldos := SaldoCTU("CTH",CTI->CTI_CLVL,dData,cMoeda,cTpSald)
		Else
			aSaldos[nQualSaldo] += SaldoCTU("CTH",CTI->CTI_CLVL,dData,cMoeda,cTpSald)[nQualSaldo]
		Endif

		While !CTI->(Eof()) .And. CTI->CTI_FILIAL = xFilial("CTI") .And. CTI->CTI_CLVL == cCodAtu
			CTI->(dbSkip())
		Enddo
	EndDo
EndIf

RestArea(aSaveArea)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Return If(Len(aSaldos) = 0, 0, aSaldos[nQualSaldo])

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CtSmEntMovºAutor  ³Marcos S. Lobo      º Data ³  14/05/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Soma o movimento de um intervalo contas/ccusto/item ou      º±±
±±º          ³Cl.Valor                                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP - Excel                                      			  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±³Parametros³ cCodigoDe  = Codigo da Entidade Inicial					  ³±±
±±³          ³ cCodigoAte = Codigo da Entidade Final	                  ³±±
±±³          ³ dDataIni   = Data inicial dos movimentos                   ³±±
±±³          ³ dDataFim   = Data Final dos movimentos                     ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado (1=Inicial/2=Final/3=Mov.)   ³±±
±±³          ³ cAlias     = Entidade Desejada (CT1/CTT/CTD/CTH)			  ³±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CtSmEntMov(cCodigoDe,cCodigoAte,dDataIni,dDataFim,cMoeda,cTpSald,nQualSaldo,cAlias)
             
Local aMovimento:= {0,0,0}
Local nSldIni	:= 0
Local nSldFim	:= 0

DEFAULT cCodigoDe	:= ""
DEFAULT cCodigoAte	:= ""
DEFAULT dDataIni	:= dDataBase
DEFAULT dDataFim	:= dDataBase
DEFAULT cMoeda 		:= "01"
DEFAULT cTpSald		:= "1"
DEFAULT nQualSaldo	:= 3
DEFAULT cAlias		:= "CT1"

If ValType(cCodigoDe) == "N"
	cCodigoDe := ALLTRIM(STR(INT(cCodigoDe)))
Endif

If ValType(cCodigoAte) == "N"
	cCodigoAte := ALLTRIM(STR(INT(cCodigoAte)))
Endif

If ValType(dDataIni) == "C"
	If At("/",dDataIni) > 0
		dDataIni := CTOD(dDataIni)
	Else
		dDataIni := STOD(dDataIni)
	Endif
EndIf

If ValType(dDataFim) == "C"
	If At("/",dDataFim) > 0
		dDataFim := CTOD(dDataFim)
	Else
		dDataFim := STOD(dDataFim)
	Endif
EndIf

If ValType(cMoeda) == "N"
	cMoeda := ALLTRIM(STRZERO(cMoeda,2))
Endif

If ValType(cTpSald) == "N"
	cTpSald := ALLTRIM(STR(INT(cTpSald)))
Endif

If ValType(nQualSaldo) == "C"
	nQualSaldo := Int(Val(nQualSaldo))
Endif

nSldIni := CtbSmSaldo(cCodigoDe,cCodigoAte,dDataIni,cMoeda,cTpSald,6,cAlias)
nSldFim	:= CtbSmSaldo(cCodigoDe,cCodigoAte,dDataFim,cMoeda,cTpSald,1,cAlias)

aMovimento := {nSldIni,nSldFim,nSldFim-nSldIni}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Inicial                                    ³
//³ [2] Saldo Final       		                         ³
//³ [3] Movimento do Periodo (com sinal)                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return(aMovimento[nQualSaldo])
                
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CtSmMov   ºAutor  ³Marcos S. Lobo      º Data ³  13/05/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Soma o Movimento/Saldo de um intervalo de entidades ou de umº±±
±±º          ³conjunto de entidades (Conta/Custo/Item e/ou Cl.Valor)      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP - Excel                                     			  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±³Parametros³ dDataIni   = Data inicial dos movimentos                   ³±±
±±³          ³ dDataFim   = Data Final dos movimentos                     ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cTpSald    = Tipo de Saldo                                 ³±±
±±³          ³ nQualSaldo = Retorno Desejado (1=Mov.Deb/2=Mov.Crd/3=Mov./4³±±
±±³          ³ cContaIni  = Codigo da Conta Inicial (opcional)            ³±±
±±³          ³ cContaFim  = Codigo da Conta Final (opcional)              ³±±
±±³          ³ cCustoIni  = Codigo do C.Custo Inicial (opcional)          ³±±
±±³          ³ cCustoFim  = Codigo do C.Custo Final (opcional)            ³±±
±±³          ³ cItemIni   = Codigo do Item Inicial (opcional)             ³±±
±±³          ³ cItemFim   = Codigo do Item Final (opcional)               ³±±
±±³          ³ cCLVLIni   = Codigo da C.Valor Inicial (opcional)          ³±±
±±³          ³ cCLVLFim   = Codigo da C.Valor Final (opcional)            ³±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CtSmMov(dDataIni,dDataFim,cMoeda,cTpSald,nQualSaldo,cContaIni,cContaFim,cCustoIni,cCustoFim,cItemIni,cItemFim,cCLVLIni,cCLVLFim)

Local aSaldoIni := {0,0,0,0,0,0,0,0}
Local aSaldoFim := {0,0,0,0,0,0,0,0}
Local aSldIni	:= {0,0,0,0,0,0,0,0}
Local aSldFim	:= {0,0,0,0,0,0,0,0}
Local aMovimento:= {0,0,0,0} 
Local nDebito	:= 0
Local nCredito	:= 0
Local lTemConta	:= .F.
Local lTemCusto	:= .F.
Local lTemItem	:= .F.
Local lTemCLVL	:= .F.
Local cKey2Skip	:= ""

DEFAULT dDataIni	:= dDataBase
DEFAULT dDataFim	:= dDataBase
DEFAULT cMoeda 		:= "01"
DEFAULT cTpSald		:= "1"
DEFAULT nQualSaldo	:= 3

If ValType(dDataIni) == "C"
	If At("/",dDataIni) > 0
		dDataIni := CTOD(dDataIni)
	Else
		dDataIni := STOD(dDataIni)
	Endif
EndIf

If ValType(dDataFim) == "C"
	If At("/",dDataFim) > 0
		dDataFim := CTOD(dDataFim)
	Else
		dDataFim := STOD(dDataFim)
	Endif
EndIf

If ValType(cMoeda) == "N"
	cMoeda := ALLTRIM(STRZERO(cMoeda,2))
Endif

If ValType(cTpSald) == "N"
	cTpSald := ALLTRIM(STR(INT(cTpSald)))
Endif

If ValType(nQualSaldo) == "C"
	nQualSaldo := Int(Val(nQualSaldo))
Endif

If !Empty(cCLVLINI) .or. !Empty(cCLVLFIM)
	lTemCLVL := .T.
	If Empty(cCLVLFim)
		cCLVLFim := cCLVLIni
	Endif
Else
	cCLVLIni	:= ""
	cCLVLFim	:= Replicate("Z",Len(CriaVar("CTH_CLVL")))
Endif
If !Empty(cItemIni) .or. !Empty(cItemFIM)
	lTemItem := .T.
	If Empty(cItemFIM)
		cItemFIM := cItemIni
	Endif
Else
	cItemIni	:= ""
	cItemFim	:= Replicate("Z",Len(CriaVar("CTD_ITEM")))
Endif
If !Empty(cCustoIni) .or. !Empty(cCustoFIM)
	lTemCusto := .T.
	If Empty(cCustoFIM)
		cCustoFIM := cCustoIni
	Endif
Else
	cCustoIni	:= ""
	cCustoFim	:= Replicate("Z",Len(CriaVar("CTT_CUSTO")))
Endif
If !Empty(cContaIni) .or. !Empty(cContaFIM)
	lTemConta := .T.
	If Empty(cContaFIM)
		cContaFIM := cContaIni
	Endif
Else
	cContaIni	:= ""
	cContaFim	:= Replicate("Z",Len(CriaVar("CT1_CONTA")))
Endif
    
If lTemConta
	If lTemCLVL
		aSaldoIni := SaldTotCTI(cClVlIni,cClVlFim,cItemIni,cItemFim,cCustoIni,cCustoFim,cContaIni,cContaFim,dDataIni,cMoeda,cTpSald)
		aSaldoFim := SaldTotCTI(cClVlIni,cClVlFim,cItemIni,cItemFim,cCustoIni,cCustoFim,cContaIni,cContaFim,dDataFim,cMoeda,cTpSald)		
	ElseIf lTemItem
		aSaldoIni := SaldTotCT4(cItemIni,cItemFim,cCustoIni,cCustoFim,cContaIni,cContaFim,dDataIni,cMoeda,cTpSald)
		aSaldoFim := SaldTotCT4(cItemIni,cItemFim,cCustoIni,cCustoFim,cContaIni,cContaFim,dDataFim,cMoeda,cTpSald)		
	ElseIf lTemCusto
		aSaldoIni := SaldTotCT3(cCustoIni,cCustoFim,cContaIni,cContaFim,dDataIni,cMoeda,cTpSald)
		aSaldoFim := SaldTotCT3(cCustoIni,cCustoFim,cContaIni,cContaFim,dDataFim,cMoeda,cTpSald)
	Else
		aSaldoIni := SaldTotCT7(cContaIni,cContaFim,dDataIni,cMoeda,cTpSald)
		aSaldoFim := SaldTotCT7(cContaIni,cContaFim,dDataFim,cMoeda,cTpSald)
	Endif
ElseIf lTemCLVL
	If lTemItem .and. lTemCusto
		// SALDO DA CLASSE DE VALORES + ITEM CONTABIL + C.CUSTO = CTY
		dbSelectArea("CTY")
		dbSetOrder(1)     
		MsSeek(xFilial("CTY")+cMoeda+cTpSald+cCLVLIni,.T.)
		While !CTY->(Eof()) .and. CTY->CTY_FILIAL == xFilial("CTY") .and. CTY->CTY_MOEDA == cMoeda .and.;
			CTY->CTY_TPSALD == cTpSald .and. CTY->CTY_CLVL <= cCLVLFim
			
			
			If CTY->CTY_ITEM < cItemIni .or. CTY->CTY_ITEM > cItemFim .or. ;
				CTY->CTY_CUSTO < cCustoIni .or. CTY->CTY_CUSTO > cCustoFim
				CTY->(dbSkip())
				Loop
			EndIf

			aSldIni := SaldoCTY(CTY->CTY_CLVL,CTY->CTY_ITEM,CTY->CTY_CUSTO,dDataIni,cMoeda,cTpsald)
			aSldFim := SaldoCTY(CTY->CTY_CLVL,CTY->CTY_ITEM,CTY->CTY_CUSTO,dDataFim,cMoeda,cTpsald)
			                    
			aSaldoIni[1] := aSaldoIni[1] + aSldIni[1]			/// ACUMULA O SALDO INICIAL
			aSaldoIni[2] := aSaldoIni[2] + aSldIni[2]
			aSaldoIni[3] := aSaldoIni[3] + aSldIni[3]
			aSaldoIni[4] := aSaldoIni[4] + aSldIni[4]
			aSaldoIni[5] := aSaldoIni[5] + aSldIni[5]
			aSaldoIni[6] := aSaldoIni[6] + aSldIni[6]
			aSaldoIni[7] := aSaldoIni[7] + aSldIni[7]
			aSaldoIni[8] := aSaldoIni[8] + aSldIni[8]
	
			aSaldoFim[1] := aSaldoFim[1] + aSldFim[1]			/// ACUMULA O SALDO FINAL
			aSaldoFim[2] := aSaldoFim[2] + aSldFim[2]
			aSaldoFim[3] := aSaldoFim[3] + aSldFim[3]
			aSaldoFim[4] := aSaldoFim[4] + aSldFim[4]
			aSaldoFim[5] := aSaldoFim[5] + aSldFim[5]
			aSaldoFim[6] := aSaldoFim[6] + aSldFim[6]
			aSaldoFim[7] := aSaldoFim[7] + aSldFim[7]
			aSaldoFim[8] := aSaldoFim[8] + aSldFim[8]
		    
			cKey2Skip := CTY->(CTY_FILIAL+CTY_MOEDA+CTY_TPSALD+CTY_CLVL+CTY_ITEM+CTY_CUSTO)
			While !Eof() .and. CTY->(CTY_FILIAL+CTY_MOEDA+CTY_TPSALD+CTY_CLVL+CTY_ITEM+CTY_CUSTO) == cKey2Skip
				CTY->(dbSkip())
			EndDo		
		EndDo		
	ElseIf lTemItem
		// SALDO DA CLASSE DE VALORES + ITEM CONTABIL = CTX	
		dbSelectArea("CTX")
		dbSetOrder(1)
		MsSeek(xFilial("CTX")+cMoeda+cTpSald+cItemIni,.T.)
		While !CTX->(Eof()) .and. CTX->CTX_FILIAL == xFilial("CTX") .and. CTX->CTX_MOEDA == cMoeda .and.;
			CTX->CTX_TPSALD == cTpSald .and. CTX->CTX_ITEM <= cItemFim
			
			If CTX->CTX_CLVL < cCLVLIni .or. CTX->CTX_CLVL > cCLVLFim
				CTX->(dbSkip())
				Loop
			EndIf
		
			#IFDEF TOP
				aSldIni := SldTop2Ent("CTX","CTH",CTX->CTX_CLVL,CTX->CTX_ITEM,dDataIni,dDataIni,Val(cMoeda),cTpsald)
				aSldFim := SldTop2Ent("CTX","CTH",CTX->CTX_CLVL,CTX->CTX_ITEM,dDataFim,dDataFim,Val(cMoeda),cTpsald)
			#ELSE
				aSldIni := SldCmpEnt(CTX->CTX_CLVL,CTX->CTX_ITEM,dDataIni,cMoeda,cTpSald,1,"CTH","CTX","","",.F.,)			
				aSldFim := SldCmpEnt(CTX->CTX_CLVL,CTX->CTX_ITEM,dDataFim,cMoeda,cTpSald,1,"CTH","CTX","","",.F.,)			
			#ENDIF
			
			aSaldoIni[1] := aSaldoIni[1] + aSldIni[1]			/// ACUMULA O SALDO INICIAL
			aSaldoIni[2] := aSaldoIni[2] + aSldIni[2]
			aSaldoIni[3] := aSaldoIni[3] + aSldIni[3]
			aSaldoIni[4] := aSaldoIni[4] + aSldIni[4]
			aSaldoIni[5] := aSaldoIni[5] + aSldIni[5]
			aSaldoIni[6] := aSaldoIni[6] + aSldIni[6]
			aSaldoIni[7] := aSaldoIni[7] + aSldIni[7]
			aSaldoIni[8] := aSaldoIni[8] + aSldIni[8]
	
			aSaldoFim[1] := aSaldoFim[1] + aSldFim[1]			/// ACUMULA O SALDO FINAL
			aSaldoFim[2] := aSaldoFim[2] + aSldFim[2]
			aSaldoFim[3] := aSaldoFim[3] + aSldFim[3]
			aSaldoFim[4] := aSaldoFim[4] + aSldFim[4]
			aSaldoFim[5] := aSaldoFim[5] + aSldFim[5]
			aSaldoFim[6] := aSaldoFim[6] + aSldFim[6]
			aSaldoFim[7] := aSaldoFim[7] + aSldFim[7]
			aSaldoFim[8] := aSaldoFim[8] + aSldFim[8]
		    
			cKey2Skip := CTX->(CTX_FILIAL+CTX_MOEDA+CTX_TPSALD+CTX_ITEM+CTX_CLVL)
			While !Eof() .and. CTX->(CTX_FILIAL+CTX_MOEDA+CTX_TPSALD+CTX_ITEM+CTX_CLVL) == cKey2Skip
				CTX->(dbSkip())
			EndDo		
		EndDo
	ElseIf lTemCusto
		// SALDO DA CLASSE DE VALORES + CENTRO DE CUSTO = CTW
		dbSelectArea("CTW")
		dbSetOrder(1)
		MsSeek(xFilial("CTW")+cMoeda+cTpSald+cCLVLIni,.T.)
		While !CTW->(Eof()) .and. CTW->CTW_FILIAL == xFilial("CTW") .and. CTW->CTW_MOEDA == cMoeda .and.;
			CTW->CTW_TPSALD == cTpSald .and. CTW->CTW_CLVL <= cCLVLFim
			
			If CTW->CTW_CUSTO < cCustoIni .or. CTW->CTW_CUSTO > cCustoFim
				CTW->(dbSkip())
				Loop
			EndIf

			#IFDEF TOP
				aSldIni := SldTop2Ent("CTW","CTH",CTW->CTW_CLVL,CTW->CTW_CUSTO,dDataIni,dDataIni,Val(cMoeda),cTpsald)
				aSldFim := SldTop2Ent("CTW","CTH",CTW->CTW_CLVL,CTW->CTW_CUSTO,dDataFim,dDataFim,Val(cMoeda),cTpsald)
			#ELSE
				aSldIni := SldCmpEnt(CTW->CTW_CLVL,CTW->CTW_CUSTO,dDataIni,cMoeda,cTpSald,1,"CTH","CTW","","",.F.,)			
				aSldFim := SldCmpEnt(CTW->CTW_CLVL,CTW->CTW_CUSTO,dDataFim,cMoeda,cTpSald,1,"CTH","CTW","","",.F.,)			
			#ENDIF
			
			aSaldoIni[1] := aSaldoIni[1] + aSldIni[1]			/// ACUMULA O SALDO INICIAL
			aSaldoIni[2] := aSaldoIni[2] + aSldIni[2]
			aSaldoIni[3] := aSaldoIni[3] + aSldIni[3]
			aSaldoIni[4] := aSaldoIni[4] + aSldIni[4]
			aSaldoIni[5] := aSaldoIni[5] + aSldIni[5]
			aSaldoIni[6] := aSaldoIni[6] + aSldIni[6]
			aSaldoIni[7] := aSaldoIni[7] + aSldIni[7]
			aSaldoIni[8] := aSaldoIni[8] + aSldIni[8]
	
			aSaldoFim[1] := aSaldoFim[1] + aSldFim[1]			/// ACUMULA O SALDO FINAL
			aSaldoFim[2] := aSaldoFim[2] + aSldFim[2]
			aSaldoFim[3] := aSaldoFim[3] + aSldFim[3]
			aSaldoFim[4] := aSaldoFim[4] + aSldFim[4]
			aSaldoFim[5] := aSaldoFim[5] + aSldFim[5]
			aSaldoFim[6] := aSaldoFim[6] + aSldFim[6]
			aSaldoFim[7] := aSaldoFim[7] + aSldFim[7]
			aSaldoFim[8] := aSaldoFim[8] + aSldFim[8]
		    
			cKey2Skip := CTW->(CTW_FILIAL+CTW_MOEDA+CTW_TPSALD+CTW_CLVL+CTW_CUSTO)
			While !Eof() .and. CTW->(CTW_FILIAL+CTW_MOEDA+CTW_TPSALD+CTW_CLVL+CTW_CUSTO) == cKey2Skip
				CTW->(dbSkip())
			EndDo		
		EndDo			
	Else
		// SALDO SOMENTE DA CLASSE DE VALORES = CTU
		dbSelectArea("CTH")
		dbSetOrder(1)
		MsSeek(xFilial("CTH")+cCLVLIni,.T.)
		While !CTH->(Eof()) .and. CTH->CTH_FILIAL == xFilial("CTH") .and. CTH->CTH_CLVL <= cCLVLFim
			
			If CTH->CTH_CLASSE <> "2"	/// SE NÃO FOR ANALITICA
				CTH->(dbSkip())
				Loop
			Endif
			
			aSldIni := SaldoCTU("CTH",CTH->CTH_CLVL,dDataIni,cMoeda,cTpSald)
			aSldFim := SaldoCTU("CTH",CTH->CTH_CLVL,dDataFim,cMoeda,cTpSald)
			
			aSaldoIni[1] := aSaldoIni[1] + aSldIni[1]			/// ACUMULA O SALDO INICIAL
			aSaldoIni[2] := aSaldoIni[2] + aSldIni[2]
			aSaldoIni[3] := aSaldoIni[3] + aSldIni[3]
			aSaldoIni[4] := aSaldoIni[4] + aSldIni[4]
			aSaldoIni[5] := aSaldoIni[5] + aSldIni[5]
			aSaldoIni[6] := aSaldoIni[6] + aSldIni[6]
			aSaldoIni[7] := aSaldoIni[7] + aSldIni[7]
			aSaldoIni[8] := aSaldoIni[8] + aSldIni[8]

			aSaldoFim[1] := aSaldoFim[1] + aSldFim[1]			/// ACUMULA O SALDO FINAL
			aSaldoFim[2] := aSaldoFim[2] + aSldFim[2]
			aSaldoFim[3] := aSaldoFim[3] + aSldFim[3]
			aSaldoFim[4] := aSaldoFim[4] + aSldFim[4]
			aSaldoFim[5] := aSaldoFim[5] + aSldFim[5]
			aSaldoFim[6] := aSaldoFim[6] + aSldFim[6]
			aSaldoFim[7] := aSaldoFim[7] + aSldFim[7]
			aSaldoFim[8] := aSaldoFim[8] + aSldFim[8]
			
			CTH->(dbSkip())
		EndDo		
	Endif
ElseIf lTemItem
    If lTemCusto
    	// SALDO DO ITEM CONTABIL + CENTRO DE CUSTO = CTV
		dbSelectArea("CTV")
		dbSetOrder(1)
		MsSeek(xFilial("CTV")+cMoeda+cTpSald+cItemIni,.T.)
		While !CTV->(Eof()) .and. CTV->CTV_FILIAL == xFilial("CTV") .and. CTV->CTV_MOEDA == cMoeda .and.;
			CTV->CTV_TPSALD == cTpSald .and. CTV->CTV_ITEM <= cItemFim
			
			If CTV->CTV_CUSTO < cCustoIni .or. CTV->CTV_CUSTO > cCustoFim
				CTV->(dbSkip())
				Loop
			EndIf

			#IFDEF TOP
				aSldIni := SldTop2Ent("CTV","CTD",CTV->CTV_ITEM,CTV->CTV_CUSTO,dDataIni,dDataIni,Val(cMoeda),cTpsald)
				aSldFim := SldTop2Ent("CTV","CTD",CTV->CTV_ITEM,CTV->CTV_CUSTO,dDataFim,dDataFim,Val(cMoeda),cTpsald)
			#ELSE
				aSldIni := SldCmpEnt(CTV->CTV_ITEM,CTV->CTV_CUSTO,dDataIni,cMoeda,cTpSald,1,"CTD","CTV","","",.F.,)			
				aSldFim := SldCmpEnt(CTV->CTV_ITEM,CTV->CTV_CUSTO,dDataFim,cMoeda,cTpSald,1,"CTD","CTV","","",.F.,)			
			#ENDIF
			
			aSaldoIni[1] := aSaldoIni[1] + aSldIni[1]			/// ACUMULA O SALDO INICIAL
			aSaldoIni[2] := aSaldoIni[2] + aSldIni[2]
			aSaldoIni[3] := aSaldoIni[3] + aSldIni[3]
			aSaldoIni[4] := aSaldoIni[4] + aSldIni[4]
			aSaldoIni[5] := aSaldoIni[5] + aSldIni[5]
			aSaldoIni[6] := aSaldoIni[6] + aSldIni[6]
			aSaldoIni[7] := aSaldoIni[7] + aSldIni[7]
			aSaldoIni[8] := aSaldoIni[8] + aSldIni[8]

			aSaldoFim[1] := aSaldoFim[1] + aSldFim[1]			/// ACUMULA O SALDO FINAL
			aSaldoFim[2] := aSaldoFim[2] + aSldFim[2]
			aSaldoFim[3] := aSaldoFim[3] + aSldFim[3]
			aSaldoFim[4] := aSaldoFim[4] + aSldFim[4]
			aSaldoFim[5] := aSaldoFim[5] + aSldFim[5]
			aSaldoFim[6] := aSaldoFim[6] + aSldFim[6]
			aSaldoFim[7] := aSaldoFim[7] + aSldFim[7]
			aSaldoFim[8] := aSaldoFim[8] + aSldFim[8]
		    
			cKey2Skip := CTV->(CTV_FILIAL+CTV_MOEDA+CTV_TPSALD+CTV_ITEM+CTV_CUSTO)
			While !Eof() .and. CTV->(CTV_FILIAL+CTV_MOEDA+CTV_TPSALD+CTV_ITEM+CTV_CUSTO) == cKey2Skip
				CTV->(dbSkip())
			EndDo		
		EndDo			
	Else
    	/// SALDO SOMENTE DO ITEM = CTU
		dbSelectArea("CTD")
		dbSetOrder(1)
		MsSeek(xFilial("CTD")+cITEMIni,.T.)
		While !CTD->(Eof()) .and. CTD->CTD_FILIAL == xFilial("CTD") .and. CTD->CTD_ITEM <= cITEMFim
			
			If CTD->CTD_CLASSE <> "2"	/// SE NÃO FOR ANALITICA
				CTD->(dbSkip())
				Loop
			Endif
		
			aSldIni := SaldoCTU("CTD",CTD->CTD_ITEM,dDataIni,cMoeda,cTpSald)
			aSldFim := SaldoCTU("CTD",CTD->CTD_ITEM,dDataFim,cMoeda,cTpSald)
					
			aSaldoIni[1] := aSaldoIni[1] + aSldIni[1]			/// ACUMULA O SALDO INICIAL
			aSaldoIni[2] := aSaldoIni[2] + aSldIni[2]
			aSaldoIni[3] := aSaldoIni[3] + aSldIni[3]
			aSaldoIni[4] := aSaldoIni[4] + aSldIni[4]
			aSaldoIni[5] := aSaldoIni[5] + aSldIni[5]
			aSaldoIni[6] := aSaldoIni[6] + aSldIni[6]
			aSaldoIni[7] := aSaldoIni[7] + aSldIni[7]
			aSaldoIni[8] := aSaldoIni[8] + aSldIni[8]

			aSaldoFim[1] := aSaldoFim[1] + aSldFim[1]			/// ACUMULA O SALDO FINAL
			aSaldoFim[2] := aSaldoFim[2] + aSldFim[2]
			aSaldoFim[3] := aSaldoFim[3] + aSldFim[3]
			aSaldoFim[4] := aSaldoFim[4] + aSldFim[4]
			aSaldoFim[5] := aSaldoFim[5] + aSldFim[5]
			aSaldoFim[6] := aSaldoFim[6] + aSldFim[6]
			aSaldoFim[7] := aSaldoFim[7] + aSldFim[7]
			aSaldoFim[8] := aSaldoFim[8] + aSldFim[8]			

			CTD->(dbSkip())
		EndDo
    Endif
ElseIf lTemCusto
	// SALDO SOMENTE DO CENTRO DE CUSTO = CTU
	dbSelectArea("CTT")
	dbSetOrder(1)
	MsSeek(xFilial("CTT")+cCustoIni,.T.)
	While !CTT->(Eof()) .and. CTT->CTT_FILIAL == xFilial("CTT") .and. CTT->CTT_CUSTO <= cCustoFim
		
		If CTT->CTT_CLASSE <> "2"	/// SE NÃO FOR ANALITICA
			CTT->(dbSkip())
			Loop
		Endif
		
		aSldIni := SaldoCTU("CTT",CTT->CTT_CUSTO,dDataIni,cMoeda,cTpSald)
		aSldFim := SaldoCTU("CTT",CTT->CTT_CUSTO,dDataFim,cMoeda,cTpSald)
				
		aSaldoIni[1] := aSaldoIni[1] + aSldIni[1]			/// ACUMULA O SALDO INICIAL
		aSaldoIni[2] := aSaldoIni[2] + aSldIni[2]
		aSaldoIni[3] := aSaldoIni[3] + aSldIni[3]
		aSaldoIni[4] := aSaldoIni[4] + aSldIni[4]
		aSaldoIni[5] := aSaldoIni[5] + aSldIni[5]
		aSaldoIni[6] := aSaldoIni[6] + aSldIni[6]
		aSaldoIni[7] := aSaldoIni[7] + aSldIni[7]
		aSaldoIni[8] := aSaldoIni[8] + aSldIni[8]

		aSaldoFim[1] := aSaldoFim[1] + aSldFim[1]			/// ACUMULA O SALDO FINAL
		aSaldoFim[2] := aSaldoFim[2] + aSldFim[2]
		aSaldoFim[3] := aSaldoFim[3] + aSldFim[3]
		aSaldoFim[4] := aSaldoFim[4] + aSldFim[4]
		aSaldoFim[5] := aSaldoFim[5] + aSldFim[5]
		aSaldoFim[6] := aSaldoFim[6] + aSldFim[6]
		aSaldoFim[7] := aSaldoFim[7] + aSldFim[7]
		aSaldoFim[8] := aSaldoFim[8] + aSldFim[8]
		
		CTT->(dbSkip())
	EndDo		
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                        ³
//³ [1] Movimento Devedor 	                        ³
//³ [2] Movimento Credor		                    ³
//³ [3] Movimento do Mes		                    ³
//³ [4] Saldo Final                                	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nDebito		:= aSaldoFim[4] - aSaldoIni[7]
nCredito	:= aSaldoFim[5] - aSaldoIni[8]

aMovimento 	:= {nDebito,nCredito,nCredito-nDebito,aSaldoFim[1]}

Return(aMovimento[nQualSaldo])

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³SaldoCTY  ³ Autor ³ Marcos S. Lobo        ³ Data ³ 14.05.04 			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Saldo da Classe de Valor + Item + C.Custo                  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SaldoCTY(cClVl,cItem,cCusto,dData,cMoeda,cTpSald,cRotina)      		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³{nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Classe de Valor                                   		    ³±±
±±³          ³ ExpC2 = Item Contabil				                       		    ³±±
±±³          ³ ExpC3 = C.Custo		                                     		    ³±±
±±³          ³ ExpD1 = Data                                              		    ³±±
±±³          ³ ExpC5 = Moeda                                             		    ³±±
±±³          ³ ExpC6 = Tipo de Saldo                                     		    ³±±
±±³          ³ ExpC7 = Rotina Chamadora                                    		    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SaldoCTY(cClasseVlr,cItem,cCusto,dData,cMoeda,cTpSald,cRotina)

Local aSaveArea	:= CTY->(GetArea())
Local aSaveAnt	:= GetArea()
Local dDataCTI
Local lNaoAchei	:= .F.
Local nDebito	:= 0					// Valor Debito na Data
Local nCredito 	:= 0					// Valor Credito na Data
Local nAtuDeb  	:= 0					// Saldo Atual Devedor
Local nAtuCrd	:= 0					// Saldo Atual Credor
Local nAntDeb	:= 0					// Saldo Anterior Devedor
Local nAntCrd	:= 0					// Saldo Anterior Credor
Local nSaldoAnt	:= 0					// Saldo Anterior (com sinal)
Local nSaldoAtu	:= 0					// Saldo Atual (com sinal)
Local bCondicao	:= { || CTY->CTY_FILIAL == xFilial("CTY") .And.;
						CTY->CTY_CLVL == cClasseVlr .And.;
						CTY->CTY_ITEM == cItem .And.;
						CTY->CTY_CUSTO == cCusto .And.;
						CTY->CTY_MOEDA == cMoeda .And.;
						CTY->CTY_TPSALD == cTpSald .And. CTY->CTY_DATA <= dData }
Local aSldLP	:= {0,0}
Local nDebLP	:= 0
Local nCrdLP	:= 0

cTpSald 	:= Iif(Empty(cTpSald),"1",cTpSald)
cRotina		:= Iif(cRotina==Nil,"",cRotina)
cCusto		:= Left(AllTrim(cCusto) + Space(Len(CTI->CTI_CUSTO)), Len(CTI->CTI_CUSTO))
cItem 		:= Left(AllTrim(cItem) + Space(Len(CTI->CTI_ITEM)), Len(CTI->CTI_ITEM))
cClasseVlr	:= Left(AllTrim(cClasseVlr) + Space(Len(CTI->CTI_CLVL)), Len(CTI->CTI_CLVL))

// Saldo composto C Custo + Item + Classe Valor
If !Empty(cCusto) .Or. !Empty(cItem)
	dbSelectArea("CTY")
	dbSetOrder(1)
	MsSeek(xFilial("CTY")+cMoeda+cTpSald+cClasseVlr+cItem+cCusto+DTOS(dData),.T.)
	If !Eval(bCondicao)
		dbSkip(-1)
		lNaoAchei := .T.
	Else	//Verificar se existe algum registro de zeramento na mesma data 
		dbSkip()
		If !Eval(bCondicao) //Se nao existir registro na mesma data, volto para o registro anterior. 
			dbSkip(-1)
		EndIf		
	EndIf

	If Eval(bCondicao)
		// Movimentacoes na data
		If CTY->CTY_DATA == dData
			nDebito	:= CTY->CTY_DEBITO
			nCredito:= CTY->CTY_CREDITO
		Endif	
		nAtuDeb	:= CTY->CTY_ATUDEB
		nAtuCrd  := CTY->CTY_ATUCRD
		If lNaoAchei
			// Neste caso, como a data nao foi encontrada, considera-se como saldo anterior
			// o saldo atual do registro anterior! -> dbskip(-1)
			nAntDeb  := CTY->CTY_ATUDEB
			nAntCrd  := CTY->CTY_ATUCRD
		Else		
			nAntDeb  := CTY->CTY_ANTDEB
			nAntCrd  := CTY->CTY_ANTCRD						
		Endif                          
		
		If cRotina = "CTBA210"
			//Se foi chamado pela rotina de apuracao de lucros/perdas,existe um registro
			//na data solcitada e o saldo nao eh o do proprio zeramento, considero como 
			//saldo anterior, o saldo atual antes do zeramento. 
			If CTY->CTY_LP	<> 'Z'
				nAntDeb  := CTY->CTY_ATUDEB                  		
				nAntCrd  := CTY->CTY_ATUCRD		
			Endif
		Endif
		
		nSaldoAtu:= nAtuCrd - nAtuDeb
		nSaldoAnt:= nAntCrd - nAntDeb
	EndIf
Else
	nDebito		:= 0
	nCredito 	:= 0
	nAtuDeb  	:= 0
	nAtuCrd		:= 0
	nAntDeb		:= 0
	nAntCrd		:= 0
	nSaldoAnt	:= 0
	nSaldoAtu	:= 0
EndIf

RestArea(aSaveAnt)
CTY->(RestArea(aSaveArea))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorno:                                             ³
//³ [1] Saldo Atual (com sinal)                          ³
//³ [2] Debito na Data                                   ³
//³ [3] Credito na Data                                  ³
//³ [4] Saldo Atual Devedor                              ³
//³ [5] Saldo Atual Credor                               ³
//³ [6] Saldo Anterior (com sinal)                       ³
//³ [7] Saldo Anterior Devedor                           ³
//³ [8] Saldo Anterior Credor                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//      [1]       [2]     [3]      [4]     [5]     [6]       [7]     [8]
Return {nSaldoAtu,nDebito,nCredito,nAtuDeb,nAtuCrd,nSaldoAnt,nAntDeb,nAntCrd}

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtPlGerSld ³ Autor ³ Simone Mie Sato       ³ Data ³ 11.07.02 		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Plano Gerencial para Comparativos de 1 Entidade             			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtPlGerSld(oMeter,oText,oDlg,lEnd,dDataIni,dDataFim,cMoeda,aSetOfBook) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpO1 = Objeto oMeter                     	                 		 ³±±
±±³          ³ ExpO2 = Objeto oText                      	                 		 ³±±
±±³          ³ ExpO3 = Objeto oDlg                       	                 		 ³±±
±±³          ³ ExpL1 = Acao do CodeBlock                 	                 		 ³±±
±±³          ³ ExpD1 = Data Inicial                      	                 		 ³±±
±±³          ³ ExpD2 = Data Final                        	                 		 ³±±
±±³          ³ ExpC1 = Moeda                              	                 		 ³±±
±±³          ³ ExpA1 = Array Set Of Book                  	                 		 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtPlGerSld(oMeter,oText,oDlg,lEnd,dDataIni,dDataFim,cMoeda,aSetOfBook,;
					cAlias,cIdent,lImpAntLP,dDataLP,cTpSld1,cTpSld2,cMoedCmp,bVariacao,;
					nQualSaldo)

Local aSaveArea := GetArea()
Local aSaldoAnt1
Local aSaldoAnt2	
Local aSaldoAtu1
Local aSaldoAtu2

Local cConta
Local cCodNor
Local cNormal
Local cContaSup
Local cDesc
Local cPlanGer := aSetOfBook[5]
Local cContaIni	:= Space(Len(Criavar("CT1_CONTA")))
Local cContaFim	:= Repl("Z",Len(Criavar("CT1_CONTA")))
Local cCustoIni	:= Space(Len(Criavar("CTT_CUSTO")))
Local cCustoFim	:= Repl("Z",Len(Criavar("CTT_CUSTO")))
Local cItemIni	:= Space(Len(Criavar("CTD_ITEM")))
Local cItemFim	:= Repl("Z",Len(Criavar("CTD_ITEM")))
Local cClvlIni	:= Space(Len(Criavar("CTH_CLVL")))
Local cClVlFim	:= Repl("Z",Len(Criavar("CTH_CLVL")))

Local lConta 	:= .F.
Local lCusto	:= .F.
Local lItem		:= .F.
Local lClasse	:= .F.
Local lIgual

Local nReg
Local nDebito1	:= 0
Local nDebito2	:= 0
Local nCredito1	:= 0 
Local nCredito2	:= 0
Local nMovim1	:= 0
Local nMovim2	:= 0
Local aContas	:= {}
Local nPos		:= 0

cAlias	:= Iif(cAlias == Nil,"",cAlias)
cIdent	:= Iif(cIdent == Nil,"",cIdent)
cMoedCmp := Iif(cMoedCmp == Nil,cMoeda,cMoedCmp)

oMeter:nTotal := CTS->(RecCount())

dbSelectArea("CTS")
dbSetOrder(1)

MsSeek(xFilial()+cPlanGer,.T.)

While !Eof() .And. 	CTS->CTS_FILIAL == xFilial() .And.;
					CTS->CTS_CODPLA == cPlanGer

	If CTS->CTS_CLASSE == "1"
		dbSkip()
		Loop
	EndIf

	// Recarrega variáveis
	lConta 	:= .F.
	lCusto	:= .F.
	lItem	:= .F.
	lClasse	:= .F.

	// Grava conta analitica
	cConta 	:= CTS->CTS_CONTAG
	cDesc	:= CTS->CTS_DESCCG
	cOrdem	:= CTS->CTS_ORDEM

	nDebito1	:= 0	
	nCredito1	:= 0
	nMovim1 	:= 0
	nDebito2	:= 0
	nCredito2	:= 0
	nMovim2		:= 0

	dbSelectArea("cArqTmp")
	dbSetOrder(1)	
	If !MsSeek(xFilial()+cConta) .Or. (CTS->CTS_IDENT = "5" .Or. CTS->CTS_CLASSE="3")
		dbAppend()                    
		Replace CONTA 		With cConta
		Replace DESCCTA    	With cDesc
		Replace TIPOCONTA 	With CTS->CTS_CLASSE
		Replace NORMAL    	With CTS->CTS_NORMAL
		Replace ORDEM		With CTS->CTS_ORDEM
		//Se a classe for "Titulo" devera ser impresso somente a descricao da conta, 
		//sem os valores. Da mesma forma que o Identificador igual a 5 (Separdor)
		If CTS->CTS_CLASSE = "3"
			Replace IDENTIFI	With "5"
		Else
			Replace IDENTIFI	With CTS->CTS_IDENT
		EndIf		
	EndIf

	dbSelectArea("CTS")
	dbSetOrder(1)
	aContas := {}
	While !Eof() .And. CTS->CTS_FILIAL == xFilial() .And.;
						CTS->CTS_CODPLA == cPlanGer  .And. CTS->CTS_ORDEM	== cOrdem

		If (!Empty(CTS->CTS_CTHINI)	.Or. !Empty(CTS->CTS_CTHFIM))		// Saldo a partir da classe
			lClasse := .T.
			cClVlIni	:= CTS->CTS_CTHINI
			cClVlFim	:= CTS->CTS_CTHFIM
		EndIf
		If (!Empty(CTS->CTS_CTDINI) .Or. !Empty(CTS->CTS_CTDFIM))	// Saldo a partir do Item
			lItem := .T.
			cItemIni	:= CTS->CTS_CTDINI
			cItemFim	:= CTS->CTS_CTDFIM			
		EndIf
		If (!Empty(CTS->CTS_CTTINI) .Or. !Empty(CTS->CTS_CTTFIM))	// Saldo a partir do C.Custo
			lCusto := .T.
			cCustoIni	:= CTS->CTS_CTTINI
			cCustoFim	:= CTS->CTS_CTTFIM
		EndIf
		If (!Empty(CTS->CTS_CT1INI) .Or. !Empty(CTS->CTS_CT1FIM))	// Saldo a partir da Conta
			lConta := .T.
			cContaIni	:= CTS->CTS_CT1INI
			cContaFim	:= CTS->CTS_CT1FIM
			Aadd(aContas, { cContaIni, cContaFim })
		EndIf

		If lConta
			aSaldoAnt1 := SaldTotCT7(cContaIni,cContaFim,dDataIni,cMoedCmp,cTpSld1,lImpAntLP,dDataLP)
			aSaldoAtu1 := SaldTotCT7(cContaIni,cContaFim,dDataFim,cMoedCmp,cTpSld1,lImpAntLP,dDataLP)
			aSaldoAnt2 := SaldTotCT7(cContaIni,cContaFim,dDataIni,cMoeda,cTpSld2,lImpAntLP,dDataLP)
			aSaldoAtu2 := SaldTotCT7(cContaIni,cContaFim,dDataFim,cMoeda,cTpSld2,lImpAntLP,dDataLP)
		EndIf         
		
		If lCusto
			aSaldoAnt1:= SaldTotCT3(cCustoIni,cCustoFim,cContaIni,;
								cContaFim,dDataIni,cMoedCmp,cTpSld1)
			aSaldoAtu1 := SaldTotCT3(cCustoIni,cCustoFim,cContaIni,;
								cContaFim,dDataFim,cMoedCmp,cTpSld1)
			aSaldoAnt2:= SaldTotCT3(cCustoIni,cCustoFim,cContaIni,;
								cContaFim,dDataIni,cMoeda,cTpSld2)
			aSaldoAtu2 := SaldTotCT3(cCustoIni,cCustoFim,cContaIni,;
								cContaFim,dDataFim,cMoeda,cTpSld2)								
		EndIf
		
		If lItem		
			aSaldoAnt1 := SaldTotCT4(cItemIni,cItemFim,cCustoIni,;
								cCustoFim,cContaIni,cContaFim,;
								dDataIni,cMoedCmp,cTpSld1)
			aSaldoAtu1 := SaldTotCT4(cItemIni,cItemFim,cCustoIni,;
								cCustoFim,cContaIni,cContaFim,;
								dDataFim,cMoedCmp,cTpSld1)
			aSaldoAnt2 := SaldTotCT4(cItemIni,cItemFim,cCustoIni,;
								cCustoFim,cContaIni,cContaFim,;
								dDataIni,cMoeda,cTpSld2)								
			aSaldoAtu2 := SaldTotCT4(cItemIni,cItemFim,cCustoIni,;
								cCustoFim,cContaIni,cContaFim,;
								dDataFim,cMoeda,cTpSld2)

		EndIf
		
		If lClasse
			aSaldoAnt1 := SaldTotCTI(cClVlIni,cClVlFim,cItemIni,;
								cItemFim,cCustoIni,cCustoFim,cContaIni,;
								cContaFim,dDataIni,cMoedCmp,cTpSld1)								
			aSaldoAtu1 := SaldTotCTI(cClVlIni,cClVlFim,cItemIni,;
								cItemFim,cCustoIni,cCustoFim,cContaIni,;
								cContaFim,dDataFim,cMoedCmp,cTpSld1)
			aSaldoAnt2 := SaldTotCTI(cClVlIni,cClVlFim,cItemIni,;
								cItemFim,cCustoIni,cCustoFim,cContaIni,;
								cContaFim,dDataIni,cMoeda,cTpSld2)								
			aSaldoAtu2 := SaldTotCTI(cClVlIni,cClVlFim,cItemIni,;
								cItemFim,cCustoIni,cCustoFim,cContaIni,;
								cContaFim,dDataFim,cMoeda,cTpSld2)								
		EndIf                                                                  
		
		If aSetOfBook[9] > 1	// Divisao por fator
			For nPos := 1 To Len(aSaldoAnt)
				aSaldoAnt1[nPos] := Round(NoRound((aSaldoAnt1[nPos]/aSetOfBook[9]),3),2)
				aSaldoAnt2[nPos] := Round(NoRound((aSaldoAnt2[nPos]/aSetOfBook[9]),3),2)				
			Next
			For nPos := 1 To Len(aSaldoAtu)
				aSaldoAtu1[nPos] := Round(NoRound((aSaldoAtu1[nPos]/aSetOfBook[9]),3),2)
				aSaldoAtu2[nPos] := Round(NoRound((aSaldoAtu2[nPos]/aSetOfBook[9]),3),2)				
			Next
		Endif

		If CTS->CTS_IDENT $ "78"	// Somo/Subtraio mostrando sinal
			If CTS->CTS_IDENT = "7" .And. ! Left(("cArqTmp")->DESC, 3) = "(+)"
				Replace ("cArqTmp")->DESC With "(+) " + ("cArqTmp")->DESC
			ElseIf CTS->CTS_IDENT = "8" .And. ! Left(("cArqTmp")->DESC, 3) = "(-)"
				Replace ("cArqTmp")->DESC With "(-) " + ("cArqTmp")->DESC
			Endif
		Endif

		// Calculos com os Fatores
		If (CTS->CTS_IDENT $ "17" .Or. CTS->CTS_IDENT $ "28") .And. (CTS->CTS_CLASSE <> "3") .And. ;
			Empty(CTS->CTS_FORMUL)	 			// Soma / Subtrai
			If CTS->CTS_IDENT $ "17"			// Somo os saldos
				If nQualSaldo = 1		// Movimento
					nDebito1	+= aSaldoAtu1[4] - aSaldoAnt1[7]
					nCredito1	+= aSaldoAtu1[5] - aSaldoAnt1[8]		
					nMovim1		:= nCredito1 - nDebito1 
		    	
					nDebito2	+= aSaldoAtu2[4] - aSaldoAnt2[7]
					nCredito2	+= aSaldoAtu2[5] - aSaldoAnt2[8]
					nMovim2			:= nCredito2 - nDebito2		
				Else
					nMovim1 	+= aSaldoAtu1[1]
					nMovim2  	+= aSaldoAtu2[1]
				Endif
			ElseIf CTS->CTS_IDENT $ "28"		// Subtraio os saldos
				If nQualSaldo = 1		// Movimento
					nDebito1	-= aSaldoAtu1[4] - aSaldoAnt1[7]
					nCredito1	-= aSaldoAtu1[5] - aSaldoAnt1[8]		
					nMovim1		:= nCredito1 - nDebito1 
		
					nDebito2	-= aSaldoAtu2[4] - aSaldoAnt2[7]
					nCredito2	-= aSaldoAtu2[5] - aSaldoAnt2[8]
					nMovim2		:= nCredito2 - nDebito2					
				Else
					nMovim1 	+= aSaldoAtu1[1]
					nMovim2  	+= aSaldoAtu2[1]
				Endif
			EndIf
		EndIf
		
		dbSelectArea("CTS")
		dbSetOrder(1)  
		nReg := Recno()
		dbSkip()
	EnddO

	dbSelectArea("CTS")
	dbSetOrder(2)
	dbGoTo(nReg)
	cCodNor := CTS->CTS_NORMAL

	dbSelectArea("cArqTmp")
	Replace MOVIMENTO1	With MOVIMENTO1 + nMovim1
	Replace MOVIMENTO2	With MOVIMENTO2 + nMovim2
	Replace VARIACAO With (MOVIMENTO1/MOVIMENTO2) *100
	
	If bVariacao <> Nil
		Eval(bVariacao, .T., aContas)
	Endif		
		
	dbSelectArea("CTS")
	dbSetOrder(2)
	// Grava contas sinteticas
	If !Empty(CTS->CTS_CTASUP)
		While !Eof() .And. 	CTS->CTS_FILIAL == xFilial() .And. ;
								CTS->CTS_CODPLAN == cPlanGer
	
			cContaSup 	:= CTS->CTS_CTASUP
			lIgual		:= CTS->CTS_IDENT = "9"
			
			dbSelectArea("CTS")
			dbSetOrder(2)
			If MsSeek(xFilial()+cPlanGer+cContaSup)
				cDesc 	:= CTS->CTS_DESCCG
				cNormal := CTS->CTS_NORMAL
			Else
				cNormal	:= cCodNor	
			EndIf

			dbSelectArea("cArqTmp")

			If lIgual .And. ! Left(DESCCTA, 3) = "(=)"
				Replace DESCCTA With "(=) " + DESCCTA
			Endif

			dbSetOrder(1)
			If !MsSeek(cContaSup)
				dbAppend() 
				Replace CONTA	With cContaSup
				Replace DESCCTA With cDesc		
				Replace TIPOCONTA	With CTS->CTS_CLASSE
				Replace NORMAL   	With CTS->CTS_NORMAL
				Replace ORDEM		With CTS->CTS_ORDEM
				Replace IDENTIFI	With CTS->CTS_IDENT
			EndIf    
	
			Replace	MOVIMENTO1 With MOVIMENTO1 + nMovim1			// Movimento Coluna 1
			Replace MOVIMENTO2 With MOVIMENTO2 + nMovim2			// Movimento Coluna 2
			Replace VARIACAO With (MOVIMENTO1/MOVIMENTO2) *100			
			
			If bVariacao <> Nil
				Eval(bVariacao, .T.)
			Endif		
			
			dbSelectArea("CTS")
			If !Eof() .And. Empty(CTS->CTS_CTASUP)
				dbSelectArea("cArqTmp")
				Replace NIVEL1 With .T.
				dbSelectArea("CTS")
				Exit
			EndIf
		EndDo
	EndIf


	dbSelectArea("CTS")
	dbSetOrder(1)
	dbGoTo(nReg)
	dbSkip()

EndDo

RestArea(aSaveArea)

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CtbVlrMoed ³ Autora³ Simone Mie Sato     ³ Data ³ 22.07.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Recupera o valor em outras moedas.                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbVlrMoed()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³nValor                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ dData	  = Data do Lancamento                            ³±±
±±³          ³ cLote	  = Lote           	                              ³±±
±±³          ³ cSublote   = SubLote                                       ³±±
±±³          ³ cDoc       = Documento                                     ³±±
±±³          ³ cLinha     = Numero da Linha                               ³±±
±±³          ³ cTpSald    = Tipo do Saldo                                 ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cEmpOri    = Empresa Origem                                ³±±
±±³          ³ cFilOri    = Filial Origem                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbVlrMoed(dData,cLote,cSubLote,cDoc,cLinha,cTpSald,cMoeda,cEmpOri,cFilOri)

Local aSaveArea	:= GetArea()
Local nValor	:= 0

dbSelectArea("CT2")
dbSetOrder(1)
If MsSeek(xFilial()+dtos(dData)+cLote+cSubLote+cDoc+cLinha+cTpSald+cEmpOri+cFilOri+cMoeda)
	nValor	:= CT2->CT2_VALOR
EndIf

RestArea(aSaveArea)
Return(nValor)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CtbConvert ³ Autora³ Simone Mie Sato     ³ Data ³ 22.07.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna o criterio de conversao utilizado                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbConvert()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³nValor                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ dData	  = Data do Lancamento                            ³±±
±±³          ³ cLote	  = Lote           	                              ³±±
±±³          ³ cSublote   = SubLote                                       ³±±
±±³          ³ cDoc       = Documento                                     ³±±
±±³          ³ cLinha     = Numero da Linha                               ³±±
±±³          ³ cTpSald    = Tipo do Saldo                                 ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cEmpOri    = Empresa Origem                                ³±±
±±³          ³ cFilOri    = Filial Origem                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbConvert(dData,cLote,cSubLote,cDoc,cLinha,cTpSald,cMoeda,cEmpOri,cFilOri)

Local aSaveArea	:= GetArea()
Local cConverte	:= ""

dbSelectArea("CT2")
dbSetOrder(1)
If MsSeek(xFilial()+dtos(dData)+cLote+cSubLote+cDoc+cLinha+cTpSald+cEmpOri+cFilOri+cMoeda)
	cConverte	:= CT2->CT2_CRCONV
Else
	cConverte	:= "5"	//Se nao achou
EndIf

RestArea(aSaveArea)
Return(cConverte)
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CtGrVlMoed  ³ Autora³ Simone Mie Sato     ³ Data ³ 22.07.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava valor em outra moeda                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtGrVlMoed()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ dData	  = Data do Lancamento                            ³±±
±±³          ³ cLote	  = Lote           	                              ³±±
±±³          ³ cSublote   = SubLote                                       ³±±
±±³          ³ cDoc       = Documento                                     ³±±
±±³          ³ cLinha     = Numero da Linha                               ³±±
±±³          ³ cTpSald    = Tipo do Saldo                                 ³±±
±±³          ³ cMoeda     = Moeda                                         ³±±
±±³          ³ cEmpOri    = Empresa Origem                                ³±±
±±³          ³ cFilOri    = Filial Origem                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtGrVlMoed(dData,cLote,cSubLote,cDoc,cLinha,cTpSald,cMoeda,cEmpOri,cFilOri,nValor,cDc,;
	cContaDeb,cDigDeb,cContaCrd,cDigCrd,cCustoDeb,cCustoCrd,cItemdeb,cItemCrd,cClVlDeb,cClVlCrd,;
	cLP,cSequenc,cOrigem,cAglut,cCriter,cHp,cHist,cSeqLan,cSeqHis,dDatalP,cSlBase)

Local aSaveArea	:= GetArea()

dbSelectArea("CT2")
dbSetOrder(1)
If !MsSeek(xFilial()+dtos(dData)+cLote+cSubLote+cDoc+cLinha+cTpSald+cEmpOri+cFilOri+cMoeda)
	Reclock("CT2",.T.)
	CT2->CT2_FILIAL		:= xFilial()
	CT2->CT2_DATA		:= dData
	CT2->CT2_LOTE		:= cLote
	CT2->CT2_SBLOTE		:= cSubLote
	CT2->CT2_DOC		:= cDoc
	CT2->CT2_LINHA		:= cLinha
	CT2->CT2_FILORI		:= cFilOri
	CT2->CT2_EMPORI		:= cEmpOri                 
	CT2->CT2_DC			:= cDc
	CT2->CT2_DEBITO		:= cContaDeb
	CT2->CT2_DCD		:= cDigDeb
	CT2->CT2_CREDIT		:= cContaCrd
	CT2->CT2_DCC		:= cDigCrd
	CT2->CT2_CCD		:= cCustoDeb
	CT2->CT2_CCC		:= cCustoCrd	
	CT2->CT2_ITEMD		:= cItemDeb
	CT2->CT2_ITEMC		:= cItemCrd
	CT2->CT2_CLVLDB		:= cClVlDeb
	CT2->CT2_CLVLCR		:= cClVlCrd
	CT2->CT2_LP			:= cLP
	CT2->CT2_SEQUEN		:= cSequenc
	CT2->CT2_ROTINA		:= FUNNAME()
	CT2->CT2_ORIGEM		:= cOrigem
	CT2->CT2_AGLUT		:= cAglut
	CT2->CT2_MOEDLC		:= cMoeda
	CT2->CT2_TPSALD		:= cTpSald
	CT2->CT2_HP			:= cHP
	CT2->CT2_HIST		:= cHist
	CT2->CT2_SEQLAN		:= cSeqLan
	CT2->CT2_SEQHIS		:= cSeqHis
	CT2->CT2_MANUAL		:= "1"
	CT2->CT2_DTLP		:= dDataLp
	CT2->CT2_SLBASE		:= cSlBase
Else
	RecLock("CT2",.F.)	
EndIf
CT2->CT2_VALOR	:= nValor              
CT2->CT2_CRCONV	:= cCriter
MsUnlock()

RestArea(aSaveArea)

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CtVlOutvlr ³ Autora³ Simone Mie Sato     ³ Data ³ 05.08.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o crit. eh igual 4. So podera alterar se for 4  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtVlOutVlr()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T./.F.                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nValorr	 = Valor                                          ³±±
±±³          ³ nMoeda 	 = Numero da Moeda                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtVlOutVlr(nValor,nMoeda)

Local aSaveArea	:= GetArea()
Local lRet		:= .T.

If nValor <> 0 
	If Subs(TMP->CT2_CONVER,nMoeda,1) <> "4"
		lRet	:= .F.
		Help(" ",1,"NOCRITER")
	EndIf
EndIf

RestArea(aSaveArea)
Return(lRet)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³ CtbImpReg    ³ Autor ³ Wagner Mobile Costa	³ Data ³ 12/03/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Importa registros gerados para base do dicionario              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbImpReg( cAlias, aRegistros )                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ CtbaUpd                                                    	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias para importacao da matriz                    	  ³±±
±±³          ³ ExpA1 = Array na mesma ordem dos campos (gerado p/Delimitador) ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbImpReg(cAlias, aRegistros)

Local aEstrutura, nRegs, nCpos
Local lAppend, cPath

DbSelectArea(cAlias)

If cAlias = "SIX"
	aEstrutura := { "INDICE", "ORDEM", "CHAVE", "DESCRICAO", "DESCSPA", "DESCENG",;
					"PROPRI","F3", "NICKNAME" }
ElseIf cAlias = "SX2"
	aEstrutura := {  "X2_CHAVE", "X2_PATH", "X2_ARQUIVO", "X2_NOME", "X2_NOMESPA",;
					 "X2_NOMEENG", "X2_DELET", "X2_MODO", "X2_TTS", "X2_ROTINA" }
	DbSeek("CT2")
	cPath := X2_PATH
ElseIf cAlias = "SX3"
	aEstrutura := {  "X3_ARQUIVO", "X3_ORDEM", "X3_CAMPO", "X3_TIPO", "X3_TAMANHO",;
	  				 "X3_DECIMAL", "X3_TITULO", "X3_TITSPA", "X3_TITENG", "X3_DESCRIC",;
	  				 "X3_DESCSPA", "X3_DESCENG", "X3_PICTURE", "X3_VALID", "X3_USADO",;
	  				 "X3_RELACAO", "X3_F3", "X3_NIVEL", "X3_RESERV", "X3_CHECK",;
	  				 "X3_TRIGGER", "X3_PROPRI", "X3_BROWSE", "X3_VISUAL", "X3_CONTEXT",;
	  				 "X3_OBRIGAT", "X3_VLDUSER", "X3_CBOX", "X3_CBOXSPA", "X3_CBOXENG",;
	  				 "X3_PICTVAR", "X3_WHEN", "X3_INIBRW", "X3_GRPSXG", "X3_FOLDER" }
	DbSetOrder(2)		// Ordem por campo
Endif

For nRegs := 1 To Len(aRegistros)
	lAppend := .T.
	If cAlias = "SIX"
		lAppend := ! DbSeek(aRegistros[nRegs][1] + aRegistros[nRegs][2])
		If lAppend .And. Select(aRegistros[nRegs][1]) > 0
			(aRegistros[nRegs][1])->(DbCloseArea())
		Endif
	ElseIf cAlias = "SX2"
		lAppend := ! DbSeek(aRegistros[nRegs][1])
	ElseIf cAlias = "SX3"
		lAppend := ! DbSeek(aRegistros[nRegs][3])
	Endif
	If lAppend
		DbAppend()
		For nCpos := 1 To Len(aEstrutura)
			If aEstrutura[nCpos] = "X2_PATH"
				Replace X2_PATH With cPath
			ElseIf aEstrutura[nCpos] = "X2_ARQUIVO"
				Replace X2_ARQUIVO With X2_CHAVE + SM0->M0_CODIGO + "0"
			Else
				Replace &(aEstrutura[nCpos]) With aRegistros[nRegs][nCpos]
			Endif
		Next
	Endif
Next

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³CtbVldDig ³ Autor ³ Simone Mie Sato       ³ Data ³ 01.10.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida o digito verificador da conta contabil              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbVldDig(cConta,cDigito)                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. / .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cConta = Conta                                             ³±±
±±³          ³ cDigito = Digito Verificador                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbVldDig(cConta,cDigito)

Local aSaveArea	:= GetArea()      
Local lRet		:= .T.

dbSelectArea("CT1")
dbSetOrder(1)
If MsSeek(xFilial()+cConta)
	If CT1->CT1_DC <> cDigito
		lRet	:= .F.
		Help( " ", 1, "DIGITO" )		
	EndIf	
EndIf

RestArea(aSaveArea)

Return(lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³CtbSinalMov³ Autor ³ Wagner Mobile Costa  ³ Data ³ 18.10.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna se deve demonstrar o sinal de acordo com MV_TPVALOR³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbSinalMov()                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. / .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cConta = Conta                                             ³±±
±±³          ³ cDigito = Digito Verificador                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbSinalMov

Return SuperGetMv("MV_TPVALOR") $ "C/D"

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡ao    ³Ctbr380Val³ Autor ³ Wagner Mobile Costa   ³ Data ³ 08/05/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Calcula o valor da variacao monetaria da data-base (CT2)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³ CTBR380                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function Ctbr380Val(lPlGer, aContas)

Local lDebito 	:= .F., cCriter, nTaxa := 0, nSal1C, aAnaCta := {}, nAnaCta := 1

DEFAULT lPlGer 	:= .F.
DEFAULT aContas	:= { cArqTmp->CONTA }

// Se for plano gerencial, devera eleger somente contas que tenham variacao monetaria

If ! lPlGer .And. Empty(CT1->CT1_CTAVM) .And. cArqTmp->TIPOCONTA = "2"
	DbDelete()
ElseIf cArqTmp->TIPOCONTA = "2"
	If mv_par20 = 1
		If ValType(aContas[1]) = "A"
			For nAnaCta := 1 To Len(aContas)
				CT1->(DbSeek(xFilial() + aContas[nAnaCta][1]))
				While 	CT1->CT1_FILIAL = xFilial() .And.;
						CT1->CT1_CONTA <= aContas[nAnaCta][2] .And. ! CT1->(Eof())
					If CT1->CT1_CLASSE = "2"
						Aadd(aAnaCta, CT1->CT1_CONTA)
					Endif
					CT1->(DbSkip())
				EndDo
			Next
		Else
			aAnaCta := Aclone(aContas)
		Endif
		For nAnaCta := 1 To Len(aAnaCta)
			CT2->(DbSetOrder(2))
			If CT2->(DbSeek(xFilial() + aAnaCta[nAnaCta] + Dtos(mv_par01)))
				While 	CT2->CT2_DEBITO = aAnaCta[nAnaCta] 	.And.;
						CT2->CT2_DATA = mv_par01 			.And. ! CT2->(Eof())
					If CT2->CT2_MOEDLC = mv_par07 .And. CT2->CT2_ROTINA = "CTBA380"
						Replace COLUNA_1 With CT2->CT2_VALOR * -1
						lDebito := .T.
					Endif
					CT2->(DbSkip())
				EndDo
			Endif
			CT2->(DbSetOrder(3))
			If ! lDebito .And. CT2->(DbSeek(xFilial() + aAnaCta[nAnaCta] + Dtos(mv_par01)))
				While 	CT2->CT2_CREDIT = aAnaCta[nAnaCta] 	.And.;
						CT2->CT2_DATA = mv_par01 			.And. ! CT2->(Eof())
					If CT2->CT2_MOEDLC = mv_par07 .And. CT2->CT2_ROTINA = "CTBA380"
						Replace COLUNA_1 With CT2->CT2_VALOR
						lDebito := .T.
					Endif
					CT2->(DbSkip())
				EndDo
			Endif
		Next
		CT2->(DbSetOrder(1))
	Else
		If mv_par21 = 2
			If cArqTmp->NORMAL = "1"
				cCriter := &("CT1->CT1_CVD" + mv_par07)
			Else
				cCriter := &("CT1->CT1_CVC" + mv_par07)
			Endif
			If cCriter = "1" .And. CTP->(DbSeek(xFilial()+DTOS(mv_par01)+mv_par07))
				nTaxa := CTP->CTP_TAXA
			ElseIf cCriter = "2"
				nTaxa := aMedias[Val(mv_par07)]
			ElseIf cCriter = "3" .And. CTP->(DbSeek(xFilial()+DTOS(LastDay(mv_par01))+mv_par07))
				nTaxa := CTP->CTP_TAXA
			Endif
		Else
			If CTO->CTO_MOEDA # mv_par07	// Garanto que a moeda esteja posicionada
				CTO->(DbSeek(xFilial() + mv_par07))
			Endif
			cCriter := CTO->CTO_CRITER
			If cCriter = "1" .And. CTP->(DbSeek(xFilial()+DTOS(mv_par01)+mv_par07))
				nTaxa := CTP->CTP_TAXA
			ElseIf cCriter = "2"
				nTaxa := aMedias[Val(mv_par07)]
			ElseIf cCriter = "3" .And. CTP->(DbSeek(xFilial()+DTOS(LastDay(mv_par01))+mv_par07))
				nTaxa := CTP->CTP_TAXA
			ElseIf cCriter = "4"
				nTaxa := CTO->CTO_TXINF
			Endif
		Endif
	
		nSal1C := NoRound(MOVIMENTO1 / nTaxa, 2)
		If 	nTaxa > 0 .And. nSal1C <> 0 .And. nSal1C <> MOVIMENTO2
			Replace COLUNA_1 With MOVIMENTO2 - nSal1C
		Endif		
	Endif
	
	If COLUNA_1 = 0 .And. mv_par06 = 2
		DbDelete()
	Else
		Replace COLUNA_2 	With MOVIMENTO2
		Replace MOVIMENTO2  With MOVIMENTO2 - COLUNA_1
		Replace VARIACAO 	With Round(NoRound((Abs(COLUNA_1) / Abs(MOVIMENTO2)) * 100, 2), 2)
	Endif
ElseIf cArqTmp->TIPOCONTA = "1"
	Replace VARIACAO 	With Round(NoRound((Abs(COLUNA_1) / Abs(MOVIMENTO2)) * 100, 2), 2)
Endif

Return


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CTBSQChv   ³ Autor ³ Leonardo            ³ Data ³ 14/01/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retornar a chave da tabela SC conforme MV_SEQCORR           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbSQChv(ExpC1)      	               					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ ExpC1 = Tipo de sequencia (MV_SEQCORR)                     ³±±
±±³          ³ ExpC2 = Lancamento Padrao                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCTB                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CTBSQChv( cTipoSeq, cLancPad )
Local cChave 
Local cTpCorr, cTpZera
Local cSeqLan001 := GetNewPar("MV_SQSUB01","500|501|502|563|565|575|576|581")
Local cSeqLan002 := GetNewPar("MV_SQSUB02","510|513|514|560|561|562|564|570|571|590|591|597")
Local cSeqLan003 := GetNewPar("MV_SQSUB03","")
             
Default cTipoSeq := "1A"
cTpCorr := Subs( cTipoSeq, 1, 1)  // "1" ou "2"
cTpZera := Subs( cTipoSeq, 2, 1)  // "M", "A" ou diferente (nao zera)
    
cChave  := "" 
If cTpZera = "M"
	cChave := Subs( DtoS( dDataBase), 3, 4) //"yymm" - chave mensal
ElseIf cTpZera = "A"
    cChave := Subs( DtoS( dDataBAse), 3, 2) //"yy" - chave anual
EndIF

If cTpCorr = "1"
	// UNICO 
    cChave := cChave + "0"
Else 
    // CLASSIFICA POR TIPO DE COMPROVANTE (INGRESO, EGRESO OU TRASPASO)
	If AllTrim(cLancPad) $ cSeqLan001
		cChave := cChave + "1"
	ElseIf AllTrim(cLancPad) $ cSeqLan002
		cChave := cChave + "2"
	ElseIf Empty(cSeqLan003) .Or. AllTrim(cLancPad) $ cSeqLan003
		cChave := cChave + "3"
	Else
	   cChave := cChave + "0"	
	EndIf                       
EndIf

Return( cChave )           


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CTBSQCor   ³ Autor ³ Lucas			    ³ Data ³ 07/01/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retornar o proximo N£mero de Sequencia Correlativa-Chile.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpC1:= CtbSQCor()   	               					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpC1 = Lancamento Padrao (default CT5)                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCTB                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CTBSQCor( cLancPad )
Local aSaveArea := GetArea()
Local cTipoSeq  := "0"
Local cSeqOfic  := "0000000001"
Local cChaveTab := ""
Local aTamSeq   := {}

DEFAULT cLancPad := CT5->CT5_LANPAD

cTipoSeq := GetNewPar("MV_SEQCORR","1AN")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gravar no campo CT2_SEGOFIC a sequencia do numero correlativo³
//³ conforme legislacao do Chile utilizando o conteudo da tabela ³
//³ SC e MV_SEQCORR.											 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc == "CHI" .and. CT2->(FieldPos("CT2_SEGOFI")) > 0

	aTamSeq := TamSX3("CT2_SEGOFI")

	cChaveTab := CTBSQChv( cTipoSeq, cLancPad)

	DbSelectArea("SX5")
	DbSetOrder(1)
	If DbSeek(xFilial("SX5")+"SC"+cChaveTab)
		cSeqOfic := Soma1( Alltrim(X5Descri()), aTamSeq[1])
	Else 
		// chave nova, sugere primeiro numero
		cSeqOfic := StrZero( 1,aTamSeq[1])
	Endif
EndIf
RestArea( aSaveArea )
Return( cSeqOfic )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CTBSQGrv   ³ Autor ³ Lucas			    ³ Data ³ 07/01/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua a gravacao do correlativo no SX5                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbSQGrv(     )      	               					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCTB                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CTBSQGrv( cLancPad )
Local aSaveArea := GetArea()
Local cTipoSeq  := "0"
Local cChaveTab := ""
Local aTamSeq := {}

cTipoSeq := GetNewPar("MV_SEQCORR","1AN")

DEFAULT cLancPad := CT5->CT5_LANPAD

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gravar no campo CT2_SEGOFIC a sequencia do numero correlativo³
//³ conforme legislacao do Chile utilizando o conteudo da tabela ³
//³ SC e MV_SEQCORR.											 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc == "CHI" .and. CT2->(FieldPos("CT2_SEGOFI")) > 0
	aTamSeq := TamSX3("CT2_SEGOFI")

	cChaveTab := CTBSQChv( cTipoSeq, cLancPad)

	DbSelectArea("SX5")
	DbSetOrder(1)
	If DbSeek(xFilial("SX5")+"SC"+cChaveTab)			
		RecLock("SX5",.F.)
	Else
		RecLock("SX5",.T.)
		Replace X5_TABELA	With "SC"
		Replace X5_CHAVE	With cChaveTab
	EndIf 
	
	If AllTrim( cSeqCorr) > Alltrim( X5Descri()) .or. Empty(Alltrim( X5Descri()))
		//nao grava sequencia de correlativo menor, pois o SX5 armazena somente o ultimo 
		Replace X5_DESCRI	With Alltrim(cSeqCorr)
		Replace X5_DESCENG	With Alltrim(cSeqCorr)
		Replace X5_DESCSPA	With Alltrim(cSeqCorr)
	EndIf
	MsUnLock()

EndIf
RestArea( aSaveArea )
Return( cSeqCorr)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CTBSubtoPad³ Autor ³ Leonardo            ³ Data ³ 07/01/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retornar algum lancamento padrao do tipo de comprovante     ³±±
±±³          ³  (quando sublote corresponde ao tipo ( MV_SEQCORR = ??S )  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbSQCor(ExpC1)      	               					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ ExpC1 = Sublote configurado como tipo de comprovante       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCTB - Localizacao Chile                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CTBSubToPad( cSubLote)
Local cLanPad := ""
Local cSeqLan001 := GetNewPar("MV_SQSUB01","500|501|502|563|565|575|576|581")
Local cSeqLan002 := GetNewPar("MV_SQSUB02","510|513|514|560|561|562|564|570|571|590|591|597")
Local cSeqLan003 := GetNewPar("MV_SQSUB03","")

cTipoSeq := GetNewPar("MV_SEQCORR","1AN")

If Subs( cTipoSeq, 3, 1) = "S"

	If cSubLote = "001"
		cLanPad := Iif(Empty(cSeqLan001),"575",Substr(cSeqLan001,1,3)) // ingresos
	ElseIf cSubLote = "002"
		cLanPad := Iif(Empty(cSeqLan002),"570",Substr(cSeqLan002,1,3))//egresos
	Else 
		cLanPad := Iif(Empty(cSeqLan003),"620",Substr(cSeqLan003,1,3)) // traspasos
	EndIf       
EndIf
Return( cLanPad)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CTBSQNaoEx³ Autor ³ Leonardo             ³ Data ³ 28/01/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Controle da concorrencia do numero correlativo             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbSQNaoEx(ExpC1)    	               					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ ExpC1 = Numero a ser consistido                            ³±±
±±³          ³ ExpC2 = Lancamento Padrao (para compor a chave por sublote)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCTB - Localizacao Chile                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CTBSQNaoEx( cNumero, cLancPad,nOpc,dDataLanc)
Local aSaveArea := GetArea()
Local cTipoSeq  := GetNewPar("MV_SEQCORR","1AN")
Local cChaveTab := ""
Local cSubL     := ""
Local cPesqDt   := ""
Local dDataLan	:= Iif (ValType(dDataLanc)<>"D",dDataBase,dDataLanc)
Local cSeculo	:= Subs(Alltrim(Str(Year(dDataLan))),1,2)

DEFAULT cLancPad := CT5->CT5_LANPAD
DEFAULT nOpc := 3

If cPaisLoc == "CHI" .and. CT2->(FieldPos("CT2_SEGOFI")) > 0 .and. (nOpc == 3 .Or. nOpc == 6) 

	cChaveTab := CTBSQChv( cTipoSeq, cLancPad)
	cPesqDt   := cSeculo + Subs( cChaveTab, 1, Len( cChaveTab)-1) 

	If Right(Alltrim(cChaveTab),1) == "0"
	    cSubL := GetMv("MV_SUBLOTE")
		If Empty(cSubL)
		    cSubL := CT2->CT2_SBLOTE
		EndIf
	Else
	    cSubL :=  "00"+Right(Alltrim(cChaveTab),1)
	EndIf

	DbSelectArea( "CT2")
	DBOrderNickName( "CT2CORRELA")
    While dbSeek( xFilial("CT2")+Padr(cNumero,TamSX3("CT2_SEGOFI")[1])+cSubL+cPesqDt ) .or.;//verifica se ja foi gravado
    	 !MayIUseCode( "CT2"+xFilial("CT2")+cChaveTab+cNumero)  //verifica se esta na memoria, sendo usado
        // busca o proximo numero disponivel 
		cNumero := Soma1( cNumero)                                                                                                             	
    EndDo
EndIf

RestArea( aSaveArea )

Return( cNumero)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o	  ³ ImpQuadro³ Autor ³ Lucimara Soares			³ Data ³ 29/11/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Impressao dos Quadros finais do balancete                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe   ³ ImpQuadro()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		  ³ SIGACTB 																	³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ImpQuadro(Tamanho,lDigVer,dData,cMoeda,aQuadro,cDescMoeda,nomeprog,dDataLP,cPicture,nDecimais,lPrintZero,cTpSald)

Local cData 	:=	StrZero(Month(dData),2) +"/" + Str(Year(dData),4)
Local nTotMov	:=	0
Local nResult	:=	0
Local nPtmCorr := 0
Local	nPtmLiq  := 0
Local nReceita := 0
Local nDespesa := 0
Local nVal1		:= 0
Local nVal2		:= 0

Cabec1 := OemToAnsi(STR0029) // "QUADROS DEMONSTRATIVOS"
Cabec2 := " "


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Quadro 1: Totais do Ativo / Passivo.                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
Cabec( Titulo, Cabec1, Cabec2, NomeProg, Tamanho, 15 )

li++           

@li,00 PSAY "+" + Repl( "-", 100 ) + "+"
li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++
@li,00 PSAY "|" + PadC( OemToAnsi(STR0030) , 100, " " ) + "|" // "TOTAIS DO ATIVO / PASSIVO"
li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++   
@li,00 PSAY "+" + Repl( "-", 100 ) + "|"
li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++

DbSelectArea("CT1")
dbSeek( cFilial + aQuadro[1] ) // Totalizadora do Ativo - mv _par08
@li,00 PSAY "|"
If lDigVer 
	@li,02 PSAY Mascara(Alltrim(aQuadro[1])+CT1->CT1_DC)
Else
	@li,02 PSAY Mascara(CT1->CT1_CONTA)
EndIf	

@li,035 PSAY OemToAnsi(STR0031) // "Total do Ativo"

dbSelectArea("cArqTmp")
dbSetOrder(1)
If dbSeek(aQuadro[1])
	nTotMov	:= SALDOATU
	ValorCTB(nTotMov,li,80,17,nDecimais,.T.,cPicture,"1", , , , , ,lPrintZero)
EndIf
@li,101 PSAY "|"

li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++

DbSelectArea("CT1")
dbSeek( cFilial + aQuadro[2]) // Totalizadora do Passivo - mv_par09
@li,00 PSAY "|"
If lDigVer 
	@li,02 PSAY Mascara(Alltrim(CT1->CT1_CONTA)+CT1->CT1_DC)
Else
	@li,02 PSAY Mascara(CT1->CT1_CONTA)
EndIf

@li,35 PSAY OemToAnsi(STR0032) // "Total do Passivo"
dbSelectArea("cArqTmp")
dbSetOrder(1)
If dbSeek(aQuadro[2])
	nTotMov	:= SALDOATU
	ValorCTB(nTotMov,li,80,17,nDecimais,.T.,cPicture,"2", , , , , ,lPrintZero)
EndIf	
@li,101 PSAY "|"

li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++
@li,00 PSAY "+" + Repl( "-", 100 ) + "+"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Quadro 2: Demonstracao de resultados                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
li += 4

@li,00 PSAY "+" + Repl( "-", 100 ) + "+"
li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++
@li,00 PSAY "|" + PadC( OemToAnsi(STR0033) , 100, " " ) + "|" // "DEMONSTRATIVO DE RESULTADOS - MENSAL"
li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++ 
@li,00 PSAY "+" + Repl( "-", 100 ) + "|"
li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++

DbSelectArea("CT1")
dbSeek( cFilial + aQuadro[3] ) // Resultado a debito

@li,00 PSAY "|"
If lDigVer 
	@li,02 PSAY Mascara(Alltrim(CT1->CT1_CONTA)+CT1->CT1_DC)
Else
	@li,02 PSAY Mascara(CT1->CT1_CONTA)
EndIf	
@li,35 PSAY OemToAnsi(STR0036)  + OemToAnsi(STR0034) // "CONTAS DE RESULTADO - "
DbSelectArea("cArqTmp")
DbSetOrder(1)
If DbSeek(aQuadro[3])
	nTotMov	:= MOVIMENTO
	nVal1 	:= SALDOATU
	ValorCTB(nTotMov,li,80,17,nDecimais,.T.,cPicture,"1", , , , , ,lPrintZero)
Endif	
nResult := nTotMov

@li,101 PSAY "|"

li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++

DbSelectArea("CT1")
dbSeek( cFilial + aQuadro[4] ) // Resultado a credito

@li,00 PSAY "|"
If lDigVer 
	@li,02 PSAY Mascara(Alltrim(CT1->CT1_CONTA)+CT1->CT1_DC)
Else
	@li,02 PSAY Mascara(CT1->CT1_CONTA)
EndIf	
@li,35 PSAY OemToAnsi(STR0036)  + OemToAnsi(STR0035) // "CONTAS DE RESULTADO - "
DbSelectArea("cArqTmp")
DbSetOrder(1)
If DbSeek(aQuadro[4])
	nTotMov	:= MOVIMENTO
	nVal2	:= SALDOATU
	ValorCTB(nTotMov,li,80,17,nDecimais,.T.,cPicture,"2", , , , , ,lPrintZero)
Endif
nResult	+= nTotMov

DbSelectArea("CT1")
@li,101 PSAY "|"

li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++

@li,00 PSAY "|"
@li,02 PSAY OemToAnsi(STR0037) + cData // "RESULTADO DO MES "

ValorCTB(nResult,li,80,17,nDecimais,.T.,cPicture,"1", , , , , ,lPrintZero)
@li,101 PSAY "|"

li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++

@li,00 PSAY "|"
@li,02 PSAY OemToAnsi(STR0038) + cData  // "RESULTADO ACUMULADO ATE "
nTotMov	:= nVal1+nVal2
ValorCTB(nTotMov,li,80,17,nDecimais,.T.,cPicture,"1", , , , , ,lPrintZero)
@li,101 PSAY "|"

li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++
@li,00 PSAY "+" + Repl( "-", 100 ) + "+"


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Quadro 3: Demonstracao de Patrimonio Liquido destacado       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
Cabec( Titulo, Cabec1, Cabec2, NomeProg, Tamanho, 15 )

@li,00 PSAY "+" + Repl( "-", 100 ) + "+"
li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++
@li,00 PSAY "|" + ;
		 PadC( OemToAnsi(STR0039), 100, " " ) + "|" // "DEMONSTRACAO DO PATRIMONIO LIQUIDO DESTACADO"

li++		 
@li,00 PSAY "|" + PadC( OemToAnsi(STR0040) + cData, 100, " " ) + "|" // "PARA O MES "

li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++
@li,00 PSAY "+" + Repl( "-", 100 ) + "|"
li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Procura a conta de patrimonio Liquido.                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
dbSeek( cFilial + aQuadro[5] )

@ li,00 PSAY OemToAnsi(STR0041) // "| PATRIMONIO LIQUIDO"
DbSelectArea("cArqTmp")
DbSetOrder(1)
If DbSeek(aQuadro[5])
	nPtmLiq := SALDOATU
	ValorCTB(nPtmLiq,li,80,17,nDecimais,.T.,cPicture,"2", , , , , ,lPrintZero)
Endif	               
DbSelectArea("CT1")
@ li,101 PSAY "|"

li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Procura a conta de receita.                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
dbSeek( cFilial + aQuadro[6] )

@li,00 PSAY OemToAnsi(STR0042) // "| TOTAL DA RECEITA"
DbSelectArea("cArqTmp")
DbSetOrder(1)
If DbSeek(aQuadro[6])
   nReceita := SALDOATU
	ValorCTB(nReceita,li,80,17,nDecimais,.T.,cPicture,"2", , , , , ,lPrintZero)
Endif
DbSelectArea("CT1")	
@li,101 PSAY "|"

li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Procura a conta de despesa.                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
dbSeek( cFilial + aQuadro[7] )

@li,00 PSAY OemToAnsi(STR0043) // "| TOTAL DA DESPESA"
DbselectArea("cArqTmp")
DbSetOrder(1)
If DbSeek(aQuadro[7])
	nDespesa := SALDOATU
	ValorCTB(nDespesa,li,80,17,nDecimais,.T.,cPicture,"1", , , , , ,lPrintZero)
Endif
DbSelectArea("CT1")	
@li,101 PSAY "|"

li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Calcula o patrimonio liquido corrigido.                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
nPtmCorr := nPtmLiq + nReceita + nDespesa
@li,00 PSAY OemToAnsi(STR0044)+cData // "| PATRIMONIO LIQUIDO CORRIGIDO " + cData
ValorCTB(nPtmCorr,li,80,17,nDecimais,.T.,cPicture,"2", , , , , ,lPrintZero)
@li,101 PSAY "|"

li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Calcula Lancamento de Correcao		                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
nLctoCorr := nPtmLiq + ( nReceita + nDespesa )
@li,00 PSAY OemToAnsi(STR0045) // "| LANCAMENTO DE CORRECAO"
ValorCTB(nLctoCorr,li,80,17,nDecimais,.T.,cPicture,"2", , , , , ,lPrintZero)
@li,101 PSAY "|"

li++
@li,00 PSAY "|" + Repl( " ", 100 ) + "|"
li++
@li,00 PSAY "|" + Repl( "-", 100 ) + "|"
li++

/* Modo de construcao do quadro 3 - conforme analise SBPS
1 - Patrimonio liquido
6.0.0.00.00.2

2 - Receita
7.0.0.00.00.9

3 - Despesa
8.0.0.00.00.6

4 - Patrimonio Liquido corrigido ate a data
1 + 2 + 3

6 - Lancamento de correcao
1 + ( 2 + 3 ) 
*/


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbCarTxt   ³ Autor ³ Lucimara Soares      ³ Data ³ 02.12.2002			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Carrega o arquivo TXT. Caso o arquivo não exista, a função o cria.	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbCarTxt(aMatriz)                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCtb                                               	    			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aGrava	   = Matriz utilizada para gravar o arquivo Txt 	         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

FUNCTION CtbCarTxt(aGrava)
                    
Local aSaveArea	:= GetArea()
Local nBytes := 0
Local nTamArq
Local xBuffer
Local nLinha := 0

//Caso a matriz esteja nula, eu leio o CTBQUAD.INI
If aGrava == Nil

	IF !file("CTBQUADR.INI")
		nHdlQuad := MSFCreate("CTBQUADR.INI",0)
		IF nHdlQuad == -1
			HELP(" ",1,"CTB_ERROR")
			Final("Erro F_"+str(ferror(),2)+" em CTBQUADR.INI")
		Endif
		Fclose(nHdlQuad)
	EndIf

	nHdlQuad := FOPEN("CTBQuadr.INI",70)   

	If nHdlQuad <0
		HELP(" ",1,"CTB_ERROR")
		Final("CTBQUADR.INI")
	EndIf

	nTamArq:=FSEEK(nHdlQuad,0,2)		// VerIfica tamanho do arquivo
	FSEEK(nHdlQuad,0,0)					// Volta para inicio do arquivo

	While nBytes<nTamArq
		xBuffer:=Space(72)
		FREAD(nHdlQuad,@xBuffer,72)
		nLinha++
		If nLinha <= Len(aQuadro)
			aQuadro[nLinha]:= Left(Alltrim(xBuffer), Len(CriaVar("CT1_CONTA")))
		Endif
		nBytes+=72
//		Dbskip()
	EndDo
Else
	nHdlQuad := MSFCreate("CTBQUADR.INI",0)
	IF nHdlQuad == -1
		HELP(" ",1,"CTB_ERROR")
		Final("Erro F_"+str(ferror(),2)+" em CTBQUADR.INI")
	Endif
	
	For nLinha:=1 To Len(aGrava)	
		fWrite(nHdlQuad,Left(aGrava[nLinha] + Space(70), 70) +chr(13)+chr(10))
	Next	

EndIf  

fClose(nHdlQuad)
RestArea(aSaveArea)

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbOpQuad   ³ Autor ³ Lucimara Soares      ³ Data ³ 06.12.2002			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Monta a tela com as perguntas referentes aos quadros contabeis.  		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbOpQuad(lDigita)                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCtb                                                   				³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ lDigita	   = Define se alguma digitação foi feita.    			    	³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbOpQuad(lDigita)


Local nOpca 	:= 1 

Local cPerg1	:= STR0046 + "?"	//Conta Tot. Ativo
Local cPerg2	:= STR0047 + "?"  //Conta Tot. Passivo
Local cPerg3	:= STR0048 + "?"  //Conta Tot. Resultado a Débito  
Local cPerg4	:= STR0049 + "?"  //Conta Tot. Resultado a Crédito
Local cPerg5	:= STR0050 + "?"  //Conta Tot. Patrimônio Líquido
Local cPerg6	:= STR0051 + "?"  //Conta Tot. das Receitas
Local cPerg7	:= STR0052 + "?"  //Conta Tot. das Despesas
Local cPerg8	:= STR0053 + "?"  //Conta Tot. PL Corrigido

Local cF3 := "CT1"

If !lDigita
	Return 
EndIf
	
DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0054) FROM 33,25 TO 300,410 PIXEL  //"Config. Parametros"
	@ 001,005 TO 130, 185 OF oDlg PIXEL
	@ 004,008 	SAY cPerg1 SIZE 90, 7 OF oDlg PIXEL  
	@ 004,096 	MSGET aQuadro[1]Pict "@!";
					F3 cF3 	SIZE 50,10 OF oDlg PIXEL ;
				
	@ 019,008 	SAY cPerg2 SIZE 90, 7 OF oDlg PIXEL  
	@ 019,096 	MSGET aQuadro[2]Pict "@!";
					F3 cF3 SIZE 50,10 OF oDlg PIXEL 
 
	@ 034,008 	SAY cPerg3 SIZE 90, 7 OF oDlg PIXEL  
	@ 034,096 	MSGET aQuadro[3]Pict "@!";
					F3 cF3 SIZE 50,10 OF oDlg PIXEL 
	
	@ 049,008 	SAY cPerg4 SIZE 90, 7 OF oDlg PIXEL  
	@ 049,096 	MSGET aQuadro[4]Pict "@!";
					F3 cF3 SIZE 50,10 OF oDlg PIXEL 			
 
	@ 064,008 	SAY cPerg5 SIZE 90, 7 OF oDlg PIXEL  
	@ 064,096 	MSGET aQuadro[5]Pict "@!";
					F3 cF3 SIZE 50,10 OF oDlg PIXEL 
	
	@ 079,008 	SAY cPerg6 SIZE 90, 7 OF oDlg PIXEL  
	@ 079,096 	MSGET aQuadro[6]Pict "@!";
					F3 cF3 SIZE 50,10 OF oDlg PIXEL 
	
	@ 094,008 	SAY cPerg7 SIZE 90, 7 OF oDlg PIXEL  
	@ 094,096 	MSGET aQuadro[7]Pict "@!";
					F3 cF3 SIZE 50,10 OF oDlg PIXEL 

	@ 109,008 	SAY cPerg8 SIZE 90, 7 OF oDlg PIXEL  
	@ 109,096 	MSGET aQuadro[8] Pict "@!";
					F3 cF3 SIZE 50,10 OF oDlg PIXEL 

	
	DEFINE SBUTTON FROM 05, 156 TYPE 1 ACTION (nOpca := 1,oDlg:End())ENABLE OF oDlg
  
	DEFINE SBUTTON FROM 18, 156 TYPE 2 ACTION (nOpca:=0,oDlg:End()) ENABLE OF oDlg
	ACTIVATE MSDIALOG oDlg CENTERED ON INIT (nOpca := 0, .T.)	// Zero nOpca caso 
                                                               //	para saida com ESC
                                                               
If nOpcA = 1
	CtbCarTxt(aQuadro)
Endif                                                               


Return 
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbTxtGer   ³ Autor ³ Lucimara Soares      ³ Data ³ 26.03.2003		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Carrega o arquivo TXT com os valores do filtro por Plano Gerencial	³±± 
±±³			 ³Caso o arquivo não exista, a função o cria.							³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbTxtGer(aMatriz)                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCtb                                               	    		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aGrava	   = Matriz utilizada para gravar o arquivo Txt 	        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

FUNCTION CtbTxtGer(aGrava)

Local nBytes := 0
Local nTamArq
Local xBuffer
Local nLinha := 0


//Caso a matriz esteja nula, eu leio o CTBGEREN.INI
If aGrava == Nil

	IF !file("CTBGEREN.INI")
		nHdlGer := MSFCreate("CTBGEREN.INI",0)
		IF nHdlGer == -1
			HELP(" ",1,"CTB_ERROR")
			Final("Erro F_"+str(ferror(),2)+" em CTBGEREN.INI")
		Endif
		Fclose(nHdlGer)
	EndIf

	nHdlGer := FOPEN("CTBGEREN.INI",64)

	If nHdlGer <0
		HELP(" ",1,"CTB_ERROR")
		Final("CTBGEREN.INI")
	EndIf

	nTamArq:=FSEEK(nHdlGer,0,2)		// VerIfica tamanho do arquivo
	FSEEK(nHdlGer,0,0)					// Volta para inicio do arquivo

	While nBytes<nTamArq
		xBuffer:=Space(72)
		FREAD(nHdlGer,@xBuffer,72)
		nLinha++
		If nLinha <= Len(aGeren)
			aGeren[nLinha]:= Left(Alltrim(xBuffer), Len(CriaVar("CT1_CONTA")))
		Endif
		nBytes+=70
		Dbskip()
	EndDo
Else
	nHdlGer := MSFCreate("CTBGEREN.INI",0)
	IF nHdlGer == -1
		HELP(" ",1,"CTB_ERROR")
		Final("Erro F_"+str(ferror(),2)+" em CTBGEREN.INI")
	Endif
	
	For nLinha:=1 To Len(aGrava)	
		fWrite(nHdlGer,Left(aGrava[nLinha] + Space(70), 70) +chr(13)+chr(10))
	Next	

EndIf  

fClose(nHdlGer)
Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbOpGeren  ³ Autor ³ Lucimara Soares      ³ Data ³ 26.03.2003		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Monta a tela com as perguntas referentes ao filtro por Pl. Gerencial ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbOpGeren(lDigita)                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCtb                                                   			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ lDigita	   = Define se alguma digitação foi feita.    			   	³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbOpGeren(lDigita)


Local nOpca 	:= 1 

Local cPerg1	:= STR0057 + "?"  //Da Conta
Local cPerg2	:= STR0058 + "?"  //Ate a Conta
Local cPerg3	:= STR0059 + "?"  //Do Centro de Custo 
Local cPerg4	:= STR0060 + "?"  //Ate o Centro de Custo
Local cPerg5	:= STR0061 + "?"  //Do Item
Local cPerg6	:= STR0062 + "?"  //Ate o Item
Local cPerg7	:= STR0063 + "?"  //Da Classe de Valor
Local cPerg8	:= STR0064 + "?"  //Ate a Classe de Valor

Local cF3Conta	:= "CT1"
Local cF3Custo	:= "CTT"
Local cF3Item	:= "CTD"
Local cF3CLVL	:= "CTH"

If !lDigita
	Return 
EndIf
	
DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0054) FROM 33,25 TO 300,410 PIXEL  //"Config. Parametros"
	@ 001,005 TO 130, 190 OF oDlg PIXEL
	@ 004,008 	SAY cPerg1 SIZE 90, 7 OF oDlg PIXEL  
	@ 004,096 	MSGET aGeren[1] Pict "@!";
					F3 cF3Conta 	SIZE 50,10 OF oDlg PIXEL ;
				
	@ 019,008 	SAY cPerg2 SIZE 90, 7 OF oDlg PIXEL  
	@ 019,096 	MSGET aGeren[2] Pict "@!";
					F3 cF3Conta SIZE 50,10 OF oDlg PIXEL 
 
	@ 034,008 	SAY cPerg3 SIZE 90, 7 OF oDlg PIXEL  
	@ 034,096 	MSGET aGeren[3] Pict "@!";
					F3 cF3Custo SIZE 50,10 OF oDlg PIXEL 
	
	@ 049,008 	SAY cPerg4 SIZE 90, 7 OF oDlg PIXEL  
	@ 049,096 	MSGET aGeren[4] Pict "@!";
					F3 cF3Custo SIZE 50,10 OF oDlg PIXEL 			
 
	@ 064,008 	SAY cPerg5 SIZE 90, 7 OF oDlg PIXEL  
	@ 064,096 	MSGET aGeren[5] Pict "@!";
					F3 cF3Item SIZE 50,10 OF oDlg PIXEL 
	
	@ 079,008 	SAY cPerg6 SIZE 90, 7 OF oDlg PIXEL  
	@ 079,096 	MSGET aGeren[6] Pict "@!";
					F3 cF3Item SIZE 50,10 OF oDlg PIXEL 
	
	@ 094,008 	SAY cPerg7 SIZE 90, 7 OF oDlg PIXEL  
	@ 094,096 	MSGET aGeren[7] Pict "@!";
					F3 cF3CLVL SIZE 50,10 OF oDlg PIXEL 

	@ 109,008 	SAY cPerg8 SIZE 90, 7 OF oDlg PIXEL  
	@ 109,096 	MSGET aGeren[8] Pict "@!";
					F3 cF3CLVL SIZE 50,10 OF oDlg PIXEL 

	
	DEFINE SBUTTON FROM 05, 156 TYPE 1 ACTION (nOpca := 1,oDlg:End())ENABLE OF oDlg
  
	DEFINE SBUTTON FROM 18, 156 TYPE 2 ACTION (nOpca:=0,oDlg:End()) ENABLE OF oDlg
	ACTIVATE MSDIALOG oDlg CENTERED ON INIT (nOpca := 0, .T.)	// Zero nOpca caso 
                                                               //	para saida com ESC
                                                               
If nOpcA = 1
	CtbTxtGer(aGeren)
Endif                                                               

Return 
        
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbValDel   ³ Autor ³ Simone Mie Sato      ³ Data ³ 15.05.2003		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verificar se pode excluir o registro.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbValDel()                                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaCtb                                                   			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cArqDel	   = Arquivo em que o registro sera excluido.			   	³±±
±±³          ³ aArqSeek    = Array contendo as tabelas a serem verificadas.  	    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbValDel(cArqDel,aArqSeek)

Local aSaveArea	:= GetArea()
Local lRet		:= .T.   
Local cFilBack	:= cFilAnt
Local cModo		:= ""
Local nRecnoSM0	:= 0
Local nArqs		:= 0

dbSelectarea("SX2")
dbSetOrder(1)
If MsSeek(cArqDel)   
	cModo	:= SX2->X2_MODO
EndIf                      

If cModo == "C"	//Se a tabela do registro a ser excluido for compartilhado, devera ser verificado em todas as filiais
	dbSelectArea("SM0") 
	nRecnoSM0	:= Recno()
	dbGoTop()
	MsSeek(cEmpAnt)
	While !Eof() .And. SM0->M0_CODIGO == cEmpAnt
		For nArqs	:= 1 to Len(aArqSeek)
			dbSelectArea(aArqSeek[nArqs][1])	//Tabela a ser verificada
			dbSetOrder(aArqSeek[nArqs][2])		//Ordem utilizada
			cFilAnt	:= SM0->M0_CODFIL
			If MsSeek(xFilial()+aArqSeek[nArqs][3])		//Chave a ser procurada, sem a filial
				lRet	:= .F.
				cFilAnt	:= cFilBack
				dbSelectArea("SM0")
				dbGoto(nRecnoSM0)  
				RestArea(aSaveArea)				
				Return(lRet)
			EndIf		
	    Next       
	    dbSelectArea("SM0")
		dbSkip()
	End
Else
	For nArqs	:= 1 to Len(aArqSeek)
		dbSelectArea(aArqSeek[nArqs][1])	//Tabela a ser verificada
		dbSetOrder(aArqSeek[nArqs][2])		//Ordem utilizada
		If MsSeek(xFilial()+aArqSeek[nArqs][3])
			lRet	:= .F.
			Exit		//Sai do For/Next
		EndIf
	Next                                      	
EndIf                                         

RestArea(aSaveArea)
Return(lRet)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³CtbSldLP   ³ Autor ³ Simone Mie Sato      ³ Data ³ 11.12.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna o valor deb./cred. das apurac. a serem desconsider. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbSldLP()                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ {nDebito,nCredito}                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAlias = Alias do arquivo                                  ³±±
±±³          ³ dDataLP= Data de apuracao                                  ³±±
±±³          ³ bCondLP= Bloco ref. condicao (apuracao)		              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbSldLP(cAlias,dDataLP,bCondLP,dData)

Local aSaveArea	:= GetArea()    
Local nDebito	:= 0
Local nCredito	:= 0

While !Eof() .And. Eval(bCondLP)
//	If (&(cAlias+"_DATA") < dData .And. &(cAlias+"_DATA") <> dDataLP)
	If (&(cAlias+"_DATA") < dData .And. &(cAlias+"_DATA") < dDataLP)
		dbSkip()
		Loop
	EndIf	
	
	If (&(cAlias+"_DATA") > dData)
		dbSkip()
		Loop
	EndIf	
	
	nDebito		+= &(cAlias+"_DEBITO")
	nCredito	+= &(cAlias+"_CREDIT")
	dbSkip()
End


RestArea(aSaveArea)

Return{nDebito,nCredito}

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CtbCCSup  ³ Autor ³ Simone Mie Sato       ³ Data ³ 02.10.03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera Codigo do Centro de Custo Superior                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbCCSup(cCodigo)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³cCod                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Centro de Custo                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbCCSup(cCodigo)

Local aAmbSave 	:= { Alias(), Indexord(), Recno() }
Local nTamCC	:= Len(CriaVar("CTT_CUSTO"))
Local aAmbCTT  := { CTT->(IndexOrd()) , CTT->(Recno()) }
Local cCod , nCont

cCodigo			:= Alltrim(cCodigo)

dbSelectArea("CTT") ; dbSetOrder(1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PONTO DE ENTRADA CTBCCSUP                            ³
//³ Criado para gerar c.c.  superior caso nao            ³
//³ siga a regra padrao do Sistema.                      ³
//³ Recebe em PARAMIXB o centro de custo atual.          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("CTBCCSUP")
	cCod := ExecBlock("CTBCCSUP",.F.,.F.,cCodigo)
Else
	For nCont := 1 to Len(cCodigo)
		cCod  := padr(Substr(cCodigo,1,Len(cCodigo)-nCont),nTamCC)
		If MsSeek(xFilial()+cCod,.f.)
			cCod := CTT->CTT_CUSTO
			Exit
		EndIf
	Next
EndIf

CTT->(DbSetOrder(aAmbCTT[1])) ; CTT->(DbGoto(aAmbCTT[2]))
DbSelectArea(aAmbSave[1]) ; DbSetOrder(aAmbSave[2]) ; DbGoto(aAmbSave[3])

Return cCod

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CtbItemSup³ Autor ³ Simone Mie Sato       ³ Data ³ 03.10.03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera Codigo do Item Contabil Superior                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbItemSup(cCodigo)                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³cCod                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Item Contabil                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbItemSup(cCodigo)

Local aAmbSave 	:= { Alias(), Indexord(), Recno() }
Local nTamItem	:= Len(CriaVar("CTD_ITEM"))
Local aAmbCTD	:= { CTD->(IndexOrd()) , CTD->(Recno()) }
Local cCod , nCont

cCodigo			:= Alltrim(cCodigo)

dbSelectArea("CTD") ; dbSetOrder(1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PONTO DE ENTRADA CTBITSUP                            ³
//³ Criado para gerar item  superior caso nao            ³
//³ siga a regra padrao do Sistema.                      ³
//³ Recebe em PARAMIXB o item contabil  atual.           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("CTBITSUP")
	cCod := ExecBlock("CTBITSUP",.F.,.F.,cCodigo)
Else
	For nCont := 1 to Len(cCodigo)
		cCod  := padr(Substr(cCodigo,1,Len(cCodigo)-nCont),nTamItem)
		If MsSeek(xFilial()+cCod,.f.)
			cCod := CTD->CTD_ITEM 
			Exit
		EndIf
	Next
EndIf

CTD->(DbSetOrder(aAmbCTD[1])) ; CTD->(DbGoto(aAmbCTD[2]))
DbSelectArea(aAmbSave[1]) ; DbSetOrder(aAmbSave[2]) ; DbGoto(aAmbSave[3])

Return cCod


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CtbClVlSup³ Autor ³ Simone Mie Sato       ³ Data ³ 03.10.03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera Codigo da Cl.Valor Superior                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbClVlSup(cCodigo)                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³cCod                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo da Classe de Valor                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbClVlSup(cCodigo)

Local aAmbSave 	:= { Alias(), Indexord(), Recno() }
Local nTamClVl	:= Len(CriaVar("CTH_CLVL"))
Local aAmbCTH	:= { CTH->(IndexOrd()) , CTH->(Recno()) }
Local cCod , nCont

cCodigo			:= Alltrim(cCodigo)

dbSelectArea("CTH") ; dbSetOrder(1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PONTO DE ENTRADA CTBCVSUP                            ³
//³ Criado para gerar Cl.Vlr. superior caso nao          ³
//³ siga a regra padrao do Sistema.                      ³
//³ Recebe em PARAMIXB a cl.Valor Atual.                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("CTBCVSUP")
	cCod := ExecBlock("CTBCVSUP",.F.,.F.,cCodigo)
Else
	For nCont := 1 to Len(cCodigo)
		cCod  := padr(Substr(cCodigo,1,Len(cCodigo)-nCont),nTamClVl)
		If MsSeek(xFilial()+cCod,.f.)
			cCod := CTH->CTH_CLVL 
			Exit
		EndIf
	Next
EndIf

CTH->(DbSetOrder(aAmbCTH[1])) ; CTH->(DbGoto(aAmbCTH[2]))
DbSelectArea(aAmbSave[1]) ; DbSetOrder(aAmbSave[2]) ; DbGoto(aAmbSave[3])

Return cCod

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CtbQbPg   ºAutor  ³Marcos S. Lobo      º Data ³  12/02/03   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Controla a quebra de pagina dos relatorios SIGACTB          º±±
±±º          ³quando possuem os parametros de PAG.INICAL-FINAL-REINICIAR  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro1³ lNewVars  = (.T.=Inicializa variaveis/.F.=Trata Quebra)    º±±
±±º         2³ nPagIni 	 = Pagina Inicial do relatorio.               	  º±±
±±º         3³ nPagFim 	 = Pagina Final do relatorio               	 	  º±±
±±º         4³ nReinicia = Pagina ao Reiniciar do relatorio               º±±
±±º         5³ m_pag 	 = Numero da pagina usada na Cabec()              º±±
±±º         6³ nBloco    = Bloco de paginas (intervalo de quebra)		  º±±
±±º         7³ nBlCount  = Contador de páginas (zerado na qebra de bloco) º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CtbQbPg(lNewVars,nPagIni,nPagFim,nReinicia,m_pag,nBloco,nBlCount)
///As variáveis nPagIni,nPagFim,nReinicia,m_pag,nBloco,nBlCount devem ser declaradas na rotina chamadora
///e na chamada desta função como @<parametro> para obter o retorno após as alterações de conteúdo desta função.
DEFAULT lNewVars := .F.

If lNewVars					/// INICIALIZA AS VARIAVEIS
	nBloco		:= (nPagFim+1) - nPagIni				/// (PAG. FIM + 1) - PAG. INICIAL - BLOCO DE PAG. PARA IMPRESSAO
	nBlCount	:= 0
	m_pag		:= nPagIni
Else						/// NAO INICIALIZA - TRATA A QUEBRA DE PAGINA
	nBlCount++
	If nBlCount > nBloco 							/// SE A QUANTIDADE DE PAGINAS IMPRESSAO FOR IGUAL AO BLOCO DEFINIDO
		If nReinicia > nPagFim						/// SE A PAG. DE REINICIO FOR MAIOR QUE A PAGINA FINAL (ATUAL)
			nUltPg	  := m_pag						/// GUARDA A ULTIMA PAG. IMPRESSA
			m_pag 	  := nReinicia					/// REINICIA A NUMERACAO DE PAG. (m_pag atual ainda não foi)
			nPagFim   := nReinicia+nBloco 			/// DEFINE O NOVO NUMERO DA PAGINA FIM
			nReinicia := nPagFim+(nReinicia-nUltPg)	/// DEFINE A PROX. PAG. AO REINICIAR PELA DIFERENCA COM  FINAL
		Else										/// SE A PAG. DE REINICIO FOR MENOR OU IGUAL A PAGINA FINAL                                                                
			m_pag := nReinicia						/// SO REINICIA A NUMERACAO DE PAG.
		Endif
		nBlCount := 1
	EndIf	
Endif

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CtbRelDig ºAutor  ³Simone Mie Sato     º Data ³  30/01/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna ate qual digito da entidade contabil sera impresso  º±±
±±º          ³no Relatorio.                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro1³ cSegAte   = Ate qual segm.da masc. contab.sera considerado.º±±
±±º         2³ cMascara	 = Qual a mascara a ser considerada.          	  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CtbRelDig(cSegAte,cMascara) 

Local aSaveArea	:= GetArea()
Local nSegAte	:= 0
Local nCont		:= 0
Local nDigitAte	:= 0

nSegAte	:= Val(cSegAte) *2
For nCont := 1 to nSegAte STEP 2
	nDigitAte += Val(Subs(cMascara,nCont,2))			
Next nCont                                      


RestArea(aSaveARea)

Return(nDigitAte)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³CtbExDtFim³ Autor ³ Simone Mie Sato       ³ Data ³ 21.05.04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verificar se o campo DTEXSF existe.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbExDtFim()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. / .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Entidade                                           ³±±
±±³          ³ ExpD1 = Data                                               ³±±
±±³          ³ ExpC2 = Alias                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbExDtFim(cCadAlias) 

Local aSaveArea	:= GetArea()
Local lRet		:= .F.


If (cCadAlias)->(FieldPos((cCadAlias)+"_DTEXSF")) > 0 
	lRet	:= .T.
EndIf

RestArea(aSaveArea)

Return(lRet)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³CtbVlDtFim³ Autor ³ Simone Mie Sato       ³ Data ³ 21.05.04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida a data de existencia final da entidades.            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbVlDtFim(cCadAlias)                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. / .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Entidade                                           ³±±
±±³          ³ ExpD1 = Data                                               ³±±
±±³          ³ ExpC2 = Alias                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbVlDtFim(cCadAlias,dDataIni) 

Local aSaveArea	:= GetArea()
Local lRet		:= .T.


If !Empty((cCadAlias)->&(cCadAlias+"_DTEXSF")) .And. (dtos(dDataIni) > DTOS((cCadAlias)->&(cCadAlias+"_DTEXSF")))
	lRet	:= .F.
EndIf

RestArea(aSaveArea)

Return(lRet)